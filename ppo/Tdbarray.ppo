#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 23 ".\Prg\Tdbarray.prg"
static __aTDbV := {}





function TDbVirtual( cAlias, cClassName )

    local n := 0
    local hCls := 0
    local __oDb


    local TVCls := "T" + upper( if( empty( cClassName ),  Alias( xArea( cAlias ) ), cClassName ) )

    if ( n := AScan( __aTDbV, { |aClass| aClass[ 1 ] == TVCls } ) ) == 0
        _HB_CLASS TVCls
        __oDb := HbClass():New( TVCls, { "TDBARRAY" } )
        __oDb:Create()
        hCls := __oDb:hClass
        AAdd( __aTDbV, { TVCls, hCls, 1 } )
    else
        ++__aTDbV[ n, 3 ]
        hCls := __aTDbV[ n, 2 ]
    endif
    return( __clsInst( hCls ) )



static function GenData( o, cName, i, aType )

local nClassH

    nClassH := o:ClassH


    __clsAddMsg( nClassH, cName,  { | o | o:aRecords[ o:RecNo, i ] }, 3 )

    __clsAddMsg( nClassH, "_" + cName,  { | o, Val | o:aRecords[ o:RecNo, i ] := Val }, 3 )

return( o )



































_HB_CLASS TDbArray ; UTILITY FUNCTION TDbArray(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TDbArray" , { HBObject():Classh } ) ) ;

    _HB_MEMBER { oDbf} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oDbf" }, .F., .F. ), )

    _HB_MEMBER { bFilter} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bFilter" }, .F., .F. ), )




    _HB_MEMBER {AS ARRAY aFields,    aRecords,   aBlank,     aStatus} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY",, nScope + IIF( .F., 32, 0 ), { "aFields" , "aRecords" , "aBlank" , "aStatus" }, .F., .F. ), )



    _HB_MEMBER {AS LOGICAL Eof,        Bof,        Used} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL",, nScope + IIF( .F., 32, 0 ), { "Eof" , "Bof" , "Used" }, .F., .F. ), )


    _HB_MEMBER {AS CHARACTER cAlias,     cComment} ; IIF( !.F., s_oClass:AddMultiData( "CHARACTER",, nScope + IIF( .F., 32, 0 ), { "cAlias" , "cComment" }, .F., .F. ), )




    _HB_MEMBER {AS NUMERIC nRecIni,    RecNo,      LastRec,    FCount} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nRecIni" , "RecNo" , "LastRec" , "FCount" }, .F., .F. ), )

    _HB_MEMBER New( cAlias, aRecords, lDatas, cComment) AS CLASS TDbArray; IIF( .F., s_oClass:ModMethod( "New", @TDbArray_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TDbArray_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

    _HB_MEMBER DefNew( cComment) AS CLASS TDbArray; IIF( .F., s_oClass:ModMethod( "DefNew", @TDbArray_DefNew(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DefNew", @TDbArray_DefNew(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER AddField( cName, cType, nLen, nDec); IIF( .F., s_oClass:ModMethod( "AddField", @TDbArray_AddField(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AddField", @TDbArray_AddField(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER Activate(); IIF( .F., s_oClass:ModMethod( "Activate", @TDbArray_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Activate", @TDbArray_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

    _HB_MEMBER Append(); IIF( .F., s_oClass:ModMethod( "Append", @TDbArray_Append(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Append", @TDbArray_Append(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER Update( aVal); IIF( .F., s_oClass:ModMethod( "Update", @TDbArray_Update(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Update", @TDbArray_Update(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER Insert(aVal); IIF( .F., s_oClass:ModInline( "Insert", {|Self,aVal | Self, ::Append():Update( aVal ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Insert", {|Self,aVal | Self, ::Append():Update( aVal ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

    _HB_MEMBER Delete(); IIF( .F., s_oClass:ModMethod( "Delete", @TDbArray__Delete(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ), s_oClass:AddMethod( "Delete", @TDbArray__Delete(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ) );
    _HB_MEMBER Zap(); IIF( .F., s_oClass:ModMethod( "Zap", @TDbArray__Zap(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ), s_oClass:AddMethod( "Zap", @TDbArray__Zap(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ) );

    _HB_MEMBER GoTo( n); IIF( .F., s_oClass:ModMethod( "GoTo", @TDbArray_GoTo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoTo", @TDbArray_GoTo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER GoTop(); IIF( .F., s_oClass:ModInline( "GoTop", {|Self | Self, ::GoTo( 1 ), Self }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GoTop", {|Self | Self, ::GoTo( 1 ), Self }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
    _HB_MEMBER GoBottom(); IIF( .F., s_oClass:ModInline( "GoBottom", {|Self | Self, ::GoTo( ::LastRec ), Self }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GoBottom", {|Self | Self, ::GoTo( ::LastRec ), Self }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

    _HB_MEMBER Skip( n); IIF( .F., s_oClass:ModMethod( "Skip", @TDbArray_Skip(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Skip", @TDbArray_Skip(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER Skipper( n); IIF( .F., s_oClass:ModMethod( "Skipper", @TDbArray_Skipper(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Skipper", @TDbArray_Skipper(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

    _HB_MEMBER Record(); IIF( .F., s_oClass:ModInline( "Record", {|Self | Self, ::aRecords[ ::RecNo ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Record", {|Self | Self, ::aRecords[ ::RecNo ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
    _HB_MEMBER RecCount(); IIF( .F., s_oClass:ModInline( "RecCount", {|Self | Self, len( ::aRecords ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "RecCount", {|Self | Self, len( ::aRecords ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

    _HB_MEMBER Eval(bBlock); IIF( .F., s_oClass:ModInline( "Eval", {|Self,bBlock | Self, AEval( ::aRecords, bBlock ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Eval", {|Self,bBlock | Self, AEval( ::aRecords, bBlock ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
    _HB_MEMBER SetBrowse( oBrw); IIF( .F., s_oClass:ModMethod( "SetBrowse", @TDbArray_SetBrowse(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetBrowse", @TDbArray_SetBrowse(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

    _HB_MEMBER Load( bFor, bWhile); IIF( .F., s_oClass:ModMethod( "Load", @TDbArray_Load(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Load", @TDbArray_Load(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER RecLoad( nRec, lNew); IIF( .F., s_oClass:ModMethod( "RecLoad", @TDbArray_RecLoad(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RecLoad", @TDbArray_RecLoad(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

    _HB_MEMBER Save(); IIF( .F., s_oClass:ModMethod( "Save", @TDbArray_Save(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Save", @TDbArray_Save(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER RecSave( nRec); IIF( .F., s_oClass:ModMethod( "RecSave", @TDbArray_RecSave(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RecSave", @TDbArray_RecSave(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

    _HB_MEMBER Clean(); IIF( .F., s_oClass:ModInline( "Clean", {|Self | Self, ::aRecords := {} }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Clean", {|Self | Self, ::aRecords := {} }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

    _HB_MEMBER Syncronize(); IIF( .F., s_oClass:ModInline( "Syncronize", {|Self | Self, ( ::oDbf:Goto( ::nRecIni ), Self ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Syncronize", {|Self | Self, ( ::oDbf:Goto( ::nRecIni ), Self ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

    _HB_MEMBER FieldGet(nFld); IIF( .F., s_oClass:ModInline( "FieldGet", {|Self,nFld | Self, ( if( ::RecNo == 0, ::aBlank[ nFld ], ::aRecords[ ::RecNo, nFld ] ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "FieldGet", {|Self,nFld | Self, ( if( ::RecNo == 0, ::aBlank[ nFld ], ::aRecords[ ::RecNo, nFld ] ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
    _HB_MEMBER FieldPut(nFld, Val); IIF( .F., s_oClass:ModInline( "FieldPut", {|Self,nFld, Val | Self, ::aRecords[ ::RecNo, nFld ] := Val }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "FieldPut", {|Self,nFld, Val | Self, ::aRecords[ ::RecNo, nFld ] := Val }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
    _HB_MEMBER FieldPos( cName); IIF( .F., s_oClass:ModMethod( "FieldPos", @TDbArray_FieldPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FieldPos", @TDbArray_FieldPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

    _HB_MEMBER FieldName(nFld); IIF( .F., s_oClass:ModInline( "FieldName", {|Self,nFld | Self, ::aFields[ nFld, 1 ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "FieldName", {|Self,nFld | Self, ::aFields[ nFld, 1 ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
    _HB_MEMBER FieldType(nFld); IIF( .F., s_oClass:ModInline( "FieldType", {|Self,nFld | Self, ::aFields[ nFld, 2 ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "FieldType", {|Self,nFld | Self, ::aFields[ nFld, 2 ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
    _HB_MEMBER FieldLen(nFld); IIF( .F., s_oClass:ModInline( "FieldLen", {|Self,nFld | Self, ::aFields[ nFld, 3  ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "FieldLen", {|Self,nFld | Self, ::aFields[ nFld, 3  ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
    _HB_MEMBER FieldDec(nFld); IIF( .F., s_oClass:ModInline( "FieldDec", {|Self,nFld | Self, ::aFields[ nFld, 4  ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "FieldDec", {|Self,nFld | Self, ::aFields[ nFld, 4  ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

    _HB_MEMBER DbCore( cFileName); IIF( .F., s_oClass:ModMethod( "DbCore", @TDbArray_DbCore(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DbCore", @TDbArray_DbCore(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

    _HB_MEMBER Clone( lNew ); IIF( !.F., s_oClass:AddVirtual( "Clone" ), )

    _HB_MEMBER Destroy(); IIF( .F., s_oClass:ModMethod( "Destroy", @TDbArray_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Destroy", @TDbArray_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));





    _HB_MEMBER OrdKeyNo(); IIF( .F., s_oClass:ModInline( "OrdKeyNo", {|Self | Self, ( ::RecNo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "OrdKeyNo", {|Self | Self, ( ::RecNo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
    _HB_MEMBER LoadArray( aArray); IIF( .F., s_oClass:ModMethod( "LoadArray", @TDbArray_LoadArray(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LoadArray", @TDbArray_LoadArray(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER Seek( xVal, nField); IIF( .F., s_oClass:ModMethod( "Seek", @TDbArray_Seek(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Seek", @TDbArray_Seek(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER GetStatus(); IIF( .F., s_oClass:ModMethod( "GetStatus", @TDbArray_GetStatus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetStatus", @TDbArray_GetStatus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER SetStatus(); IIF( .F., s_oClass:ModMethod( "SetStatus", @TDbArray_SetStatus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetStatus", @TDbArray_SetStatus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TDbArray ;



UTILITY STATIC function TDbArray_New( oDbf, aRecords, lDatas, cComment) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local i     := 0
    local nLen  := 0
    local nRec  := 0

    lDatas := If( lDatas == nil, .F., lDatas );



    ::oDbf     := oDbf
    ::cAlias   := "ARRAY"
    ::aRecords := if( ValType( aRecords ) == "A", oClone( aRecords ), {} )
    ::Eof      := .F.
    ::Bof      := .F.
    ::RecNo    := 0
    ::nRecIni  := 1
    ::cComment := if( ValType( cComment ) == "C", cComment, "" )
    ::aBlank   := {}
    ::aFields  := {}

    if ::oDbf:Used()


        nRec   := ::oDbf:RecNo()
        nLen   := len( ::oDbf:aTField )

        ::aFields := Array( nLen )

        ::oDbf:GoTo( 0 )
        for i := 1 TO nLen
            aAdd( ::aBlank, ::oDbf:aTField[ i ]:GetVal() )
            if lDatas
                GenData( Self, ::oDbf:aTField[ i ]:cName, i, ::oDbf:aTField[ i ]:cType )
            end
        next

        ::FCount := len( ::aBlank )
        ::oDbf:GoTo( nRec )

    endif

return( Self )



UTILITY STATIC function TDbArray_DefNew( cComment) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    ::cAlias   := "ARRAY"
    ::RecNo    := 0
    ::nRecIni  := 1
    ::LastRec  := 0
    ::FCount   := 0
    ::aFields  := {}
    ::aRecords := {}
    ::aBlank   := {}
    ::Eof      := .F.
    ::Bof      := .F.
    ::Used     := .F.
    ::cComment := if( ValType( cComment ) == "C", cComment, ::cAlias )

return( Self )



UTILITY STATIC function TDbArray_AddField( cName, cType, nLen, nDec) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local aRow := {}

    cName := upper( cName )
    cType := upper( cType )

    AAdd( aRow, cName )
    AAdd( aRow, cType )
    AAdd( aRow, nLen )
    AAdd( aRow, nDec )

    AAdd( ::aFields, aRow )

return( aRow )



UTILITY STATIC function TDbArray_Activate() ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local xVal
    local nFld := 0
    local cType := "C"
    local nCount := ::FCount := len( ::aFields )

    FOR nFld := 1 TO nCount

        cType := ::FieldType( nFld )

        Self:aFields[ nFld, 3  ] := If( Self:aFields[ nFld, 3  ] == nil, 10, Self:aFields[ nFld, 3  ] );
        Self:aFields[ nFld, 4 ] := If( Self:aFields[ nFld, 4 ] == nil, 0, Self:aFields[ nFld, 4 ] );

        DO CASE

           CASE cType == "C"
                xVal := space( ::FieldLen( nFld ) )

           CASE cType  == "N"
                xVal  := replicate( "0", ::FieldLen( nFld ) )
                if ::FieldDec( nFld ) > 0

                  xVal := Stuff( xVal,  ( ::FieldLen( nFld ) - ::FieldDec( nFld ) ), 1, "." )
                endif
                xVal := Val( xVal )

           CASE cType == "L"
                xVal := .F.
                ::aFields[ nFld, 3 ] := 1
                ::aFields[ nFld, 4 ] := 0

           CASE cType == "D"
                xVal  := CToD( "" )
                ::aFields[ nFld, 3 ] := 8
                ::aFields[ nFld, 4 ] := 0

           CASE cType == "M"
                xVal := space( 10 )
                ::aFields[ nFld, 3 ] := 10
                ::aFields[ nFld, 4 ] := 0

        ENDCASE

        AAdd( ::aBlank, xVal )
        GenData( Self, ::FieldName( nFld ), nFld, aType( cType ) )
    NEXT

return( Self )



UTILITY STATIC function TDbArray_GoTo( n) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

   local nRec  := ::RecNo

   if ValType( n ) == "N" .AND. n > 0
      ::Eof := .F.
      ::Bof := .F.
      if n > ::LastRec
         ::RecNo := ::LastRec
         ::Eof := .T.
      else
         ::RecNo := n
      end
   end

return( nRec )



UTILITY STATIC function TDbArray__Delete() ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    ADel( ::aRecords, ::RecNo )
    ASize( ::aRecords, --::LastRec )

    ::GoTo( ::RecNo )

return( Self )



UTILITY STATIC function TDbArray__Zap() ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    ::GoTop()
    while !::Eof()
       ::Delete()
       ::Skip()
    end

return( Self )



UTILITY STATIC function TDbArray_Update( aVal) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local lRet := .F.

    if ValType( aVal ) == "A"
        aSize( aVal )
        AEval( ::aRecords[ ::RecNo ], { | v, i | v := aVal[ i ] } )
        lRet := .T.
    endif

return( lRet )



UTILITY STATIC function TDbArray_Append() ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    AAdd( ::aRecords, aClone( ::aBlank ) )
    ::RecNo := ++::LastRec
    ::Eof   := ::Bof := .F.

return( Self )



UTILITY STATIC function TDbArray_Skip( n) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

   local nPos  := 0

   n := If( n == nil, 1, n );

   ::Eof       := .F.
   ::Bof       := .F.

   nPos        := ::RecNo + n
   if nPos > ::LastRec
      ::GoBottom()
      ::Eof    := .T.
   elseif nPos < 1
      ::GoTop()
      ::Bof    := .T.
   else
      ::RecNo  := nPos
   endif

return( Self )



UTILITY STATIC function TDbArray_Skipper( nSkip) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local nSkipped := 0

    nSkipped   := Min( Max( nSkip, 1 - ::RecNo ), ::LastRec - ::RecNo )

    ::RecNo    += nSkipped

return( nSkipped )



UTILITY STATIC function TDbArray_SetBrowse( oBrw) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    if upper( oBrw:ClassName() ) $ "TBROWSE TDBBRW"
        oBrw:goTopBlock    := { || ::GoTop() }
        oBrw:goBottomBlock := { || ::GoBottom() }
        oBrw:SkipBlock     := { | n | ::Skipper( n ) }
    elseif upper( oBrw:ClassName() ) $ "TWBROWSE TCBROWSE TGRID"
        oBrw:bGoTop    := { || ::GoTop() }
        oBrw:bGoBottom := { || ::GoBottom() }
        oBrw:bSkip     := { | n | ::Skipper( n ) }
        oBrw:bLogicLen := { || ::LastRec }
        oBrw:Refresh()
    endif

return( oBrw )



UTILITY STATIC function TDbArray_Load( bFor, bWhile, bOnPreLoad, bOnPostLoad) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local i          := 0
    local aRec       := {}
    local nLen       := ::FCount
    local lTrigger

    ::nRecIni        := ::oDbf:RecNo()

    bFor             := if( ValType( bFor )   <> "B", { || .T. }, bFor )
    bWhile           := if( ValType( bWhile ) <> "B", { || !::oDbf:Eof() }, bWhile )

    while eval( bWhile, Self )

       if eval( bFor, Self )

          if bOnPreLoad <> nil
             lTrigger := Eval( bOnPreLoad, Self )
             if Valtype( lTrigger ) == "L" .AND. !lTrigger
                return .F.
             end
          end

          aRec := {}
          for i := 1 TO nLen
              aAdd( aRec, ::oDbf:aTField[ i ]:GetVal() )
          next
          aAdd( ::aRecords, aRec )

          ::RecNo    := 1

          if bOnPostLoad <> nil
             lTrigger := Eval( bOnPostLoad, Self )
             if Valtype( lTrigger ) == "L" .AND. !lTrigger
                return .F.
             end
          end

       endif

       ::oDbf:Skip( 1 )

    end

    ::Syncronize()

    ::Eof := ::Bof := ( ( ::LastRec := ::RecCount() ) == 0 )

return( Self )



UTILITY STATIC function TDbArray_FieldPos( cName) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray
return( AScan( ::aFields, { | aRow | aRow[ 1 ] == upper( cName ) } ) )



UTILITY STATIC function TDbArray_RecLoad( nRec, lAdd, bOnPreLoad, bOnPostLoad) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local i    := 0
    local aRec := {}
    local nLen := ::FCount
    local lTrigger

    nRec := If( nRec == nil, ::oDbf:RecNo(), nRec );
    lAdd := If( lAdd == nil, .F., lAdd );

    ::oDbf:Goto( nRec )

    if bOnPreLoad <> nil
       lTrigger := Eval( bOnPreLoad, Self )
       if Valtype( lTrigger ) == "L" .AND. !lTrigger
          return .F.
       end
    end

    for i := 1 TO nLen
       aAdd( aRec, ::oDbf:aTField[ i ]:GetVal() )
    next

    if lAdd
       AAdd( ::aRecords, aRec )
       ::RecNo := ++::LastRec
    else
       ::Update( aRec )
    end

    if bOnPostLoad <> nil
       return Eval( bOnPostLoad, Self )
    end

return ( Self )



UTILITY STATIC function TDbArray_Save( lAppend, bFor) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local i    := 0
    local nRec := ::FCount

    bFor := if( ValType( bFor ) <> "B", { || .T. }, bFor )
    lAppend := if( ValType( lAppend ) <> "L", .T., lAppend )

    if lAppend
        while !::Eof()
            if eval( bFor )
                ( ::nArea )->( DbAppend() )
                FOR i := 1 TO nRec
                    ( ::nArea )->( FieldPut( i, ::FieldGet( i ) ) )
                NEXT
            endif
            ::Skip( 1 )
        end
    else
        ::Syncronize()
        while !::Eof()
            if eval( bFor )
                ( ::nArea )->( DbSkip( 1 ) )
                ( ::nArea )->( if( Eof(), DbAppend(), ) )
                FOR i := 1 TO nRec
                    ( ::nArea )->( FieldPut( i, ::FieldGet( i ) ) )
                NEXT
            endif
            ::Skip( 1 )
        end
    endif

return( Self )



UTILITY STATIC function TDbArray_RecSave( lAppend) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local i    := 0
    local nLen := ::FCount

    lAppend    := if( ValType( lAppend ) <> "L", .T., lAppend )

    if lAppend
        ::oDbf:Append()
    else
        ::oDbf:Load()
    end

    for i := 1 TO nLen
        if !::oDbf:aTField[ i ]:lCalculate
            ::oDbf:FldPut( i, ::FieldGet( i ) )
        end
    next

    ::oDbf:Save()

return( Self )



UTILITY STATIC function TDbArray_DbCore( cFileName) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local lRet := .F.

    if ValType( cFileName ) == "C"
        DbCreate( cFileName, ::aFields )
        DbUseArea( .T.,, cFileName )
        ::nArea := Select()
        ::GoTop()
        ::Save( .T. )
        lRet := .T.
    endif

return( lRet )



UTILITY STATIC function TDbArray_Destroy() ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    ::aRecords := {}
    ::aBlank   := {}
    ::aFields  := {}

    Self       := nil

return( .T. )



UTILITY STATIC function TDbArray_LoadArray( aArray) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

   ::aRecords  := aArray
   ::RecNo     := 1
   ::LastRec   := ::RecCount()

return( Self )



UTILITY STATIC function TDbArray_Seek( xVal, nField) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

   local nScan       := 0
   local nLen        := len( xVal )

   nField := If( nField == nil, 1, nField );

   nScan := AScan( ::aRecords, { | aRow | SubStr( aRow[ nField ], 1, nLen ) == xVal } )
   if nScan <> 0
      ::GoTo( nScan )
   end

return ( nScan <> 0 )



UTILITY STATIC function TDbArray_GetStatus() ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    ::aStatus := {}

    AAdd( ::aStatus, ::Recno )

return( Self )



UTILITY STATIC function TDbArray_SetStatus() ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    ::Goto( ::aStatus[ 1 ] )

return( Self )
