#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 12 ".\Prg\Treeitem.prg"
static aLines



_HB_CLASS TTreeItem ; UTILITY FUNCTION TTreeItem(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TTreeItem" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { cDraw, cPrompt} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cDraw" , "cPrompt" }, .F., .F. ), )
   _HB_MEMBER { oPrev, oNext} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oPrev" , "oNext" }, .F., .F. ), )
   _HB_MEMBER { oTree} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oTree" }, .F., .F. ), )
   _HB_MEMBER { lOpened} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lOpened" }, .F., .F. ), )
   _HB_MEMBER { nLevel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nLevel" }, .F., .F. ), )
   _HB_MEMBER { hBmpOpen, hBmpClose} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "hBmpOpen" , "hBmpClose" }, .F., .F. ), )
   _HB_MEMBER { Cargo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "Cargo" }, .F., .F. ), )

   _HB_MEMBER New( cPrompt, nLevel, hBmpOpen, hBmpClose) AS CLASS TTreeItem; IIF( .F., s_oClass:ModMethod( "New", @TTreeItem_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TTreeItem_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER Open(); IIF( .F., s_oClass:ModInline( "Open", {|Self | Self, If( ! ::lOpened .AND. ::oTree <> nil, ::lOpened := .T.,) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Open", {|Self | Self, If( ! ::lOpened .AND. ::oTree <> nil, ::lOpened := .T.,) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Close(); IIF( .F., s_oClass:ModInline( "Close", {|Self | Self, If( ::lOpened, ::lOpened := .F.,) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Close", {|Self | Self, If( ::lOpened, ::lOpened := .F.,) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Skip( @n); IIF( .F., s_oClass:ModMethod( "Skip", @TTreeItem_Skip(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Skip", @TTreeItem_Skip(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GetNext(); IIF( .F., s_oClass:ModInline( "GetNext", {|Self | Self, If( ::lOpened, ::oTree:oFirst, ::oNext ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetNext", {|Self | Self, If( ::lOpened, ::oTree:oFirst, ::oNext ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER GetPrev(); IIF( .F., s_oClass:ModMethod( "GetPrev", @TTreeItem_GetPrev(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetPrev", @TTreeItem_GetPrev(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER GetText(); IIF( .F., s_oClass:ModInline( "GetText", {|Self | Self, If( ::oTree <> nil .AND. ::lOpened, " - ",  If( ::oTree <> nil, " + ", "   " ) ) + ::cDraw + ::cPrompt }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetText", {|Self | Self, If( ::oTree <> nil .AND. ::lOpened, " - ",  If( ::oTree <> nil, " + ", "   " ) ) + ::cDraw + ::cPrompt }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER GetLabel(); IIF( .F., s_oClass:ModMethod( "GetLabel", @TTreeItem_GetLabel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetLabel", @TTreeItem_GetLabel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Draw( cPrevDraw); IIF( .F., s_oClass:ModMethod( "Draw", @TTreeItem_Draw(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Draw", @TTreeItem_Draw(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER SetNext(oItem); IIF( .F., s_oClass:ModInline( "SetNext", {|Self,oItem | Self, ::oNext := oItem, If( ::oTree <> nil, ::oTree:oLast:SetNext( oItem ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetNext", {|Self,oItem | Self, ::oNext := oItem, If( ::oTree <> nil, ::oTree:oLast:SetNext( oItem ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Toggle(); IIF( .F., s_oClass:ModInline( "Toggle", {|Self | Self, If( ::lOpened, ::Close(), ::Open() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Toggle", {|Self | Self, If( ::lOpened, ::Close(), ::Open() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER ColSizes(); IIF( .F., s_oClass:ModMethod( "ColSizes", @TTreeItem_ColSizes(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ColSizes", @TTreeItem_ColSizes(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Add( cPrompt); IIF( .F., s_oClass:ModMethod( "Add", @TTreeItem_Add(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Add", @TTreeItem_Add(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Delete(); IIF( .F., s_oClass:ModInline( "Delete", {|Self | Self, ::oPrev:oNext := ::oNext }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Delete", {|Self | Self, ::oPrev:oNext := ::oNext }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetText(cPrompt); IIF( .F., s_oClass:ModInline( "SetText", {|Self,cPrompt | Self, ::cPrompt := cPrompt }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetText", {|Self,cPrompt | Self, ::cPrompt := cPrompt }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER End(); IIF( .F., s_oClass:ModMethod( "End", @TTreeItem_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "End", @TTreeItem_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TTreeItem ;



UTILITY STATIC function TTreeItem_New( cPrompt, nLevel, hBmpOpen, hBmpClose) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   IIF( aLines == nil, aLines := aTreeBmps(), ) ;

   ::cDraw     = ""
   ::cPrompt   = cPrompt
   ::lOpened   = .F.
   ::nLevel    = nLevel
   ::hBmpOpen  = hBmpOpen
   ::hBmpClose = hBmpClose

return Self



UTILITY STATIC function TTreeItem_Skip( n) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local nCount := 0
   local oItem  := Self

   if n > 0
      while nCount < n .AND. oItem:GetNext() <> nil
          oItem = oItem:GetNext()
          nCount++
      end
      n = nCount
   endif

   if n < 0
      while nCount < -n .AND. oItem:GetPrev() <> nil
         oItem = oItem:GetPrev()
         nCount++
      end
      n = -nCount
   endif

return oItem



UTILITY STATIC function TTreeItem_GetPrev() ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   if ::oPrev <> nil
      if ::oPrev:nLevel < ::nLevel
         return ::oPrev
      else
         if ::oPrev:lOpened
            return ::oPrev:oTree:GetLast()
         else
            return ::oPrev
         endif
      endif
   endif

return nil



UTILITY STATIC function TTreeItem_Draw( cPrevDraw) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   IIF( cPrevDraw == nil, cPrevDraw := "", ) ;








   ::cDraw = cPrevDraw +  If( ::oPrev <> nil, If( ::oNext <> nil .AND. ::oNext:nLevel == ::nLevel, If( ::oTree <> nil, If( ::lOpened, Chr( 5 ), Chr( 4 ) ), Chr( 2 ) ), If( ::oTree <> nil, If( ::lOpened, Chr( 7 ), Chr( 6 ) ), Chr( 3 ) ) ), Chr( 2 ) )

   If ::oTree <> nil



      ::oTree:Draw( cPrevDraw + If( ::oNext <> nil, If( ::oNext:nLevel < ::nLevel,  if( ::lOpened, Chr( 1 ), Chr( 0 )), Chr( 1 ) ), Chr( 0 ) ) )
   endif

return nil



UTILITY STATIC function TTreeItem_GetLabel() ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local aLabel := Array( ::nLevel + 1 )
   local n, nLine

   AFill( aLabel, 0 )
   AAdd( aLabel, ::cPrompt )

   for n = 1 to Len( ::cDraw )
       nLine = Asc( SubStr( ::cDraw, n, 1 ) )
       if nLine <> 0
          aLabel[ n ] = aLines[ nLine ]
       endif
   next

   if ::oTree <> nil
      if ::oNext <> nil
         if ::oNext:nLevel < ::nLevel
            aLabel[ ::nLevel ] = If( ::lOpened, aLines[ 7 ], aLines[ 6 ] )
         else
            aLabel[ ::nLevel ] = If( ::lOpened, aLines[ 5 ], aLines[ 4 ] )
         endif
      else
         aLabel[ ::nLevel ] = If( ::lOpened, aLines[ 7 ], aLines[ 6 ] )
      endif
   endif



   aLabel[ ::nLevel + 1 ] = If( ::lOpened, If( ::hBmpClose <> nil, ::hBmpClose, 0 ), If( ::hBmpOpen <> nil, ::hBmpOpen, 0 ) )

return aLabel



UTILITY STATIC function TTreeItem_ColSizes() ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local aCols := Array( ::nLevel + 1 )

   AFill( aCols, 16 )
   AAdd( aCols, 400 )

return aCols



UTILITY STATIC function TTreeItem_Add( cPrompt) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local oItem := TTreeItem():New( cPrompt, ::nLevel )
   local oPrev

   oItem:oPrev   = Self
   oItem:oNext   = ::oNext
   if ::oTree <> nil
      ::oTree:oLast:oNext = oItem
   endif
   ::oNext = oItem

   while ( oPrev := ::GetPrev() ):nLevel >= ::nLevel

   end

   oPrev:oTree:oLast = oItem

return oItem



UTILITY STATIC function TTreeItem_End() ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   if ! Empty( ::hBmpOpen )
      DeleteObject( ::hBmpOpen )
      ::hBmpOpen = 0
   endif

   if ! Empty( ::hBmpClose )
      DeleteObject( ::hBmpClose )
      ::hBmpClose = 0
   endif

return nil



function GetTreeBmps()

return aLines
