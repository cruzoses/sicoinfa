#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 19 ".\Prg\OutLook2010.prg"
_HB_CLASS TOutLook2010 ; UTILITY FUNCTION TOutLook2010(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TOutLook2010" , {TControl():classh} ) ) ; ;

   _HB_MEMBER { oHeader} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oHeader" }, .F., .F. ), )
   _HB_MEMBER { aGroups, aDialogs} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aGroups" , "aDialogs" }, .F., .F. ), )
   _HB_MEMBER { oFontHeader} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oFontHeader" }, .F., .F. ), )
   _HB_MEMBER { oFontGroup} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oFontGroup" }, .F., .F. ), )
   _HB_MEMBER { nOver} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nOver" }, .F., .F. ), )
   _HB_MEMBER { bChange} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bChange" }, .F., .F. ), )
   _HB_MEMBER { nOption} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nOption" }, .F., .F. ), )
   _HB_MEMBER { hBmpDots} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "hBmpDots" }, .F., .F. ), )
   _HB_MEMBER { oPopup} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oPopup" }, .F., .F. ), )

   _HB_MEMBER {AS LOGICAL lRegistered} ; IIF( !.F., s_oClass:AddMultiClsData("LOGICAL",, nScope + IIF( .F., 32, 0 ) + 64, { "lRegistered" }, .F. ), )

   _HB_MEMBER New( oWnd, aPrompts, aBmpNames, bChange); IIF( .F., s_oClass:ModMethod( "New", @TOutLook2010_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TOutLook2010_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Redefine( nId, oWnd, aPrompts, aBmpNames, bChange, aDialogs); IIF( .F., s_oClass:ModMethod( "Redefine", @TOutLook2010_Redefine(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Redefine", @TOutLook2010_Redefine(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Paint(); IIF( .F., s_oClass:ModMethod( "Paint", @TOutLook2010_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Paint", @TOutLook2010_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Display(); IIF( .F., s_oClass:ModInline( "Display", {|Self | Self, ::BeginPaint(), ::Paint(), ::EndPaint(), 0 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Display", {|Self | Self, ::BeginPaint(), ::Paint(), ::EndPaint(), 0 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER EraseBkGnd(hDC); IIF( .F., s_oClass:ModInline( "EraseBkGnd", {|Self,hDC | Self, 1 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "EraseBkGnd", {|Self,hDC | Self, 1 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER AddGroup( cPrompt, cBitmap); IIF( .F., s_oClass:ModMethod( "AddGroup", @TOutLook2010_AddGroup(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AddGroup", @TOutLook2010_AddGroup(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER AtGroup( nRow, nCol); IIF( .F., s_oClass:ModMethod( "AtGroup", @TOutLook2010_AtGroup(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AtGroup", @TOutLook2010_AtGroup(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER BuildPopup(); IIF( .F., s_oClass:ModMethod( "BuildPopup", @TOutLook2010_BuildPopup(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "BuildPopup", @TOutLook2010_BuildPopup(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Default(); IIF( .F., s_oClass:ModMethod( "Default", @TOutLook2010_Default(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Default", @TOutLook2010_Default(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Initiate( hDlg); IIF( .F., s_oClass:ModMethod( "Initiate", @TOutLook2010_Initiate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Initiate", @TOutLook2010_Initiate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER MouseMove( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "MouseMove", @TOutLook2010_MouseMove(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MouseMove", @TOutLook2010_MouseMove(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER LButtonDown( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "LButtonDown", @TOutLook2010_LButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LButtonDown", @TOutLook2010_LButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Destroy(); IIF( .F., s_oClass:ModMethod( "Destroy", @TOutLook2010_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Destroy", @TOutLook2010_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER HandleEvent( nMsg, nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "HandleEvent", @TOutLook2010_HandleEvent(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HandleEvent", @TOutLook2010_HandleEvent(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER MouseLeave( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "MouseLeave", @TOutLook2010_MouseLeave(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MouseLeave", @TOutLook2010_MouseLeave(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetOption( nOption); IIF( .F., s_oClass:ModMethod( "SetOption", @TOutLook2010_SetOption(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetOption", @TOutLook2010_SetOption(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER AdjustDialogs( nWidth, nHeight); IIF( .F., s_oClass:ModMethod( "AdjustDialogs", @TOutLook2010_AdjustDialogs(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AdjustDialogs", @TOutLook2010_AdjustDialogs(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetPopup(oPopup); IIF( .F., s_oClass:ModInline( "SetPopup", {|Self,oPopup | Self, ::oPopup:End(), ::oPopup := oPopup }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetPopup", {|Self,oPopup | Self, ::oPopup:End(), ::oPopup := oPopup }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TOutLook2010 ;



UTILITY STATIC function TOutLook2010_New( oWnd, aPrompts, aBmpNames, bChange) ; local Self AS CLASS TOutLook2010 := QSelf() AS CLASS TOutLook2010

   local n, oDlg

   IIF( oWnd == nil, oWnd := GetWndDefault(), ) ;

   ::nTop    = 0
   ::nLeft   = 0
   ::nBottom = oWnd:nBottom
   ::nRight  = 190
   ::oWnd    = oWnd
   ::nStyle  = nOr( 1073741824, 268435456, 8388608 )
   ::lDrag   = .F.
   ::nClrPane = nRGB( 220, 223, 228 )
   ::aGroups = {}
   ::bChange = bChange
   ::aDialogs = {}
   ::bResized = { | nType, nWidth, nHeight | ::AdjustDialogs( nWidth, nHeight ) }
   ::nOption  = 1
   ::hBmpDots = BmpOLDots()
   ::oPopup   = ::BuildPopup()

   ::Register()

   if ! Empty( ::oWnd:hWnd )
      ::Create()
      ::oWnd:AddControl( Self )
   else
      ::oWnd:DefControl( Self )
   endif

   ::oWnd:oLeft = Self

   ::oFontHeader := TFont():New( "Verdana", 0, -16,, .T.,,,,,,,,,,,, )
   ::oFontGroup := TFont():New( "Verdana", 0, -12,, .T.,,,,,,,,,,,, )

   ::oHeader = TOutLook2010Group():New( "", Self )

   if ! Empty( aPrompts )
      for n = 1 to Len( aPrompts )
         if ! Empty( aBmpNames ) .AND. n <= Len( aBmpNames )
            ::AddGroup( aPrompts[ n ], aBmpNames[ n ] )
         else
            ::AddGroup( aPrompts[ n ] )
         endif
      next
   endif

   for n = 1 to Len( ::aGroups )


      oDlg = TDialog():New( 33, 0, ::nHeight - ( Len( ::aGroups ) * 32 ), ::nWidth() - 1,,,, .F., 1073741824,,,, Self, .T.,, Self:oFont,,,, .F., )
      AAdd( ::aDialogs, oDlg )
   next

   if ! Empty( oWnd:hWnd )
      ::Default()
   endif

return Self



UTILITY STATIC function TOutLook2010_Redefine( nId, oWnd, aPrompts, aBmpNames, bChange, aDialogs) ; local Self AS CLASS TOutLook2010 := QSelf() AS CLASS TOutLook2010

   local n, oDlg, oFont

   IIF( aDialogs == nil, aDialogs := Array( Len( aPrompts ) ), ) ; IIF( oWnd == nil, oWnd := GetWndDefault(), ); IIF( aBmpNames == nil, aBmpNames := {}, );

   ::nId      = nId
   ::oWnd     = oWnd
   ::aGroups  = {}
   ::aDialogs = {}
   ::bChange  = bChange
   ::nClrPane = nRGB( 0, 45, 150 )
   ::hBmpDots = BmpOLDots()
   ::oPopup   = ::BuildPopup()

   ::Register()

   ::oFontHeader := TFont():New( "Verdana", 0, -16,, .T.,,,,,,,,,,,, )
   ::oFontGroup := TFont():New( "Verdana", 0, -12,, .T.,,,,,,,,,,,, )

   ::oHeader = TOutLook2010Group():New( "", Self )

   if ! Empty( aPrompts )
      for n = 1 to Len( aPrompts )
         if ! Empty( aBmpNames ) .AND. n <= Len( aBmpNames )
            ::AddGroup( aPrompts[ n ], aBmpNames[ n ] )
         else
            ::AddGroup( aPrompts[ n ] )
         endif
      next
   endif

   oFont = TFont():New( GetSysFont(), 0, -9 )

   for n = 1 to Len( aPrompts )
      oDlg = TDialog():New(,,,,, aDialogs[ n ],, .F.,,,,, Self, .F.,, oFont,,,, .F., )
      AAdd( ::aDialogs, oDlg )
   next

   oWnd:DefControl( Self )

return Self



UTILITY STATIC function TOutLook2010_Default() ; local Self AS CLASS TOutLook2010 := QSelf() AS CLASS TOutLook2010

   local oDlg, n

   ::SetColor( ::nClrText, ::nClrPane )

   for n = 1 to Len( ::aDialogs )
      oDlg = ::aDialogs[ n ]



      oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .F., {|Self|.F.}, ! .T., {|Self|oDlg:Move( 33, 0 )}, oDlg:bRClicked,,, )

      if IsAppThemed()
         if Empty( oDlg:oBrush:hBitmap )

         endif
      endif

      oDlg:Hide()
   next

   if Len( ::aDialogs ) > 0
      ::aDialogs[ 1 ]:Show()
   endif

return nil



UTILITY STATIC function TOutLook2010_Initiate( hDlg) ; local Self AS CLASS TOutLook2010 := QSelf() AS CLASS TOutLook2010

   ::TControl:Initiate( hDlg )

   ::Default()
   ::AdjustDialogs()

return nil



UTILITY STATIC function TOutLook2010_AddGroup( cPrompt, cBitmap) ; local Self AS CLASS TOutLook2010 := QSelf() AS CLASS TOutLook2010

  AAdd( ::aGroups, TOutLook2010Group():New( cPrompt, Self, cBitmap ) )

  if Empty( ::oHeader:cPrompt )
     ::oHeader:cPrompt = cPrompt
  endif

return nil



UTILITY STATIC function TOutLook2010_BuildPopup() ; local Self AS CLASS TOutLook2010 := QSelf() AS CLASS TOutLook2010

   local oPopup

   oPopup := MenuBegin( .T.,,, .T., .F. )
      MenuAddItem( "Show &More Buttons",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Show &Fewer Buttons",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Na&vigation Pane Options...",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem()
      MenuAddItem( "&Add or Remove Buttons",, .F.,,,,,,,,, .F.,,, .F. )
   MenuEnd()

return oPopup



UTILITY STATIC function TOutLook2010_Paint() ; local Self AS CLASS TOutLook2010 := QSelf() AS CLASS TOutLook2010

   local n, nTop
   local aInfo := ::DispBegin()

   FillRect( ::hDC, GetClientRect( ::hWnd ), ::oBrush:hBrush )

   ::oHeader:Paint()


   nTop = ::nHeight - ( Len( ::aGroups ) * 32 ) - 7
   Gradient( ::hDC, { nTop, 0, nTop + 7, ::nWidth() }, nRGB(   3,  56, 147 ), nRGB(  89, 135, 214 ), .T. )
   DrawTransparent( ::hDC, ::hBmpDots, nTop + 2, ( ::nWidth() / 2 ) - ( nBmpWidth( ::hBmpDots ) / 2 ) )

   if Len( ::aGroups ) > 0
      for n = 1 to Len( ::aGroups )
         ::aGroups[ n ]:Paint()
      next
   endif

   ::DispEnd( aInfo )

return nil



UTILITY STATIC function TOutLook2010_AtGroup( nRow, nCol) ; local Self AS CLASS TOutLook2010 := QSelf() AS CLASS TOutLook2010

   local nGroupsArea := ::nHeight - ( Len( ::aGroups ) * 32 )

   if nRow > nGroupsArea
      return Len( ::aGroups ) - Int( ( ::nHeight - nRow ) / 32 )
   endif

return nil



UTILITY STATIC function TOutLook2010_MouseMove( nRow, nCol, nFlags) ; local Self AS CLASS TOutLook2010 := QSelf() AS CLASS TOutLook2010

   local nGroup := ::AtGroup( nRow, nCol )

   if nGroup == nil
      CursorArrow()
      if ::nOver <> nil
         ::aGroups[ ::nOver ]:Paint()
         ::nOver = nil
      endif
   endif

   if nGroup <> nil .AND. nGroup <> ::nOver
      if ::nOver <> nil
         ::aGroups[ ::nOver ]:Paint()
      endif
      ::aGroups[ nGroup ]:Paint( .T. )
      ::nOver = nGroup
      CursorHand()
   endif

   TrackMouseEvent( ::hWnd, 2 )

return nil



UTILITY STATIC function TOutLook2010_LButtonDown( nRow, nCol, nFlags) ; local Self AS CLASS TOutLook2010 := QSelf() AS CLASS TOutLook2010

   local nGroup := ::AtGroup( nRow, nCol )

   if nGroup <> nil
      ::SetOption( nGroup )
      if nCol > ::nWidth - 30 .AND. nCol < ::nWidth
         if nGroup == Len( ::aGroups )
            ::oPopup:Activate( ::nHeight, ::nWidth + 1, Self, .F., 32 )
         endif
      endif
   endif

return nil



UTILITY STATIC function TOutLook2010_Destroy() ; local Self AS CLASS TOutLook2010 := QSelf() AS CLASS TOutLook2010

   local n

   ::oFontHeader:End()
   ::oFontGroup:End()

   for n = 1 to Len( ::aDialogs )
      ::aDialogs[ n ]:bValid = nil
      ::aDialogs[ n ]:End()
   next

   DeleteObject( ::hBmpDots )

   for n = 1 to Len( ::aGroups )
      ::aGroups[ n ]:Destroy()
   next
   ::oHeader:Destroy()
   ::oPopup:End()

return ::TControl:Destroy()



UTILITY STATIC function TOutLook2010_HandleEvent( nMsg, nWParam, nLParam) ; local Self AS CLASS TOutLook2010 := QSelf() AS CLASS TOutLook2010

   if nMsg == 675
      return ::MouseLeave( nHiWord( nLParam ), nLoWord( nLParam ), nWParam )
   endif

return ::TControl:HandleEvent( nMsg, nWParam, nLParam )



UTILITY STATIC function TOutLook2010_MouseLeave( nRow, nCol, nFlags) ; local Self AS CLASS TOutLook2010 := QSelf() AS CLASS TOutLook2010

   if ::nOver <> nil
      ::aGroups[ ::nOver ]:Paint()
      ::nOver = nil
   endif

return nil



UTILITY STATIC function TOutLook2010_SetOption( nOption) ; local Self AS CLASS TOutLook2010 := QSelf() AS CLASS TOutLook2010

   local nOldOption := AScan( ::aGroups, { | o | o:lSelected } )

   if nOption > 0 .AND. nOption <> nOldOption
      ::aGroups[ nOldOption ]:lSelected = .F.
      ::aGroups[ nOldOption ]:nClrStart = nRGB( 203, 225, 252 )
      ::aGroups[ nOldOption ]:nClrEnd   = nRGB( 125, 165, 224 )
      ::aGroups[ nOldOption ]:Paint()
      ::aGroups[ nOption ]:lSelected = .T.
      ::aGroups[ nOption ]:nClrStart = nRGB( 250, 227, 143 )
      ::aGroups[ nOption ]:nClrEnd   = nRGB( 238, 152, 25 )
      ::aGroups[ nOption ]:Paint( .T. )
      ::oHeader:cPrompt = ::aGroups[ nOption ]:cPrompt
      ::oHeader:Paint()

      if nOldOption <= Len( ::aDialogs ) .AND. ::aDialogs[ nOldOption ] <> nil
         ::aDialogs[ nOldOption ]:Hide()
      endif

      if nOption <= Len( ::aDialogs ) .AND. ::aDialogs[ nOption ] <> nil
         ::nOption = nOption
         if ::bChange <> nil
            Eval( ::bChange, nOption, nOldOption )
         endif
         ::aDialogs[ nOption ]:AEvalWhen()
         ::aDialogs[ nOption ]:Show()
         ::aDialogs[ nOption ]:SetFocus()
      endif
   endif

return nil



UTILITY STATIC function TOutLook2010_AdjustDialogs( nWidth, nHeight) ; local Self AS CLASS TOutLook2010 := QSelf() AS CLASS TOutLook2010

   local n


   IIF( nWidth == nil, nWidth := ::nWidth, ) ; IIF( nHeight == nil, nHeight := ::nHeight, );
   nHeight := Max( 0, nHeight - 6 - ( ( Len( ::aGroups ) + 1 ) * 32 ) )

   for n = 1 to Len( ::aDialogs )
      ::aDialogs[ n ]:SetSize( nWidth, nHeight )
   next

return nil



_HB_CLASS TOutLook2010Group ; UTILITY FUNCTION TOutLook2010Group(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TOutLook2010Group" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { cPrompt} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPrompt" }, .F., .F. ), )
   _HB_MEMBER { hBmp, hBmpArrow} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "hBmp" , "hBmpArrow" }, .F., .F. ), )
   _HB_MEMBER { lSelected, lHeader} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lSelected" , "lHeader" }, .F., .F. ), )
   _HB_MEMBER { nClrStart, nClrEnd, nClrText} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrStart" , "nClrEnd" , "nClrText" }, .F., .F. ), )
   _HB_MEMBER { oContainer} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oContainer" }, .F., .F. ), )

   _HB_MEMBER New( cPrompt, oContainer, cBitmap); IIF( .F., s_oClass:ModMethod( "New", @TOutLook2010Group_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TOutLook2010Group_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Paint( lOver); IIF( .F., s_oClass:ModMethod( "Paint", @TOutLook2010Group_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Paint", @TOutLook2010Group_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Destroy(); IIF( .F., s_oClass:ModMethod( "Destroy", @TOutLook2010Group_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Destroy", @TOutLook2010Group_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TOutLook2010Group ;



UTILITY STATIC function TOutLook2010Group_New( cPrompt, oContainer, cBitmap) ; local Self AS CLASS TOutLook2010Group := QSelf() AS CLASS TOutLook2010Group

   ::cPrompt    = cPrompt
   ::oContainer = oContainer
   ::lHeader    = ( ::oContainer:oHeader == nil )
   ::lSelected  = ! ::lHeader .AND. Len( ::oContainer:aGroups ) == 0
   ::nClrStart  = If( ::lHeader, nRGB(  89, 135, 214 ), If( ::lSelected, nRGB( 250, 227, 143 ), nRGB( 203, 225, 252 ) ) )
   ::nClrEnd    = If( ::lHeader, nRGB(   3,  56, 147 ), If( ::lSelected, nRGB( 238, 152, 25 ), nRGB( 125, 165, 224 ) ) )
   ::nClrText   = If( ::lHeader, 16777215, 0 )
   ::hBmpArrow  = BmpOLArrow()

   if File( cBitmap )
      ::hBmp = ReadBitmap( 0, cBitmap )
   else
      ::hBmp = LoadBitmap( GetResources(), cBitmap )
   endif

return Self



UTILITY STATIC function TOutLook2010Group_Paint( lOver) ; local Self AS CLASS TOutLook2010Group := QSelf() AS CLASS TOutLook2010Group

   local nTop, hDC, oBmp, oCon := ::oContainer
   local hGrayPen, hOldPen

   IIF( lOver == nil, lOver := .F., ) ;

   if ::lHeader
      nTop = 0
   else

      nTop = oCon:nHeight -  ( ( Len( oCon:aGroups ) + 1 - AScan( oCon:aGroups, { | o | o == Self } ) ) * 32 )
   endif

   if ::lSelected


      GradientFill( hDC := oCon:GetDC(), nTop + 2, 2, nTop + 28, oCon:nWidth() - 2, { { 0.5, ( 222 + ( 227 * 256 ) + ( 233 * 65536 ) ), ( 209 + ( 213 * 256 ) + ( 222 * 65536 ) ) }, { 0.5, ( 209 + ( 213 * 256 ) + ( 222 * 65536 ) ), ( 222 + ( 227 * 256 ) + ( 233 * 65536 ) ) } } )
   else
      FillRect( hDC := oCon:GetDC(), { nTop, 0, nTop + 32, oCon:nWidth() }, oCon:oBrush:hBrush )
   endif

   if ! Empty( ::hBmp )
      DrawTransparent( hDC, ::hBmp, nTop + 5, 8 )
   endif


   oCon:Say( nTop + 8 - If( ::lHeader, 2, 0 ), 40 - If( ::lHeader, 30, 0 ), ::cPrompt, If( ::lSelected, ::nClrText, ( 57 + ( 75 * 256 ) + ( 97 * 65536 ) ) ),, If( ::lHeader, oCon:oFontHeader, oCon:oFontGroup ), .T., ::lSelected )
   if Self == ATail( oCon:aGroups )
      DrawTransparent( hDC, ::hBmpArrow, nTop + 10, oCon:nWidth() - nBmpWidth( ::hBmpArrow ) * 2 )
   endif

   if ::lSelected
      hGrayPen = CreatePen( 0, 1, nRGB( 165, 168, 173 ) )
      WndBoxClr( hDC, nTop + 1, 3, nTop + 30, oCon:nWidth - 6, hGrayPen )
      DeleteObject( hGrayPen )
   endif

   oCon:ReleaseDC()

return nil



UTILITY STATIC function TOutLook2010Group_Destroy() ; local Self AS CLASS TOutLook2010Group := QSelf() AS CLASS TOutLook2010Group

   if ! Empty( ::hBmp )
      DeleteObject( ::hBmp )
   endif

   if ! Empty( ::hBmpArrow )
      DeleteObject( ::hBmpArrow )
   endif

return nil
