#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 30 ".\Prg\Folder.prg"
_HB_CLASS TFolder ; UTILITY FUNCTION TFolder(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TFolder" , {TControl():classh} ) ) ; ;

   _HB_MEMBER {AS LOGICAL lRegistered} ; IIF( !.F., s_oClass:AddMultiClsData("LOGICAL",, nScope + IIF( .F., 32, 0 ) + 64, { "lRegistered" }, .F. ), )

   _HB_MEMBER { aPrompts, aDialogs} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aPrompts" , "aDialogs" }, .F., .F. ), )
   _HB_MEMBER { nOption, nTabSize, nFdHeight} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nOption" , "nTabSize" , "nFdHeight" }, .F., .F. ), )
   _HB_MEMBER { oFont2} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oFont2" }, .F., .F. ), )
   _HB_MEMBER { aEnable} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aEnable" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lAllWidth} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .T., nScope + IIF( .F., 32, 0 ), { "lAllWidth" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lWin95Look} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL",, nScope + IIF( .F., 32, 0 ), { "lWin95Look" }, .F., .F. ), )




   _HB_MEMBER { aProperties} ; IIF( !.F., s_oClass:AddMultiClsData(, { "aPrompts", "cVarName", "nClrText", "nClrPane", "nAlign", "nTop", "nLeft", "nWidth", "nHeight", "nOption", "Cargo" }, nScope + IIF( .F., 32, 0 ) + 64, { "aProperties" }, .F. ), )



   _HB_MEMBER New( nTop, nLeft, aPrompts, aDialogs, oWnd, nOption, nClrFore, nClrBack, lPixel, lDesign, nWidth, nHeight, cMsg, lAllWidth, oFont) AS CLASS TFolder; IIF( .F., s_oClass:ModMethod( "New", @TFolder_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TFolder_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER ReDefine( nId, aPrompts, aDialogs, oWnd, nOption, nClrFore, nClrBack, bChange, lAllWidth) AS CLASS TFolder; IIF( .F., s_oClass:ModMethod( "ReDefine", @TFolder_ReDefine(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReDefine", @TFolder_ReDefine(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));





      _HB_MEMBER Display( ); IIF( !.F., s_oClass:AddVirtual( "Display" ), )
      _HB_MEMBER Paint( ); IIF( !.F., s_oClass:AddVirtual( "Paint" ), )
      _HB_MEMBER CtlColor( hWndChild, hDCChild); IIF( .F., s_oClass:ModMethod( "CtlColor", @TFolder_CtlColor(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CtlColor", @TFolder_CtlColor(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER Initiate( hDlg); IIF( .F., s_oClass:ModMethod( "Initiate", @TFolder_Initiate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Initiate", @TFolder_Initiate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER LButtonDown( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "LButtonDown", @TFolder_LButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LButtonDown", @TFolder_LButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Default(); IIF( .F., s_oClass:ModMethod( "Default", @TFolder_Default(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Default", @TFolder_Default(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ReSize( nType, nWidth, nHeight); IIF( .F., s_oClass:ModMethod( "ReSize", @TFolder_ReSize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReSize", @TFolder_ReSize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AddItem( cItem); IIF( .F., s_oClass:ModMethod( "AddItem", @TFolder_AddItem(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AddItem", @TFolder_AddItem(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


      _HB_MEMBER cToChar(); IIF( .F., s_oClass:ModInline( "cToChar", {|Self | Self, ::TControl:cToChar( "SysTabControl32" ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "cToChar", {|Self | Self, ::TControl:cToChar( "SysTabControl32" ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER DelItem(); IIF( .F., s_oClass:ModMethod( "DelItem", @TFolder_DelItem(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DelItem", @TFolder_DelItem(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DelPages(); IIF( .F., s_oClass:ModMethod( "DelPages", @TFolder_DelPages(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DelPages", @TFolder_DelPages(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Destroy(); IIF( .F., s_oClass:ModMethod( "Destroy", @TFolder_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Destroy", @TFolder_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GotFocus( hWndLoseFocus); IIF( .F., s_oClass:ModMethod( "GotFocus", @TFolder_GotFocus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GotFocus", @TFolder_GotFocus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER LoadPages( aResNames, bRedefineControls); IIF( .F., s_oClass:ModMethod( "LoadPages", @TFolder_LoadPages(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LoadPages", @TFolder_LoadPages(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



      _HB_MEMBER MouseMove(nRow, nCol, nFlags); IIF( .F., s_oClass:ModInline( "MouseMove", {|Self,nRow, nCol, nFlags | Self, ( ::TControl:MouseMove( nRow, nCol, nFlags ), nil ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "MouseMove", {|Self,nRow, nCol, nFlags | Self, ( ::TControl:MouseMove( nRow, nCol, nFlags ), nil ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER Notify( nIdCtrl, nPtrNMHDR); IIF( .F., s_oClass:ModMethod( "Notify", @TFolder_Notify(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Notify", @TFolder_Notify(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetOption( nOption); IIF( .F., s_oClass:ModMethod( "SetOption", @TFolder_SetOption(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetOption", @TFolder_SetOption(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetPrompts( aPrompts); IIF( .F., s_oClass:ModMethod( "SetPrompts", @TFolder_SetPrompts(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetPrompts", @TFolder_SetPrompts(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GetHotPos( nChar); IIF( .F., s_oClass:ModMethod( "GetHotPos", @TFolder_GetHotPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetHotPos", @TFolder_GetHotPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));










      _HB_MEMBER Update(); IIF( .F., s_oClass:ModInline( "Update", {|Self | Self, ASend( ::aDialogs, "Update()" ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Update", {|Self | Self, ASend( ::aDialogs, "Update()" ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER KeyDown( nKey, nFlags); IIF( .F., s_oClass:ModMethod( "KeyDown", @TFolder_KeyDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "KeyDown", @TFolder_KeyDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


      _HB_MEMBER AdjustRect(); IIF( .F., s_oClass:ModMethod( "AdjustRect", @TFolder_AdjustRect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AdjustRect", @TFolder_AdjustRect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER HScroll( nWParam, nLParam ); IIF( !.F., s_oClass:AddVirtual( "HScroll" ), )

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TFolder ;





UTILITY STATIC function TFolder_New( nTop, nLeft, aPrompts, aDialogs, oWnd, nOption, nClrFore, nClrBack, lPixel, lDesign, nWidth, nHeight, cMsg, lAllWidth, oFont) ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder





   local n, oDlg











   IIF( nTop == nil, nTop := 0, ) ; IIF( nLeft == nil, nLeft := 0, ); IIF( aDialogs == nil, aDialogs := {}, ); IIF( aPrompts == nil, aPrompts := { "&One", "&Two", "T&hree" }, ); IIF( oWnd == nil, oWnd := GetWndDefault(), ); IIF( nOption == nil, nOption := 1, ); IIF( nClrFore == nil, nClrFore := oWnd:nClrText, ); IIF( nClrBack == nil, nClrBack := GetSysColor( 15 ), ); IIF( lPixel == nil, lPixel := .F., ); IIF( lDesign == nil, lDesign := .F., ); IIF( nWidth == nil, nWidth := 100, ); IIF( nHeight == nil, nHeight := 100, ); IIF( lAllWidth == nil, lAllWidth := .T., );

   if Len( aDialogs ) < Len( aPrompts )
      aDialogs = Array( Len( aPrompts ) )
   endif

   if ::aEnable == nil
      ::aEnable = Array( Len( aPrompts ) )
      AFill( ::aEnable, .T. )
   endif



   ::nStyle    = nOR( 1073741824, 268435456, If( lDesign, 67108864, 0 ), 65536 )
   ::nId       = ::GetNewId()
   ::oWnd      = oWnd
   ::aPrompts  = aPrompts
   ::aDialogs  = aDialogs
   ::nOption   = nOption
   ::cMsg      = cMsg
   ::nTop      = If( lPixel, nTop, nTop * 15 )
   ::nLeft     = If( lPixel, nLeft, nLeft * 6 )
   ::nBottom   = ::nTop + nHeight - 1
   ::nRight    = ::nLeft + nWidth - 1
   ::lDrag     = lDesign
   ::lCaptured = .F.

   ::oFont2    = TFont():New( GetSysFont(), 0, -9,, .T. )
   ::lAllWidth = lAllWidth
   ::nFdHeight = If( LargeFonts(), 25 , 22 )
   ::cVarName  = ""

   ::lWin95Look = GetVersion()[ 1 ] > 3 .OR. GetVersion()[ 2 ] > 51 .OR.  IsWinNT()

   ::SetColor( nClrFore, nClrBack )

   ::Register()

   if ! Empty( oWnd:hWnd )



         ::Create( "SysTabControl32" )
         ::SetPrompts()

      if oFont <> nil
         ::SetFont( oFont )
      elseif oWnd <> nil .AND. oWnd:oFont <> nil
         ::SetFont( oWnd:oFont )
      else
         ::GetFont()
      endif
      oWnd:AddControl( Self )
   else
      oWnd:DefControl( Self )
   endif

   for n = 1 to Len( ::aDialogs )


      oDlg = TDialog():New( 0, 0, ::nHeight() - ::nFdHeight - 5, ::nWidth() - 6,,,, .F., 1073741824,,,, Self, .T.,, Self:oFont,,,, .F., )
      ::aDialogs[ n ] = oDlg
      oDlg:cVarName = "Page" + AllTrim( Str( n ) )
   next

   if ! Empty( oWnd:hWnd )
      ::Default()
   endif

   if lDesign
      ::CheckDots()
   endif

   SetWndDefault( oWnd )

return Self




UTILITY STATIC function TFolder_ReDefine( nId, aPrompts, aDialogs, oWnd, nOption,  nClrFore, nClrBack, bChange, lAllWidth) ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   local n, oDlg





   IIF( nOption == nil, nOption := 1, ) ; IIF( nClrFore == nil, nClrFore := oWnd:nClrText, ); IIF( nClrBack == nil, nClrBack := oWnd:nClrPane, ); IIF( aDialogs == nil, aDialogs := Array( Len( aPrompts ) ), ); IIF( lAllWidth == nil, lAllWidth := .F., );

   if ::aEnable == nil
      ::aEnable = Array( Len( aPrompts ) )
      AFill( ::aEnable, .T. )
   endif

   ::nId      = nId
   ::oWnd     = oWnd
   ::aPrompts = aPrompts
   ::aDialogs = aDialogs
   ::nOption  = nOption

   if oWnd <> nil .AND. oWnd:oFont <> nil
      ::SetFont( oWnd:oFont )
   else
      ::GetFont()
   endif

   ::oFont2     = TFont():New( GetSysFont(), 0, -9,, .T. )
   ::bChange    = bChange
   ::nClrPane   = GetSysColor( 15 )
   ::lAllWidth  = lAllWidth
   ::nFdHeight  = If( LargeFonts(), 25 , 22 )

   ::lWin95Look = GetVersion()[ 1 ] > 3 .OR. GetVersion()[ 2 ] > 51 .OR.  IsWinNT()

   ::Register()

   ::SetColor( nClrFore, nClrBack )

   for n = 1 to Len( ::aDialogs )

      oDlg = TDialog():New(,,,,, ::aDialogs[ n ],, .F.,, nClrFore, nClrBack,, Self, .F.,, Self:oFont,,,, .F., )
      ::aDialogs[ n ] = oDlg
   next

   oWnd:DefControl( Self )

return Self



















UTILITY STATIC function TFolder_CtlColor( hWndChild, hDCChild) ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   if GetClassName( hWndChild ) $ "Button,Static" .AND. IsAppThemed()
      return DrawThemed( hWndChild, hDCChild )
   endif

return ::TControl:CtlColor( hWndChild, hDCChild )




















UTILITY STATIC function TFolder_Initiate( hDlg) ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   local n

   ::TControl:Initiate( hDlg )

   ::Default()

   for n = 1 to Len( ::aDialogs )





         ::aDialogs[ n ]:SetSize( ::nWidth() - 5, ::nHeight() - ::nFdHeight - 4 )

   next


      ::SetPrompts( ::aPrompts )


return nil



UTILITY STATIC function TFolder_LButtonDown( nRow, nCol, nFlags) ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   local n := 1

   if ::lDrag
      return ::TControl:LButtonDown( nRow, nCol, nFlags )
   else












         n = TabCtrl_HitTest( ::hWnd ) + 1

      ::SetOption( n )
   endif

return nil



UTILITY STATIC function TFolder_Default() ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   local nLen := Len( ::aPrompts ), n
   local oDlg
   local nHeight := ::nFdHeight

   if nLen > 0
      if ::lAllWidth
         ::nTabSize = int( ::nWidth() / nLen )
      else
         ::nTabSize := 0
         for n = 1 to nLen


            ::nTabSize = Max( ::nTabSize,  int( GetTextWidth( 0, ::aPrompts[n],  ::oFont:hFont ) + 40 ) )
         next
         ::nTabSize = Min( ::nTabSize, int( ::nWidth() / nLen ) )
      endif
   else
      ::nTabSize = ::nWidth()
   endif

   for nLen = 1 to Len( ::aDialogs )
      oDlg = ::aDialogs[ nLen ]








         oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .F., {|Self|.F.}, ! .T., {|Self|oDlg:Move( nHeight, 1 )}, oDlg:bRClicked,,, )



         if IsAppThemed()

            oDlg:bEraseBkGnd = { | hDC | DrawPBack( oDlg:hWnd, hDC ), 1 }
         endif


      oDlg:Hide()
   next

   if Len( ::aDialogs ) > 0
      if ::nOption <= Len( ::aDialogs )
         ::aDialogs[ ::nOption ]:Show()
      endif
   endif

return nil



function SysWait( nLong )

   local nSeconds

   IIF( nLong == nil, nLong := .1, ) ;
   nSeconds := Seconds() + nLong

   while Seconds() < nSeconds
     SysRefresh()
   end

return nil



UTILITY STATIC function TFolder_ReSize( nType, nWidth, nHeight) ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   local nLen := Len( ::aPrompts ), n

   if nLen > 0
      if ::lAllWidth
         ::nTabSize = int( nWidth / nLen )
      else
         ::nTabSize := 0
         for n = 1 to nLen


            ::nTabSize = Max( ::nTabSize,  int( GetTextWidth( 0, ::aPrompts[n],  ::oFont:hFont ) + 40 ) )
         next
         ::nTabSize = Min( ::nTabSize, int( nWidth / nLen ) )
      endif
   else
      ::nTabSize = nWidth + 1
   endif

   for n = 1 to Len( ::aDialogs )
      ::aDialogs[ n ]:SetSize( nWidth - 6, nHeight - ::nFdHeight - 5 )
   next

return ::TControl:Resize( nType, nWidth, nHeight )



UTILITY STATIC function TFolder_SetPrompts( aPrompts) ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   local n

   if ! Empty( aPrompts )
      ::aPrompts = aPrompts
   endif


      TabDelAllItems( ::hWnd )

      for n = Len( ::aPrompts ) to 1 step -1
         TabCtrlAdd( ::hWnd, ::aPrompts[ n ], ::aEnable[ n ] )
      next

      SendMessage( ::hWnd, ( 4864 + 12 ), ::nOption - 1 )
      ::TControl:Refresh()


return nil



UTILITY STATIC function TFolder_AddItem( cItem) ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   local oDlg
   local oThis := Self


   oDlg = TDialog():New( 0, 0, oThis:nHeight - oThis:nFdHeight - 5, oThis:nWidth - 6,,,, .F., 1073741824,,,, Self, .T.,,,,,, .F., )

   AAdd( ::aDialogs, oDlg )
   AAdd( ::aPrompts, cItem )
   AAdd( ::aEnable, .T. )



   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .F., {|Self|.F.}, ! .T., {|Self|( oDlg:Move( oThis:nFdHeight + 2, 3 ) )}, oDlg:bRClicked,,, )

   oDlg:Hide()
   oDlg:SetSize( ::nWidth - 6, ::nHeight - ::nFdHeight - 5 )



















      ::SetPrompts( ::aPrompts )
      ::SetOption( Len( ::aDialogs ) )


return nil



UTILITY STATIC function TFolder_DelPages() ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   while Len( ::aPrompts ) > 0
      ::DelItem()
   end

return nil



UTILITY STATIC function TFolder_DelItem( nOption) ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   local nLen, n

   IIF( nOption == nil, nOption := ::nOption, ) ;

   if Len( ::aPrompts ) > 0
      ::aPrompts = ADel( ::aPrompts, nOption )
      ::aPrompts = ASize( ::aPrompts, Len( ::aPrompts ) - 1 )
      ::aDialogs[ nOption ]:bValid = { || .T. }
      ::aDialogs[ nOption ]:End()
      ::aDialogs = ADel( ::aDialogs, nOption )
      ::aDialogs = ASize( ::aDialogs, Len( ::aDialogs ) - 1 )
   endif

   ::nOption         := Min( nOption, Len( ::aPrompts ) )

   if ( nLen := Len( ::aPrompts ) ) > 0
      if ::lAllWidth
         ::nTabSize = int( ::nWidth / nLen )
      else
         ::nTabSize  := 0
         for n = 1 to nLen
            ::nTabSize  := Max( ::nTabSize, int( GetTextWidth( 0, ::aPrompts[n], ::oFont:hFont ) + 40 ) )
         next
         ::nTabSize  := Min( ::nTabSize, int( ::nWidth / nLen ) )
      endif
   else
      ::nTabSize     := ::nWidth + 1
   endif

   ::Refresh()
   ::SetPrompts( ::aPrompts )

return nil



UTILITY STATIC function TFolder_Destroy() ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   local n

   ::oFont2:End()

   if ::oFont <> nil
      ::oFont:End()
   endif

   for n = 1 to Len( ::aDialogs )
      ::aDialogs[ n ]:bValid = { || .T. }
      ::aDialogs[ n ]:End()
   next

return ::TControl:Destroy()



UTILITY STATIC function TFolder_GotFocus( hWndLoseFocus) ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   ::TControl:GotFocus()

   if ::nOption > 0 .AND. ::nOption <= Len( ::aDialogs )
      ::aDialogs[ ::nOption ]:AEvalWhen()
      ::aDialogs[ ::nOption ]:SetFocus()
   endif

return 0



UTILITY STATIC function TFolder_LoadPages( aResNames, bRedefineControls) ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   local n, oDlg
   local oThis := Self

   ::DelPages()

   ::aPrompts = aResNames
   ::aDialogs = Array( Len( aResNames ) )

   for n = 1 to Len( ::aDialogs )

      oDlg = TDialog():New(,,,,, aResNames[ n ],, .F.,,,,, Self, .F.,, Self:oFont,,,, .F., )

      ::aDialogs[ n ] = oDlg

      if bRedefineControls <> nil
         Eval( bRedefineControls, Self, n )
      endif



      oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .F., {|Self|.F.}, ! .T., {|Self|( oDlg:Move( oThis:nFdHeight + 2, 3 ) )}, oDlg:bRClicked,,, )

      oDlg:Hide()
   next

   ::nOption = 1
   ::aDialogs[ 1 ]:Show()

return nil



UTILITY STATIC function TFolder_SetOption( nOption) ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   local nOldOption


   if nOption > 0 .AND. nOption <> ::nOption .AND. ::aEnable[ nOption ]
      if ::nOption <= Len( ::aDialogs ) .AND. ::aDialogs[ ::nOption ] <> nil
         ::aDialogs[ ::nOption ]:Hide()
      endif
      nOldOption = ::nOption
      ::nOption  = nOption





      if nOption <= Len( ::aDialogs ) .AND. ::aDialogs[ nOption ] <> nil
         if ::bChange <> nil
            Eval( ::bChange, nOption, nOldOption )
         endif
         ::aDialogs[ nOption ]:AEvalWhen()
         ::aDialogs[ nOption ]:Show()
         ::aDialogs[ nOption ]:SetFocus()
      endif
   endif


   if nOption > 0

         PostMessage( ::hWnd, ( 4864 + 12 ), ::nOption - 1 )

      if ! ::aEnable[ nOption ]
         MsgBeep()
      endif
   endif

return nil



UTILITY STATIC function TFolder_GetHotPos( nChar) ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   local n := 1
   local nAt

   while n <= Len( ::aPrompts )



     if n <> ::nOption .AND. ::aEnable[n] .AND.  ( nAt := At( "&", ::aPrompts[ n ] ) ) <> 0 .AND.  Lower( SubStr( ::aPrompts[ n ], nAt + 1, 1 ) ) ==  Lower( Chr( nChar ) )
        return n
     endif
     n++
   end

return 0



UTILITY STATIC function TFolder_Notify( nIdCtrl, nPtrNMHDR) ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   local nCode := GetNMHDRCode( nPtrNMHDR )

   static nOldOption

   do case
      case nCode == ( -550 - 2 )

              nOldOption = TabCtrl_GetCurSel( ::hWnd ) + 1


      case nCode == ( -550 - 1 )

              if ! ::aEnable[ TabCtrl_GetCurSel( ::hWnd ) + 1 ]
                 TabCtrl_SetCurSel( ::hWnd, nOldOption - 1 )
              endif

   endcase

return nil



UTILITY STATIC function TFolder_KeyDown( nKey, nFlags) ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   do case
      case nKey == 34
           TONE(155,3)
           return 0

      case nKey == 33
           TONE(955,3)
           return 0
   endcase

return ::TControl:KeyDown( nKey, nFlags )






UTILITY STATIC function TFolder_AdjustRect() ; local Self AS CLASS TFolder := QSelf() AS CLASS TFolder

   local aRect:= TabCtrl_AdjustRect( ::hWnd )

   if Len( ::aDialogs ) > 0 .AND. ::aDialogs[ 1 ]:nTop <> aRect[ 1 ]
      AEval( ::aDialogs, { | oDlg | oDlg:Move( aRect[ 1 ], aRect[ 2 ] ) } )
   endif

return nil
