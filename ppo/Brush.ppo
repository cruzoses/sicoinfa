#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 13 ".\Prg\Brush.prg"
_HB_CLASS TBrush ; UTILITY FUNCTION TBrush(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TBrush" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { hBrush, hBitmap, hBmpOrgl} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "hBrush" , "hBitmap" , "hBmpOrgl" }, .F., .F. ), )
   _HB_MEMBER { nBmpFormat} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nBmpFormat" }, .F., .F. ), )
   _HB_MEMBER { nCount, cStyle, nRGBColor, cBmpFile, cBmpRes} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nCount" , "cStyle" , "nRGBColor" , "cBmpFile" , "cBmpRes" }, .F., .F. ), )
   _HB_MEMBER { lSystem} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lSystem" }, .F., .F. ), )
   _HB_MEMBER { aGrad} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aGrad" }, .F., .F. ), )
   _HB_MEMBER { uSource} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "uSource" }, .F., .F. ), )
   _HB_MEMBER { nResizeMode} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nResizeMode" }, .F., .F. ), )
   _HB_MEMBER { oRect} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oRect" }, .F., .F. ), )
   _HB_MEMBER { Cargo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "Cargo" }, .F., .F. ), )

   _HB_MEMBER { aBrushes} ; IIF( !.F., s_oClass:AddMultiClsData(, {}, nScope + IIF( .F., 32, 0 ) + 64, { "aBrushes" }, .F. ), )

   _HB_MEMBER { aProperties} ; IIF( !.F., s_oClass:AddMultiClsData(, { "cStyle", "cBmpFile", "cBmpRes", "nRGBColor", "lSystem" }, nScope + IIF( .F., 32, 0 ) + 64, { "aProperties" }, .F. ), )

   _HB_MEMBER New( cStyle, nRGBColor, cBmpFile, cBmpRes, nBmpHandle); IIF( .F., s_oClass:ModMethod( "New", @TBrush_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TBrush_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   _HB_MEMBER cGenPRG(); IIF( .F., s_oClass:ModMethod( "cGenPRG", @TBrush_cGenPRG(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "cGenPRG", @TBrush_cGenPRG(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER End(); IIF( .F., s_oClass:ModMethod( "End", @TBrush_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "End", @TBrush_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Load( cInfo); IIF( .F., s_oClass:ModMethod( "Load", @TBrush_Load(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Load", @TBrush_Load(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Release(); IIF( .F., s_oClass:ModInline( "Release", {|Self | Self, ::End() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Release", {|Self | Self, ::End() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Save(); IIF( .F., s_oClass:ModMethod( "Save", @TBrush_Save(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Save", @TBrush_Save(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Resized( x, y, nMode); IIF( .F., s_oClass:ModMethod( "Resized", @TBrush_Resized(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Resized", @TBrush_Resized(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Cropped( oWnd, oRect); IIF( .F., s_oClass:ModMethod( "Cropped", @TBrush_Cropped(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Cropped", @TBrush_Cropped(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SaveToText( nIndent); IIF( .F., s_oClass:ModMethod( "SaveToText", @TBrush_SaveToText(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SaveToText", @TBrush_SaveToText(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Resize( oWnd, nOrgX, nOrgY); IIF( .F., s_oClass:ModMethod( "Resize", @TBrush_Resize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Resize", @TBrush_Resize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Copy(); IIF( .F., s_oClass:ModMethod( "Copy", @TBrush_Copy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Copy", @TBrush_Copy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SameAs( oBrush); IIF( .F., s_oClass:ModMethod( "SameAs", @TBrush_SameAs(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SameAs", @TBrush_SameAs(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   IIF( .F., s_oClass:ModInline( "==", {|Self, o | Self, ::SameAs( o ) }, nScope ), s_oClass:AddInline( "==", {|Self, o | Self, ::SameAs( o ) }, nScope ) )

   IIF( .F., s_oClass:ModInline( "!=", {|Self, o | Self, ! ::SameAs( o ) }, nScope ), s_oClass:AddInline( "!=", {|Self, o | Self, ! ::SameAs( o ) }, nScope ) )

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TBrush ;



UTILITY STATIC function TBrush_New( cStyle, nRGBColor, cBmpFile, cBmpRes, nBmpHandle, cResizeMode) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local nAt, nFormat := 0
   local aNewTypes := { "BORLAND", "BRICKS", "TILED", "TABS" }

   local aStdTypes := { "HORIZONTAL", "VERTICAL", "FDIAGONAL", "BDIAGONAL", "CROSS", "DIAGCROSS" }

   ::hBrush    = 0
   ::hBitmap   = 0
   ::cStyle    = cStyle
   ::nRGBColor = nRGBColor
   ::cBmpFile  = cBmpFile
   ::cBmpRes   = cBmpRes
   ::lSystem   = .F.

   if ValType( nBmpHandle ) == "N"
      if IsGDIObject( nBmpHandle )
         ::cBmpFile  = LTrim( Str( nBmpHandle ) )
      else
         nBmpHandle  = nil
      endif
   elseif ValType( nBmpHandle ) == "A"
      ::aGrad        = nBmpHandle
      ::nResizeMode  = 1
   else
      nBmpHandle     = nil
   endif

   if ! Empty( cStyle ) .AND. ! Empty( IfNil( cBmpFile, cBmpRes, nBmpHandle ) ) .AND. Empty( cResizeMode )
      cResizeMode    := cStyle
      cStyle         := nil
   endif



   ::uSource   = If( nRGBColor == nil,  IfNil( cStyle, cBmpFile, cBmpRes, nBmpHandle ),  cClrToCode( nRGBColor ) )


   if ! Empty( cResizeMode ) .AND. ::nRGBColor == nil .AND. ::uSource <> nil
      if ValType( ::uSource ) == "A"
         ::nResizeMode  := If( Left( cResizeMode, 3 ) == "HOR", 2, 1 )
      else
         ::nResizeMode  := FW_DeCode( cResizeMode, "STRETCH", 1, "RESIZE", 2, 0 )
      endif
   endif


   if ::nResizeMode == 0 .AND.  ( nAt := AScan( ::aBrushes, {|oBrush| Self == oBrush } ) ) > 0


      if ! Empty( ::aBrushes[ nAt ]:hBitmap ) .AND. ( Empty( ::aBrushes[ nAt ]:cBmpFile ) .AND.  Empty( ::aBrushes[ nAt ]:cBmpRes ) )
         ::aBrushes[ nAt ]:End()

      else

         Self := ::aBrushes[ nAt ]
         ::nCount++
         return Self
      endif

   endif

   do case





      case cStyle == nil .AND. nRGBColor <> nil
           if nRGBColor == 16777215
              ::hBrush  = GetStockObject( 0 )
              ::lSystem = .T.

           elseif nRGBColor == 0
              ::hBrush  = GetStockObject( 4 )
              ::lSystem = .T.

            elseif nRGBColor == 12632256
              ::hBrush  = GetStockObject( 1 )
              ::lSystem = .T.

            elseif nRGBColor == 8421504
              ::hBrush  = GetStockObject( 2 )
              ::lSystem = .T.

            elseif nRGBColor == ( 64 + ( 64 * 256 ) + ( 64 * 65536 ) )
              ::hBrush  = GetStockObject( 3 )
              ::lSystem = .T.

           else
              ::hBrush := CreateSolidBrush( nRGBColor )
           endif

      case cStyle <> nil
           do case
              case cStyle == "NULL"
                   ::hBrush = GetStockObject( 5 )
                   ::lSystem = .T.

              case ( nAt := AScan( aNewTypes, cStyle ) ) <> 0
                   ::hBitmap = FWBrushes( nAt )


                   ::hBrush = If( ::hBitmap <> 0, CreatePatternBrush( ::hBitmap ), )

              case ( nAt := AScan( aStdTypes, cStyle ) ) <> 0
                   ::hBrush = CreateHatchBrush( nAt - 1, nRGBColor )

              otherwise
                 if File( cBmpFile )
                    ::hBitMap = ReadBitmap( 0, cBmpFile )

                    ::hBrush = If( ::hBitmap <> 0, CreatePatternBrush( ::hBitmap ), )
                 endif
           endcase

      case ValType( nBmpHandle ) == "N"
           ::hBitmap = nBmpHandle
           ::hBrush  = CreatePatternBrush( ::hBitmap )

      case cBmpFile <> nil
           if File( cBmpFile )
               if Lower( cFileExt( cBmpFile ) ) == "bmp"
                  ::hBitMap = ReadBitmap( 0, cBmpFile )
               else
                  ::hBitmap = FILoadImg( cBmpFile, @nFormat )
                  ::nBmpFormat = nFormat
               endif
               ::hBrush = If( ::hBitmap <> 0, CreatePatternBrush( ::hBitmap ), )
           endif

      case cBmpRes <> nil
           ::hBitmap = LoadBitmap( GetResources(), cBmpRes )
           ::hBrush  = If( ::hBitmap <> 0, CreatePatternBrush( ::hBitmap ),)

   endcase

   ::nCount    := 1
   IIF( ::hBmpOrgl == nil, ::hBmpOrgl := ::hBitmap, ) ;

   AAdd( ::aBrushes, Self )

return Self



UTILITY STATIC function TBrush_cGenPRG( cVar) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local cPrg := ""

   IIF( cVar == nil, cVar := "oBrush", ) ;

   cPrg     := "   DEFINE BRUSH " + cVar

   if ! Empty( ::cStyle )
      cPrg  += " STYLE '" + ::cStyle + "'"
   endif

   if ! Empty( ::nRGBColor )
      cPrg  += " COLOR " + cClrToCode( ::nRGBColor )
   endif

   if ! Empty( ::cBmpFile )
      cPrg  += " FILE '" + ::cBmpFile + "'"
   elseif ! Empty( ::cBmpRes )
      cPrg  += " RESOURCE '" + ::cBmpRes + "'"
   endif

return cPrg



UTILITY STATIC function TBrush_End() ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local nAt


   if ::nCount == nil
      ::nCount := 1
   endif

   if --::nCount < 1
      nAt := AScan( ::aBrushes, { | oBrush | oBrush:hBrush = ::hBrush } )
      if nAt > 0
         ADel( ::aBrushes, nAt )
         ASize( ::aBrushes, Len( ::aBrushes ) - 1 )
      endif
   else
      return nil
   endif

   if ::hBrush <> nil .AND. ::hBrush <> 0
      if ! ::lSystem
         if ! DeleteObject( ::hBrush )

            LogFile( "resources.txt", { "DeleteObject( ::hBrush ) failed from TBrush:End()", ::hBrush } )
         endif
      endif
   endif

   if ! Empty( ::hBmpOrgl ) .AND. ::hBmpOrgl <> ::hBitmap
      DeleteObject( ::hBmpOrgl )
   endif

   if ::hBitmap <> nil .AND. ::hBitmap <> 0
      DeleteObject( ::hBitmap )
   endif

   ::hBrush  = 0
   ::hBitmap = 0

return nil



UTILITY STATIC function TBrush_Load( cInfo) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local nPos := 1, nProps, n, nLen
   local cData, cType, cBuffer

   nProps = Bin2I( SubStr( cInfo, nPos, 2 ) )
   nPos += 2

   for n = 1 to nProps
      nLen  = Bin2I( SubStr( cInfo, nPos, 2 ) )
      nPos += 2
      cData = SubStr( cInfo, nPos, nLen )
      nPos += nLen
      cType = SubStr( cInfo, nPos++, 1 )
      nLen  = Bin2I( SubStr( cInfo, nPos, 2 ) )
      nPos += 2
      cBuffer = SubStr( cInfo, nPos, nLen )
      nPos += nLen

      do case
         case cType == "A"
              OSend( Self, "_" + cData, ARead( cBuffer ) )

         case cType == "O"
              OSend( Self, "_" + cData, ORead( cBuffer ) )

         case cType == "C"
              if SubStr( cData, 1, 2 ) == "On"
                 if ::oWnd == nil
                    OSend( Self, "_" + cData, { | u1, u2, u3, u4 | OSend( Self, cBuffer, u1, u2, u3, u4 ) } )
                 else
                    OSend( Self, "_" + cData, { | u1, u2, u3, u4 | OSend( Self:oWnd, cBuffer, u1, u2, u3, u4 ) } )
                 endif
              else
                 OSend( Self, "_" + cData, cBuffer )
              endif

         case cType == "L"
              OSend( Self, "_" + cData, cBuffer == ".T." )

         case cType == "N"
              OSend( Self, "_" + cData, Val( cBuffer ) )
      endcase
   next

return nil



UTILITY STATIC function TBrush_Resized( x, y, nMode) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local hBmp     := ResizeBitmap( ::hBitmap, x, y, nMode )

return TBrush():New( ,,,, hBmp )



UTILITY STATIC function TBrush_Cropped( oWnd, oChildRect) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local hBmp, hDC
   local oBrush, hCrop, oRect

   oBrush      := oWnd:oBrush
   if oBrush:nResizeMode > 0 .AND. oBrush:aGrad == nil
      oRect       := DataRect( oWnd )
      if oBrush:aGrad == nil
         hBmp     := ResizeBitmap( oBrush:hBmpOrgl, oRect:nWidth, oRect:nHeight, oBrush:nResizeMode )
      else
         hDC      := oWnd:GetDC()

         hBmp     := GradientBmp( hDC, oRect:nWidth, oRect:nHeight,  oBrush:aGrad, oBrush:nResizeMode == 1 )
         oWnd:ReleaseDC()
      endif
      hCrop       := CropBmp( hBmp, oChildRect )
      DeleteObject( hBmp )
   else
      return oBrush:Copy()
   endif

return TBrush():New( nil, nil, nil, nil, hCrop )



UTILITY STATIC function TBrush_Save() ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local n
   local cType, cInfo := "", cMethod
   local oBrush := &( ::ClassName() + "()" )
   local uData, nProps := 0

   oBrush = oBrush:New()

   for n = 1 to Len( ::aProperties )

       if ! ( uData := OSend( Self, ::aProperties[ n ] ) ) ==  OSend( oBrush, ::aProperties[ n ] )

          cInfo += ( I2Bin( Len( ::aProperties[ n ] ) ) +  ::aProperties[ n ] )
          nProps++
          cType = ValType( uData )
          do case
             case cType == "A"
                  cInfo += ASave( uData )

             case cType == "O"
                  cInfo += uData:Save()

             otherwise

                  cInfo += ( cType + I2Bin( Len( uData := cValToChar( uData ) ) ) +  uData )
          endcase
       endif
   next

   oBrush:End()



return "O" + I2Bin( 2 + Len( ::ClassName() ) + 2 + Len( cInfo ) ) +  I2Bin( Len( ::ClassName() ) ) +  ::ClassName() + I2Bin( nProps ) + cInfo



UTILITY STATIC function TBrush_SaveToText( nIndent) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local n, m, cType, cInfo
   local cMethod, uData, nProps := 0
   local oBrush := &( ::ClassName() + "()" )
   local cParams1, cParams2

   IIF( nIndent == nil, nIndent := 0, ) ;





   cInfo := Space( nIndent ) + "OBJECT " + If( nIndent > 0, "::", "" ) +  "oBrush AS " +  If( nIndent > 0, Upper( Left( ::ClassName(), 2 ) ) +  Lower( SubStr( ::ClassName(), 3 ) ), If( ::IsDerivedFrom( "TFORM" ), ::cClassName, ::ClassName() ) ) +  Chr(13)+Chr(10) + Chr(13)+Chr(10)

   oBrush = oBrush:New()

   for n = 1 to Len( ::aProperties )

       if ! ( uData := OSend( Self, ::aProperties[ n ] ) ) ==  OSend( oBrush, ::aProperties[ n ] )
          nProps++
          cType = ValType( uData )
          do case
             case cType == "C"
                  cInfo += Space( nIndent ) + "   ::" + ::aProperties[ n ] + " = "
                  cInfo += '"' + uData + '"' + Chr(13)+Chr(10)

             case cType == "A"

                  cInfo += Space( nIndent + 3 ) + "::" + ::aProperties[ n ] +  " = Array( " + AllTrim( Str( Len( uData ) ) ) + " )" + Chr(13)+Chr(10) + Chr(13)+Chr(10)
                  cInfo += AToText( uData, ::aProperties[ n ], nIndent + 3 )

             case cType == "O"
                  cInfo += Chr(13)+Chr(10) + uData:SaveToText( nIndent + 3 )

             otherwise
                  cInfo += Space( nIndent ) + "   ::" + ::aProperties[ n ] + " = "
                  cInfo += cValToChar( uData ) + Chr(13)+Chr(10)
          endcase
       endif
   next

   cInfo += Chr(13)+Chr(10) + Space( nIndent ) + "ENDOBJECT" + If( nIndent > 0, Chr(13)+Chr(10), "" )

   oBrush:End()

return cInfo



UTILITY STATIC function TBrush_Copy() ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local oBrush

   if Empty( ::nResizeMode )
      oBrush   := Self
   else
      oBrush   := TBrush():New()
      WITH OBJECT oBrush
         :cBmpFile      := ::cBmpFile
         :cBmpRes       := ::cBmpRes

         :hBitmap       :=  :hBmpOrgl      := ResizeBitmap( ::hBmpOrgl )
         :nBmpFormat    := ::nBmpFormat
         :lSystem       := ::lSystem
         :aGrad         := ::aGrad
         :uSource       := ::uSource
         :nResizeMode   := ::nResizeMode
      END

   endif

return oBrush



UTILITY STATIC function TBrush_SameAs( oBrush) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush







   return  ValType( oBrush ) == "O"                           .AND.  oBrush:IsKindOf( "TBRUSH" )                        .AND.  ! Empty( oBrush:uSource )                          .AND.  ValType( oBrush:uSource )  == ValType( ::uSource ) .AND.  oBrush:uSource             == ::uSource            .AND.  oBrush:nResizeMode         == ::nResizeMode



UTILITY STATIC function TBrush_Resize( oWnd, nOrgX, nOrgY) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local hDC, oRect

   IIF( nOrgX == nil, nOrgX := 0, ) ; IIF( nOrgY == nil, nOrgY := 0, );

   oRect    := DataRect( oWnd )
   if ::nResizeMode == 0
      ::oRect  := oRect
      if ! Empty( ::hBmpOrgl )
         if ! Empty( ::hBitmap ) .AND. ::hBitmap <> ::hBmpOrgl
            DeleteObject( ::hBitmap )
            DeleteObject( ::hBrush )
            ::hBitmap := ::hBrush := nil
         endif

         IIF( ::hBitmap == nil, ::hBitmap := ::hBmpOrgl, ) ; IIF( ::hBrush == nil, ::hBrush := CreatePatternBrush( ::hBitmap ), );

      endif
   else
      if ::oRect == nil .OR. !( ::oRect == oRect ) .OR. ::hBrush == nil
         if ::hBrush <> nil
            DeleteObject( ::hBrush )
            ::hBrush      := nil
         endif
         if ::hBitmap <> ::hBmpOrgl
            DeleteObject( ::hBitmap )
         endif
         if Empty( ::aGrad )
            if ! Empty( ::hBmpOrgl )
               ::hBitmap   := ResizeBitmap( ::hBmpOrgl, oRect:nWidth, oRect:nHeight, ::nResizeMode )
            endif
         else
            hDC         := oWnd:GetDC()
            ::hBitmap   := GradientBmp( hDC, oRect:nWidth, oRect:nHeight, ::aGrad, ::nResizeMode == 1 )
            IIF( ::hBmpOrgl == nil, ::hBmpOrgl := ::hBitmap, ) ;
            oWnd:ReleaseDC()
         endif
         ::oRect     := oRect
         IIF( ::hBrush == nil, ::hBrush := CreatePatternBrush( ::hBitmap ), ) ;
      endif
   endif

   nOrgX    += ::oRect:nLeft
   nOrgY    += ::oRect:nTop

return oRect



function ResizeBitmap( hBmp, nWndW, nWndH, nMode )

   local hBmpNew
   local nWidth, nHeight
   local nBmpW       := nBmpWidth(  hBmp )
   local nBmpH       := nBmpHeight( hBmp )

   if Empty( nWndW ) .AND. Empty( nWndH )
      nMode          := 0
   else
      IIF( nMode == nil, nMode := 1, ) ;
      IIF( nWndW == nil, nWndW := nWndH * nBmpW / nBmpH, ) ;
      IIF( nWndH == nil, nWndH := nWndW * nBmpH / nBmpW, ) ;
   endif

   if nMode == 0
      nWidth := nBmpW; nHeight := nBmpH
   elseif nMode == 1
      nWidth := nWndW; nHeight := nWndH

   elseif ( nMode == 3 .AND. ( nWndW / nBmpW ) < ( nWndH / nBmpH ) ) .OR.  ( nMode == 2 .AND. ( nWndW / nBmpW ) > ( nWndH / nBmpH ) )
      nWidth := nWndW; nHeight := nBmpH * ( nWndW / nBmpW )
   else
      nHeight := nWndH; nWidth := nBmpW * ( nWndH / nBmpH )
   endif

   hBmpNew     := ResizeImg( hBmp, nWidth, nHeight )

return hBmpNew



static function GradientBmp( hDC, nWidth, nHeight, aColors, lVert )

   local hDC2, hBmp, hBmpOld
   local lDC := .F.

   IIF( lVert == nil, lVert := .T., ) ; IIF( nWidth == nil, nWidth := 319, ); IIF( nHeight == nil, nHeight := 153, );

   if hDC == nil
      hDC   := GetDC( 0 )
      lDC   :=.T.
   endif
   hDC2     := CreateCompatibleDC( hDC )
   hBmp     := CreateCompatibleBitMap( hDC, nWidth, nHeight )
   hBmpOld  := SelectObject( hDC2, hBmp )
   GradientFill( hDC2, 0, 0, nHeight, nWidth, aColors,lVert )

   SelectObject( hDC2, hBmpOld )
   DeleteDC( hDC2 )
   if lDC
      ReleaseDC( 0, hDC )
   endif

return hBmp



static function CropBmp( hBmp, oRect )
return CropImage( hBmp, oRect:nTop, oRect:nLeft, oRect:nBottom, oRect:nRight )



function GradientBrush( hDC, nTop, nLeft, nWidth, nHeight, aColors, lVert )

   local hDC2, hBmp, hBmpOld , hBrush

   IIF( lVert == nil, lVert := .T., ) ;

   if lVert
      nWidth   := 1
   else
      nHeight  := 1
   endif

   hDC2     := CreateCompatibleDC( hDC )
   hBmp     := CreateCompatibleBitMap( hDC, nWidth, nHeight )
   hBmpOld  := SelectObject( hDC2, hBmp )
   GradientFill( hDC2, 0, 0, nHeight, nWidth, aColors,lVert )

   hBrush = CreatePatternBrush( hBmp )
   SelectObject( hDC2, hBmpOld )
   DeleteObject( hBmp )
   DeleteDC( hDC2 )

return hBrush



static function DataRect( oWnd )

   local oRect

   if __ObjHasMethod( oWnd, "DATARECT" )
      oRect    := oWnd:DataRect()
      if ValType( oRect ) == "A"
         oRect := TRect():New( oRect )
      endif
   else
      oRect    := oWnd:GetCliRect()
















   endif

return oRect



static function ContainerWnd( oWnd, nTop, nLeft )

   local oRet     := oWnd

   IIF( nTop == nil, nTop := 0, ) ; IIF( nLeft == nil, nLeft := 0, );





   while lAnd( oRet:nStyle, 1073741824 ) .AND.  ( oRet:IsKindOf( "TCONTROL" ) .OR.   oRet:IsKindOf( "TDIALOG" )  ) .AND.  oWnd:oBrush == oRet:oBrush    .AND.  oRet:oWnd:lTransparent == .T.

      nTop     += oRet:nTop
      nLeft    += oRet:nLeft
      oRet     := oRet:oWnd
   enddo

return oRet



#pragma BEGINDUMP

#include "windows.h"
#include "hbapi.h"

HB_FUNC( CROPIMAGE ) //hOriginalBmp, nTop, nLeft, nBottom, nRight --> hCroppedBmp
{
   HDC hdc1, hdcSrc, hdcDest;
   HBITMAP hbmpSrc  = ( HBITMAP ) hb_parnl( 1 );
   HBITMAP hbmpDest, hold1, hold2;
   RECT rct;
   BITMAP bm;

   GetObject( ( HGDIOBJ ) hbmpSrc, sizeof( BITMAP ), ( LPSTR ) &bm );

   rct.top    = hb_pcount() > 1 ? hb_parnl( 2 ) : 0;
   rct.left   = hb_pcount() > 2 ? hb_parnl( 3 ) : 0;
   rct.bottom = hb_pcount() > 3 ? hb_parnl( 4 ) : bm.bmHeight;
   rct.right  = hb_pcount() > 4 ? hb_parnl( 5 ) : bm.bmWidth;


   hdc1 = GetDC( GetDesktopWindow() );
   hdcSrc = CreateCompatibleDC( hdc1 );
   hdcDest = CreateCompatibleDC( hdc1 );

   hbmpDest = CreateCompatibleBitmap( hdc1, rct.right - rct.left, rct.bottom - rct.top );

   ReleaseDC( GetDesktopWindow(), hdc1 );

   hold1 = ( HBITMAP ) SelectObject( hdcSrc, hbmpSrc );
   hold2 = ( HBITMAP ) SelectObject( hdcDest, hbmpDest );

   BitBlt( hdcDest, 0, 0, rct.right, rct.bottom, hdcSrc, rct.left, rct.top, SRCCOPY );

   SelectObject( hdcSrc, hold1 );
   SelectObject( hdcDest, hold2 );

   DeleteDC( hdcSrc );
   DeleteDC( hdcDest );

   hb_retnl( ( LONG ) hbmpDest );

}

#pragma ENDDUMP
