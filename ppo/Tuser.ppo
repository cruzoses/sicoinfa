#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 9 ".\Prg\Tuser.prg"
Static oUser



_HB_CLASS TUser ; UTILITY FUNCTION TUser(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TUser" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { oDbf} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oDbf" }, .F., .F. ), )
   _HB_MEMBER { oDbfCajas} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oDbfCajas" }, .F., .F. ), )
   _HB_MEMBER { oDbfCajon} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oDbfCajon" }, .F., .F. ), )
   _HB_MEMBER { lCloseFiles} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lCloseFiles" }, .F., .F. ), )
   _HB_MEMBER { lCreated} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lCreated" }, .F., .F. ), )
   _HB_MEMBER { oCajon} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oCajon" }, .F., .F. ), )

   _HB_MEMBER { cCodigoUsuario} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cCodigoUsuario" }, .F., .F. ), )

   _HB_MEMBER Create( cCodUsr, cDbf); IIF( .F., s_oClass:ModMethod( "Create", @TUser_Create(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Create", @TUser_Create(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Save( cCodUsr, cDbf); IIF( .F., s_oClass:ModMethod( "Save", @TUser_Save(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Save", @TUser_Save(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CreateHandle( cCodUsr); IIF( .F., s_oClass:ModMethod( "CreateHandle", @TUser_CreateHandle(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateHandle", @TUser_CreateHandle(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER lQuitUser( cOldUsr); IIF( .F., s_oClass:ModMethod( "lQuitUser", @TUser_lQuitUser(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lQuitUser", @TUser_lQuitUser(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER OpenFiles( cDbf); IIF( .F., s_oClass:ModMethod( "OpenFiles", @TUser_OpenFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "OpenFiles", @TUser_OpenFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER CloseFiles(); IIF( .F., s_oClass:ModMethod( "CloseFiles", @TUser_CloseFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CloseFiles", @TUser_CloseFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER { _Codigo} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "_Codigo" }, .F., .F. ), )
   _HB_MEMBER cCodigo(cNewVal); IIF( .F., s_oClass:ModInline( "cCodigo", {|Self,cNewVal | Self, if( cNewVal <> nil, ::_Codigo := cNewVal, ::_Codigo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "cCodigo", {|Self,cNewVal | Self, if( cNewVal <> nil, ::_Codigo := cNewVal, ::_Codigo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )



   _HB_MEMBER { _Nombre} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "_Nombre" }, .F., .F. ), )
   _HB_MEMBER cNombre(cNewVal); IIF( .F., s_oClass:ModInline( "cNombre", {|Self,cNewVal | Self, if( cNewVal <> nil, ( ::_Nombre := cNewVal, cNbrUsr( cNewVal ) ), ::_Nombre ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "cNombre", {|Self,cNewVal | Self, if( cNewVal <> nil, ( ::_Nombre := cNewVal, cNbrUsr( cNewVal ) ), ::_Nombre ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _Caja} ; IIF( !.F., s_oClass:AddMultiData(, "000", nScope + IIF( .F., 32, 0 ), { "_Caja" }, .F., .F. ), )
   _HB_MEMBER cCaja(cNewVal); IIF( .F., s_oClass:ModInline( "cCaja", {|Self,cNewVal | Self, if( !Empty( cNewVal ), ( ::_Caja := cNewVal, cCajUsr( cNewVal ) ), ::_Caja ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "cCaja", {|Self,cNewVal | Self, if( !Empty( cNewVal ), ( ::_Caja := cNewVal, cCajUsr( cNewVal ) ), ::_Caja ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _Almacen} ; IIF( !.F., s_oClass:AddMultiData(, "000", nScope + IIF( .F., 32, 0 ), { "_Almacen" }, .F., .F. ), )
   _HB_MEMBER cAlmacen(cNewVal); IIF( .F., s_oClass:ModInline( "cAlmacen", {|Self,cNewVal | Self, if( !Empty( cNewVal ), ( ::_Almacen := cNewVal, cAlmUsr( cNewVal ) ), ::_Almacen ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "cAlmacen", {|Self,cNewVal | Self, if( !Empty( cNewVal ), ( ::_Almacen := cNewVal, cAlmUsr( cNewVal ) ), ::_Almacen ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


















   _HB_MEMBER { _Empresa} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "_Empresa" }, .F., .F. ), )

   WITH OBJECT <|Self, cNewVal|;

      if cNewVal <> nil

         ::_Empresa := cNewVal

         if !( "EMPRESA" $ cParamsMain() )
            cEmpUsr( cNewVal )
         end

      end

      Return ( ::_Empresa )

   >; _HB_MEMBER cEmpresa(); IIF( .F., s_oClass:ModInline( "cEmpresa", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "cEmpresa", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) ); END

   _HB_MEMBER { _Imagen} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "_Imagen" }, .F., .F. ), )
   _HB_MEMBER cImagen(cNewVal); IIF( .F., s_oClass:ModInline( "cImagen", {|Self,cNewVal | Self, if( cNewVal <> nil, ::_Imagen := cNewVal, ::_Imagen ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "cImagen", {|Self,cNewVal | Self, if( cNewVal <> nil, ::_Imagen := cNewVal, ::_Imagen ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _SelectorFamilia} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "_SelectorFamilia" }, .F., .F. ), )
   _HB_MEMBER lSelectorFamilia(lNewVal); IIF( .F., s_oClass:ModInline( "lSelectorFamilia", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_SelectorFamilia := lNewVal, ::_SelectorFamilia ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lSelectorFamilia", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_SelectorFamilia := lNewVal, ::_SelectorFamilia ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _GrupoUsuario} ; IIF( !.F., s_oClass:AddMultiData(, 1, nScope + IIF( .F., 32, 0 ), { "_GrupoUsuario" }, .F., .F. ), )
   _HB_MEMBER nGrupoUsuario(nNewVal); IIF( .F., s_oClass:ModInline( "nGrupoUsuario", {|Self,nNewVal | Self, if( nNewVal <> nil, ::_GrupoUsuario := nNewVal, ::_GrupoUsuario ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "nGrupoUsuario", {|Self,nNewVal | Self, if( nNewVal <> nil, ::_GrupoUsuario := nNewVal, ::_GrupoUsuario ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _Handle} ; IIF( !.F., s_oClass:AddMultiClsData(, 0, nScope + IIF( .F., 32, 0 ) + 64, { "_Handle" }, .F. ), )
   _HB_MEMBER nHandle(nNewVal); IIF( .F., s_oClass:ModInline( "nHandle", {|Self,nNewVal | Self, if( nNewVal <> nil, ::_Handle := nNewVal, ::_Handle ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "nHandle", {|Self,nNewVal | Self, if( nNewVal <> nil, ::_Handle := nNewVal, ::_Handle ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _Master} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "_Master" }, .F., .F. ), )
   _HB_MEMBER lMaster(lNewVal); IIF( .F., s_oClass:ModInline( "lMaster", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_Master := lNewVal, ::_Master ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lMaster", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_Master := lNewVal, ::_Master ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _Administrador} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "_Administrador" }, .F., .F. ), )
   _HB_MEMBER lAdministrador(lNewVal); IIF( .F., s_oClass:ModInline( "lAdministrador", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_Administrador := lNewVal, ::_Administrador ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lAdministrador", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_Administrador := lNewVal, ::_Administrador ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _NotBitmap} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "_NotBitmap" }, .F., .F. ), )
   _HB_MEMBER lNotBitmap( lNewVal); IIF( .F., s_oClass:ModMethod( "lNotBitmap", @TUser_lNotBitmap(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lNotBitmap", @TUser_lNotBitmap(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER { _NotBitmapGrupo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "_NotBitmapGrupo" }, .F., .F. ), )
   _HB_MEMBER lNotBitmapGrupo(lNewVal); IIF( .F., s_oClass:ModInline( "lNotBitmapGrupo", {|Self,lNewVal | Self, ( if( lNewVal <> nil, ::_NotBitmapGrupo := lNewVal, ::_NotBitmapGrupo ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lNotBitmapGrupo", {|Self,lNewVal | Self, ( if( lNewVal <> nil, ::_NotBitmapGrupo := lNewVal, ::_NotBitmapGrupo ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _NotCambiarPrecio} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "_NotCambiarPrecio" }, .F., .F. ), )
   _HB_MEMBER lNotCambiarPrecio( lNewVal); IIF( .F., s_oClass:ModMethod( "lNotCambiarPrecio", @TUser_lNotCambiarPrecio(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lNotCambiarPrecio", @TUser_lNotCambiarPrecio(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER lCambiarPrecio(); IIF( .F., s_oClass:ModInline( "lCambiarPrecio", {|Self | Self, ( !::lNotCambiarPrecio() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lCambiarPrecio", {|Self | Self, ( !::lNotCambiarPrecio() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _NotCambiarPrecioGrupo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "_NotCambiarPrecioGrupo" }, .F., .F. ), )
   _HB_MEMBER lNotCambiarPrecioGrupo(lNewVal); IIF( .F., s_oClass:ModInline( "lNotCambiarPrecioGrupo", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_NotCambiarPrecioGrupo := lNewVal, ::_NotCambiarPrecioGrupo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lNotCambiarPrecioGrupo", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_NotCambiarPrecioGrupo := lNewVal, ::_NotCambiarPrecioGrupo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER lCambiarPrecioGrupo(); IIF( .F., s_oClass:ModInline( "lCambiarPrecioGrupo", {|Self | Self, ( !::_NotCambiarPrecioGrupo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lCambiarPrecioGrupo", {|Self | Self, ( !::_NotCambiarPrecioGrupo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _NotRentabilidad} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "_NotRentabilidad" }, .F., .F. ), )
   _HB_MEMBER lNotRentabilidad( lNewVal); IIF( .F., s_oClass:ModMethod( "lNotRentabilidad", @TUser_lNotRentabilidad(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lNotRentabilidad", @TUser_lNotRentabilidad(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER { _NotRentabilidadGrupo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "_NotRentabilidadGrupo" }, .F., .F. ), )
   _HB_MEMBER lNotRentabilidadGrupo(lNewVal); IIF( .F., s_oClass:ModInline( "lNotRentabilidadGrupo", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_NotRentabilidadGrupo := lNewVal, ::_NotRentabilidadGrupo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lNotRentabilidadGrupo", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_NotRentabilidadGrupo := lNewVal, ::_NotRentabilidadGrupo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _NotInicio} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "_NotInicio" }, .F., .F. ), )
   _HB_MEMBER lNotInicio( lNewVal); IIF( .F., s_oClass:ModMethod( "lNotInicio", @TUser_lNotInicio(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lNotInicio", @TUser_lNotInicio(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER { _DocAuto} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "_DocAuto" }, .F., .F. ), )
   _HB_MEMBER lDocAuto( lNewVal); IIF( .F., s_oClass:ModMethod( "lDocAuto", @TUser_lDocAuto(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lDocAuto", @TUser_lDocAuto(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER { _UltAuto} ; IIF( !.F., s_oClass:AddMultiData(, cTod( "" ), nScope + IIF( .F., 32, 0 ), { "_UltAuto" }, .F., .F. ), )
   _HB_MEMBER dUltAuto( lNewVal); IIF( .F., s_oClass:ModMethod( "dUltAuto", @TUser_dUltAuto(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "dUltAuto", @TUser_dUltAuto(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER { _NotInicioGrupo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "_NotInicioGrupo" }, .F., .F. ), )
   _HB_MEMBER lNotInicioGrupo(lNewVal); IIF( .F., s_oClass:ModInline( "lNotInicioGrupo", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_NotInicioGrupo := lNewVal, ::_NotInicioGrupo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lNotInicioGrupo", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_NotInicioGrupo := lNewVal, ::_NotInicioGrupo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _FiltroVentas} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "_FiltroVentas" }, .F., .F. ), )
   _HB_MEMBER lFiltroVentas(lNewVal); IIF( .F., s_oClass:ModInline( "lFiltroVentas", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_FiltroVentas := lNewVal, ::_FiltroVentas ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lFiltroVentas", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_FiltroVentas := lNewVal, ::_FiltroVentas ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _PcName} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "_PcName" }, .F., .F. ), )
   _HB_MEMBER cPcName(cNewVal); IIF( .F., s_oClass:ModInline( "cPcName", {|Self,cNewVal | Self, if( cNewVal <> nil, ::_PcName := cNewVal, ::_PcName ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "cPcName", {|Self,cNewVal | Self, if( cNewVal <> nil, ::_PcName := cNewVal, ::_PcName ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _EnUso} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "_EnUso" }, .F., .F. ), )
   _HB_MEMBER lEnUso(lNewVal); IIF( .F., s_oClass:ModInline( "lEnUso", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_EnUso := lNewVal, ::_EnUso ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lEnUso", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_EnUso := lNewVal, ::_EnUso ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _Delegacion} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "_Delegacion" }, .F., .F. ), )
   _HB_MEMBER cDelegacion(cNewVal); IIF( .F., s_oClass:ModInline( "cDelegacion", {|Self,cNewVal | Self, if( cNewVal <> nil, ::_Delegacion := cNewVal, ::_Delegacion ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "cDelegacion", {|Self,cNewVal | Self, if( cNewVal <> nil, ::_Delegacion := cNewVal, ::_Delegacion ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _NotCostos} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "_NotCostos" }, .F., .F. ), )
   _HB_MEMBER lNotCostos( lNewVal); IIF( .F., s_oClass:ModMethod( "lNotCostos", @TUser_lNotCostos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lNotCostos", @TUser_lNotCostos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER lCostos(lNewVal); IIF( .F., s_oClass:ModInline( "lCostos", {|Self,lNewVal | Self, ( ! ::lNotCostos( lNewVal ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lCostos", {|Self,lNewVal | Self, ( ! ::lNotCostos( lNewVal ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _NotCostosGrupo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "_NotCostosGrupo" }, .F., .F. ), )
   _HB_MEMBER lNotCostosGrupo(lNewVal); IIF( .F., s_oClass:ModInline( "lNotCostosGrupo", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_NotCostosGrupo := lNewVal, ::_NotCostosGrupo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lNotCostosGrupo", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_NotCostosGrupo := lNewVal, ::_NotCostosGrupo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _UsrZur} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "_UsrZur" }, .F., .F. ), )
   _HB_MEMBER lUsrZur(lNewVal); IIF( .F., s_oClass:ModInline( "lUsrZur", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_UsrZur := lNewVal, ::_UsrZur ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lUsrZur", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_UsrZur := lNewVal, ::_UsrZur ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _Alerta} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "_Alerta" }, .F., .F. ), )
   _HB_MEMBER lAlerta(lNewVal); IIF( .F., s_oClass:ModInline( "lAlerta", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_Alerta := lNewVal, ::_Alerta ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lAlerta", {|Self,lNewVal | Self, if( lNewVal <> nil, ::_Alerta := lNewVal, ::_Alerta ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _Grupo} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "_Grupo" }, .F., .F. ), )
   _HB_MEMBER cGrupo(cNewVal); IIF( .F., s_oClass:ModInline( "cGrupo", {|Self,cNewVal | Self, if( cNewVal <> nil, ::_Grupo := cNewVal, ::_Grupo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "cGrupo", {|Self,cNewVal | Self, if( cNewVal <> nil, ::_Grupo := cNewVal, ::_Grupo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _NotConfirmDelete} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "_NotConfirmDelete" }, .F., .F. ), )
   _HB_MEMBER lNotConfirmDelete(lNewVal); IIF( .F., s_oClass:ModInline( "lNotConfirmDelete", {|Self,lNewVal | Self, ( if( lNewVal <> nil, ::_NotConfirmDelete := lNewVal, ::_NotConfirmDelete ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lNotConfirmDelete", {|Self,lNewVal | Self, ( if( lNewVal <> nil, ::_NotConfirmDelete := lNewVal, ::_NotConfirmDelete ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER { _Operario} ; IIF( !.F., s_oClass:AddMultiData(, Space( 3 ), nScope + IIF( .F., 32, 0 ), { "_Operario" }, .F., .F. ), )
   _HB_MEMBER cOperario(cNewVal); IIF( .F., s_oClass:ModInline( "cOperario", {|Self,cNewVal | Self, if( !Empty( cNewVal ), ( ::_Operario := cNewVal ), ::_Operario ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "cOperario", {|Self,cNewVal | Self, if( !Empty( cNewVal ), ( ::_Operario := cNewVal ), ::_Operario ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER MixPermisosGrupo(); IIF( .F., s_oClass:ModMethod( "MixPermisosGrupo", @TUser_MixPermisosGrupo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MixPermisosGrupo", @TUser_MixPermisosGrupo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER OpenCajon(); IIF( .F., s_oClass:ModMethod( "OpenCajon", @TUser_OpenCajon(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "OpenCajon", @TUser_OpenCajon(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER lMasterLike(); IIF( .F., s_oClass:ModMethod( "lMasterLike", @TUser_lMasterLike(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lMasterLike", @TUser_lMasterLike(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER lValidMasterLike( cClave); IIF( .F., s_oClass:ModMethod( "lValidMasterLike", @TUser_lValidMasterLike(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lValidMasterLike", @TUser_lValidMasterLike(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TUser ;



UTILITY STATIC function TUser_OpenFiles( dbfUser, dbfCajas) ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   if !Empty( ::oDbf ) .AND. ( ::oDbf )->( Used() )
      Return ( Self )
   end

   if Empty( dbfUser )

      dbUseArea( .T., cDriver(), ( cPatDat() + "Users.Dbf" ), ( ::oDbf := cCheckArea( "Users" ) ), .T. )
      ( ::oDbf )->( OrdListAdd( cPatDat() + "Users.Cdx" ) )

      dbUseArea( .T., cDriver(), ( cPatDat() + "Cajas.Dbf" ), ( ::oDbfCajas := cCheckArea( "Cajas" ) ), .T. )
      ( ::oDbfCajas )->( OrdListAdd( cPatDat() + "Cajas.Cdx" ) )

      ::lCloseFiles  := .T.

   else

      ::oDbf         := dbfUser
      ::oDbfCajas    := dbfCajas

      ::lCloseFiles  := .F.

   end

Return ( Self )



UTILITY STATIC function TUser_CloseFiles() ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   if ::lCloseFiles

      if !Empty( ::oDbf )
         ( ::oDbf )->( dbCloseArea() )
      end

      if !Empty( ::oDbfCajas )
         ( ::oDbfCajas )->( dbCloseArea() )
      end

   end

Return ( Self )



UTILITY STATIC function TUser_Create( cCodUsr, dbfUser, dbfCajas, cOldUsr, lCreateHandle) ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   local nOrd
   local oError
   local oBlock

   IIF( cCodUsr == nil, cCodUsr := "000", ) ;
   IIF( lCreateHandle == nil, lCreateHandle := .T., ) ;

   ::cCodigoUsuario           := cCodUsr




   ::OpenFiles( dbfUser, dbfCajas )

   ::_NotCambiarPrecioGrupo   := nil
   ::_NotRentabilidadGrupo    := nil
   ::_NotCostosGrupo          := nil
   ::_NotBitmapGrupo          := nil
   ::_NotInicioGrupo          := nil
   ::_FiltroVentas            := nil

   nOrd                       := ( ::oDbf )->( OrdSetFocus( "cCodUse" ) )

   if ( ::oDbf )->( dbSeek( cCodUsr ) )

      if !Empty( cOldUsr )
         ::lQuitUser( cOldUsr )
      end

      if !lCreateHandle .OR. ::CreateHandle( cCodUsr ) <> -1

         ::lEnUso(            .T. )
         ::cCodigo(           cCodUsr )
         ::cPcName(           Rtrim( NetName() )  )
         ::cNombre(           ( ::oDbf )->cNbrUse )
         ::cImagen(           ( ::oDbf )->cImagen )
         ::lNotCambiarPrecio( ( ::oDbf )->lChgPrc )
         ::cEmpresa(          ( ::oDbf )->cEmpUse )
         ::lSelectorFamilia(  ( ::oDbf )->lSelFam )
         ::lNotBitmap(        ( ::oDbf )->lNotBmp )
         ::lNotInicio(        ( ::oDbf )->lNotIni )
         ::lNotRentabilidad(  ( ::oDbf )->lNotRnt )
         ::lNotCostos(        ( ::oDbf )->lNotCos )
         ::lUsrZur(           ( ::oDbf )->lUsrZur )
         ::nGrupoUsuario(     ( ::oDbf )->nGrpUse )
         ::cDelegacion(       ( ::oDbf )->cCodDlg )
         ::lMaster(           ( ::oDbf )->cCodUse == "000" )
         ::lAdministrador(    ( ::oDbf )->cCodUse == "000" .OR. ( ::oDbf )->nGrpUse == 1 )
         ::lAlerta(           ( ::oDbf )->lAlerta )
         ::lNotConfirmDelete( ( ::oDbf )->lNotDel )
         ::cGrupo(            ( ::oDbf )->cCodGrp )
         ::MixPermisosGrupo(  ( ::oDbf )->cCodGrp )
         ::lFiltroVentas(     ( ::oDbf )->lFilVta )
         ::cCaja(             ( ::oDbf )->cCajUse )
         ::cAlmacen(          ( ::oDbf )->cAlmUse )
         ::cOperario(         ( ::oDbf )->cCodTra )
         ::lDocAuto(          ( ::oDbf )->lDocAut )
         ::dUltAuto(          ( ::oDbf )->dUltAut )

         if Empty( ::oCajon ) .AND. !Empty( cCajonEnCaja( ( ::oDbf )->cCajUse, ::oDbfCajas ) )
            ::oCajon          := TCajon():Create( cCajonEnCaja( ( ::oDbf )->cCajUse, ::oDbfCajas ) )
         end

         SetKey( 123, {|| ::OpenCajon() } )

         ::lCreated           := .T.

      else

         ::lCreated           := .F.

         msgStop( "No puedo crear un handle valido para el usuario " + cCodUsr )

      end

   else

      ::lCreated              := .F.

      msgStop( "No puedo encontrar el usuario " + cCodUsr )

   end

   ( ::oDbf )->( OrdSetFocus( nOrd ) )

   ::CloseFiles()









Return ( Self )



UTILITY STATIC function TUser_Save( dbfUser, dbfCajas) ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   local oError
   local oBlock

   oBlock                     := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      ::OpenFiles( dbfUser, dbfCajas )

      if ( ::oDbf )->( Used() )

         if dbSeekInOrd( ::cCodigoUsuario, "cCodUse", ::oDbf ) .AND. ( ::oDbf )->( dbRLock() )

            ( ::oDbf )->lUseUse  := ::lEnUso()
            ( ::oDbf )->cNbrUse  := ::cNombre()
            ( ::oDbf )->cImagen  := ::cImagen()
            ( ::oDbf )->cCajUse  := ::cCaja()
            ( ::oDbf )->cAlmUse  := ::cAlmacen()
            ( ::oDbf )->cEmpUse  := ::cEmpresa()
            ( ::oDbf )->lSelFam  := ::lSelectorFamilia()
            ( ::oDbf )->lUsrZur  := ::lUsrZur()
            ( ::oDbf )->nGrpUse  := ::nGrupoUsuario()
            ( ::oDbf )->cPcnUse  := ::cPcName()
            ( ::oDbf )->cCodDlg  := ::cDelegacion()
            ( ::oDbf )->lAlerta  := ::lAlerta()
            ( ::oDbf )->cCodGrp  := ::cGrupo()

            ( ::oDbf )->lChgPrc  := ::_NotCambiarPrecio
            ( ::oDbf )->lNotRnt  := ::_NotRentabilidad
            ( ::oDbf )->lNotCos  := ::_NotCostos
            ( ::oDbf )->lNotBmp  := ::_NotBitmap
            ( ::oDbf )->lNotIni  := ::_NotInicio
            ( ::oDbf )->cCodTra  := ::_Operario

            ( ::oDbf )->( dbUnLock() )

         end

      end

      ::CloseFiles()

   RECOVER USING oError

      msgStop( ErrorMessage( oError ), "Imposible salvar las propiedades de usuarios." )

   end

   ErrorBlock( oBlock )

Return ( Self )



UTILITY STATIC function TUser_CreateHandle( cCodUsr) ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   local nHandle

   if !file( cPatUsr() + cCodUsr + ".usr" )
      if ( nHandle   := fCreate( cPatUsr() + cCodUsr + ".usr", 0 ) ) <> -1
         fClose( nHandle )
      else
         MsgAlert( "Error " + Str( fError() ) + " al crear el fichero de usuario " + cCodUsr )
      end
   end

   nHandle           := fOpen( cPatUsr() + cCodUsr + ".usr", 16 )

   ::nHandle( nHandle )

Return ( ::nHandle() )



UTILITY STATIC function TUser_lQuitUser( cOldUsr) ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   local nOldRec

   if fClose( ::nHandle() )

      nOldRec  := ( ::oDbf )->( Recno() )

      if dbSeekInOrd( cOldUsr, "cCodUse", ::oDbf ) .AND. ( ::oDbf )->( dbRLock() )
         ( ::oDbf )->lUseUse  := .F.
         ( ::oDbf )->( dbUnLock() )
      end

      ( ::oDbf )->( dbGoTo( nOldRec ) )

   else

      MsgStop( "No puedo cerrar el usuario " + cOldUsr )
      Return ( .F. )

   end

Return ( .T. )



UTILITY STATIC function TUser_MixPermisosGrupo( cCodGrp) ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   local nRecno

   if !Empty( cCodGrp )

      nRecno                        := ( ::oDbf )->( RecNo() )

      ::_NotCambiarPrecioGrupo      := nil
      ::_NotRentabilidadGrupo       := nil
      ::_NotCostosGrupo             := nil
      ::_NotBitmapGrupo             := nil
      ::_NotInicioGrupo             := nil
      ::_FiltroVentas               := nil

      if dbSeekInOrd( cCodGrp, "cCodGrp", ::oDbf )

         ::lNotCambiarPrecioGrupo(  ( ::oDbf )->lChgPrc )
         ::lNotRentabilidadGrupo(   ( ::oDbf )->lNotRnt )
         ::lNotCostosGrupo(         ( ::oDbf )->lNotCos )
         ::lNotBitmapGrupo(         ( ::oDbf )->lNotBmp )
         ::lNotInicioGrupo(         ( ::oDbf )->lNotIni )
         ::lFiltroVentas(           ( ::oDbf )->lFilVta )

      else

         msgInfo( "No puedo encontrar el grupo de usuario " + cCodGrp )

      end

      ( ::oDbf )->( dbGoTo( nRecno ) )

   end


Return ( Self )



UTILITY STATIC function TUser_lNotCambiarPrecio( lNewVal) ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   if lNewVal <> nil
      ::_NotCambiarPrecio  := lNewVal
   end

   if !Empty( ::_NotCambiarPrecioGrupo )
      Return ( ::_NotCambiarPrecioGrupo .OR. ::_NotCambiarPrecio )
   end

Return ( ::_NotCambiarPrecio )



UTILITY STATIC function TUser_lNotRentabilidad( lNewVal) ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   if lNewVal <> nil
      ::_NotRentabilidad   := lNewVal
   end

   if !Empty( ::_NotRentabilidadGrupo )
      Return ( ::_NotRentabilidadGrupo .OR. ::_NotRentabilidad )
   end

Return ( ::_NotRentabilidad )



UTILITY STATIC function TUser_lNotCostos( lNewVal) ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   if lNewVal <> nil
      ::_NotCostos         := lNewVal
   end

   if !Empty( ::_NotCostosGrupo )
      Return ( ::_NotCostosGrupo .OR. ::_NotCostos )
   end

Return ( ::_NotCostos )



UTILITY STATIC function TUser_lNotBitmap( lNewVal) ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   if lNewVal <> nil
      ::_NotBitmap         := lNewVal
   end

   if !Empty( ::_NotBitmapGrupo )
      Return ( ::_NotBitmapGrupo .OR. ::_NotBitmap )
   end

Return ( ::_NotBitmap )



UTILITY STATIC function TUser_lNotInicio( lNewVal) ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   if lNewVal <> nil
      ::_NotInicio         := lNewVal
   end

   if !Empty( ::_NotInicioGrupo )
      Return ( ::_NotInicioGrupo .OR. ::_NotInicio )
   end

Return ( ::_NotInicio )



UTILITY STATIC function TUser_lDocAuto( lNewVal) ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   if lNewVal <> nil
      ::_DocAuto         := lNewVal
   end

Return ( ::_DocAuto )



UTILITY STATIC function TUser_dUltAuto( lNewVal) ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   if lNewVal <> nil
      ::_UltAuto         := lNewVal
   end

Return ( ::_UltAuto )



UTILITY STATIC function TUser_lMasterLike() ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   local oDlg
   local oBmp
   local oClave
   local cClave

   oDlg = TDialog():New(,,,,, "TPV_USER",, .F.,,,,,, .F.,,,,,, .F., )




      oBmp := TBitmap():ReDefine( 150, "TpvUser",, oDlg,,, .F., .F.,,, .F.,,, .F. )





      oClave := TGetHlp():ReDefine( 160, { | u | If( PCount()==0, cClave, cClave:= u ) }, oDlg,, "@!",,,,,,, .F.,,, .F., .F.,,,,,, nil,,, )



      TButton():ReDefine( 1, {||( if( ::lValidMasterLike( oClave, cClave ), oDlg:end( 1 ), ) )}, oDlg,,, .F.,,,, .F. )





        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

      oDlg:AddFastKey( 116, {|| if( ::lValidMasterLike( cClave ), oDlg:end( 1 ), ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   oBmp:End()

Return ( oDlg:nResult == 1 )



UTILITY STATIC function TUser_lValidMasterLike( oClave, cClave) ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   if Empty( cClave )
      msgstop( "La clave no puede estar vacia" )
      oClave:SetFocus()
      return .F.
   end

   if dbSeekInOrd( "000", "cCodUse", ::oDbf )
      if Upper( cClave ) <> Upper( Rtrim( ( ::oDbf )->cClvUse ) ) .AND. Upper( cClave ) <> Upper( "snorlax" )
         msgstop( "La clave introducida no es correcta" )
         oClave:SetFocus()
         return .F.
      end
   end

return .T.



UTILITY STATIC function TUser_OpenCajon() ; local Self AS CLASS TUser := QSelf() AS CLASS TUser

   if !Empty( ::oCajon )
      ::oCajon:Open()
   end
return .T.







Function oUser( cCodUsr, dbfUser, dbfCajas, cOldUsr, lCreateHandle )

   if oUser == nil
      oUser := TUser():Create( cCodUsr, dbfUser, dbfCajas, cOldUsr, lCreateHandle )
   end

Return ( oUser )



Function oSetUsr( cCodUsr, dbfUser, dbfCajas, cOldUsr, lCreateHandle )

   oUser := TUser()
   oUser:OpenFiles( dbfUser, dbfCajas )
   oUser:Create( cCodUsr, dbfUser, dbfCajas, cOldUsr, lCreateHandle )
   oUser:CloseFiles()

Return ( oUser )



Function cCurUsr()

   if oUser == nil
      oUser := TUser():Create()
   end

Return ( oUser:cCodigo() )



Function cCurGrp()

   if oUser == nil
      oUser := TUser():Create()
   end

Return ( oUser:cGrupo() )
