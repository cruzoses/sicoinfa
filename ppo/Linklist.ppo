#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 7 ".\Prg\Linklist.prg"
_HB_CLASS TLinkList ; UTILITY FUNCTION TLinkList(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TLinkList" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { oFirst, oLast} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oFirst" , "oLast" }, .F., .F. ), )

   _HB_MEMBER New(); IIF( .F., s_oClass:ModInline( "New", {|Self | Self, Self }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "New", {|Self | Self, Self }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER Add( cPrompt, nLevel, hBmpOpen, hBmpClose, lOpened); IIF( .F., s_oClass:ModMethod( "Add", @TLinkList_Add(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Add", @TLinkList_Add(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER OpenAll(); IIF( .F., s_oClass:ModMethod( "OpenAll", @TLinkList_OpenAll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "OpenAll", @TLinkList_OpenAll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GetLast(); IIF( .F., s_oClass:ModMethod( "GetLast", @TLinkList_GetLast(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetLast", @TLinkList_GetLast(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER nCount(); IIF( .F., s_oClass:ModMethod( "nCount", @TLinkList_nCount(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nCount", @TLinkList_nCount(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Draw( cPrevDraw); IIF( .F., s_oClass:ModMethod( "Draw", @TLinkList_Draw(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Draw", @TLinkList_Draw(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER End(); IIF( .F., s_oClass:ModMethod( "End", @TLinkList_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "End", @TLinkList_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Eval(bAction); IIF( .F., s_oClass:ModMethod( "Eval", @TLinkList__Eval(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ), s_oClass:AddMethod( "Eval", @TLinkList__Eval(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ) );

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TLinkList ;



UTILITY STATIC function TLinkList_Add( cPrompt, nLevel, hBmpOpen, hBmpClose, lOpened) ; local Self AS CLASS TLinkList := QSelf() AS CLASS TLinkList

   local oItem

   IIF( lOpened == nil, lOpened := .F., ) ; IIF( nLevel == nil, nLevel := If( ::oFirst <> nil, ::oFirst:nLevel,), );

   oItem := TTreeItem():New( cPrompt, nLevel, hBmpOpen, hBmpClose )

   if ::oFirst == nil
      ::oFirst = oItem
      ::oLast  = oItem
   else
      ::oLast:SetNext( oItem )
      oItem:oPrev   = ::oLast
      ::oLast       = oItem
   endif

   oItem:lOpened = lOpened

return oItem



UTILITY STATIC function TLinkList_OpenAll() ; local Self AS CLASS TLinkList := QSelf() AS CLASS TLinkList

   local oItem := ::oFirst

   while oItem <> nil
      oItem:Open()
      oItem = oItem:GetNext()
   end

return nil



UTILITY STATIC function TLinkList_GetLast() ; local Self AS CLASS TLinkList := QSelf() AS CLASS TLinkList

   if ::oLast:lOpened
      return ::oLast:oTree:GetLast()
   else
      return ::oLast
   endif

return nil



UTILITY STATIC function TLinkList_Draw( cPrevDraw) ; local Self AS CLASS TLinkList := QSelf() AS CLASS TLinkList

   local oItem := ::oFirst

   while oItem <> nil
      oItem:Draw( cPrevDraw )


      oItem = If( oItem:oNext <> nil .AND.  oItem:oNext:nLevel == oItem:nLevel, oItem:oNext, nil )
   end

return nil



UTILITY STATIC function TLinkList_nCount() ; local Self AS CLASS TLinkList := QSelf() AS CLASS TLinkList

   local oItem  := ::oFirst
   local nItems := 0

   while oItem <> nil
      nItems++
      oItem = oItem:GetNext()
   end

return nItems



UTILITY STATIC function TLinkList__Eval(bAction) ; local Self AS CLASS TLinkList := QSelf() AS CLASS TLinkList

   local oItem := ::oFirst

   while oItem <> nil
      Eval( bAction, oItem )
      oItem = If( oItem:oTree <> nil, oItem:oTree:oFirst, oItem:oNext )
   end

return nil



UTILITY STATIC function TLinkList_End() ; local Self AS CLASS TLinkList := QSelf() AS CLASS TLinkList

   local oItem := ::oFirst
   local aBmps, n

   while oItem <> nil
      oItem:End()
      oItem = If( oItem:oTree <> nil, oItem:oTree:oFirst, oItem:oNext )
   end

   aBmps = GetTreeBmps()
   if ValType( aBmps ) == "A"
      for n = 1 to Len( aBmps )
         DeleteObject( aBmps[ n ] )
      next
   endif

return nil
