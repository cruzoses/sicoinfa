#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 6 ".\Prg\Toleword.prg"
_HB_CLASS TOleWord ; UTILITY FUNCTION TOleWord(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TOleWord" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { cTitle} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cTitle" }, .F., .F. ), )
   _HB_MEMBER { lMeter} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lMeter" }, .F., .F. ), )
   _HB_MEMBER { cMessage} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cMessage" }, .F., .F. ), )

   _HB_MEMBER { oWord} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oWord" }, .F., .F. ), )

   _HB_MEMBER { oWaitMeter} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oWaitMeter" }, .F., .F. ), )

   _HB_MEMBER { lError} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lError" }, .F., .F. ), )

   _HB_MEMBER New(); IIF( .F., s_oClass:ModMethod( "New", @TOleWord_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TOleWord_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ExportBrowse( oBrowse); IIF( .F., s_oClass:ModMethod( "ExportBrowse", @TOleWord_ExportBrowse(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ExportBrowse", @TOleWord_ExportBrowse(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER End(); IIF( .F., s_oClass:ModMethod( "End", @TOleWord_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "End", @TOleWord_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TOleWord ;



UTILITY STATIC function TOleWord_New( cTitle, cMessage, lMeter) ; local Self AS CLASS TOleWord := QSelf() AS CLASS TOleWord

   local oBlock

   IIF( cTitle == nil, cTitle := "Espere por favor", ) ;
   IIF( lMeter == nil, lMeter := .T., ) ;
   IIF( cMessage == nil, cMessage := "Conectando con Word", ) ;

   ::cTitle          := cTitle
   ::lMeter          := lMeter
   ::cMessage        := cMessage

   if ::lMeter
      ::oWaitMeter   := TWaitMeter():New( ::cTitle, ::cMessage )
   end

   TRY
      ::oWord        := GetActiveObject( "Word.Application" )
   CATCH
      TRY
         ::oWord     := CreateObject( "Word.Application" )
      CATCH
         ::lError    := .T.
         MsgStop( "ERROR! Word no disponible. [" + Ole2TxtError()+ "]" )
         RETURN ( Self )
      END
   END

Return ( Self )



UTILITY STATIC function TOleWord_ExportBrowse( oBrowse) ; local Self AS CLASS TOleWord := QSelf() AS CLASS TOleWord

   local nRec
   local nRow
   local nCol
   local uData
   local oDocs
   local oActiveDoc
   local oRange
   local oTables
   local oTable
   local oTablesItem
   local oTablesItemCell
   local oTablesItemCellRange
   local aText
   local cText       := ""
   local nBrowseLen
   local nBrowseHead
   local nBrowseAt
   local nEvery
   local oBlock
   local oError

   if ::lError
      Return ( Self )
   end

   oBlock               := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      if !Empty( oBrowse:cAlias ) .AND. Upper( oBrowse:cAlias ) <> "ARRAY" .AND. Upper( oBrowse:cAlias ) <> "_TXT_"
         nRec           := ( oBrowse:cAlias )->( Recno() )
      end

      nBrowseLen        := oBrowse:nLen
      nBrowseHead       := len( oBrowse:aHeaders )
      nBrowseAt         := oBrowse:nAt
      nEvery            := Max( 1, Int( nBrowseLen / 10 ) )

      if ::lMeter
         ::oWaitMeter:SetTotal( nBrowseLen )
         ::oWaitMeter:SetMessage( "Exportando datos a Word" )
      end

      oDocs             := ::oWord:Get( "Documents" )
      oDocs:Add()

      oActiveDoc        := ::oWord:Get( "ActiveDocument" )
      oRange            := oActiveDoc:Range( 0, 0 )

      oTables           := oActiveDoc:Tables()
      oTable            := oTables:Add( oRange, nBrowseLen, nBrowseHead )
      oTablesItem       := oTables:Item( 1 )





      oBrowse:GoTop()

      for nRow := 1 to nBrowseLen

         aText          := Eval( oBrowse:bLine )

         for nCol := 1 to Len( aText )

            if ValType( aText[ nCol ] ) <> "C"
               uData    := ""
            else
               uData    := StrTran( aText[ nCol ], Chr(13)+Chr(10), Chr( 10 ) )
            end

            oTablesItemCell            := oTablesItem:Cell( nRow, nCol )
            oTablesItemCellRange       := oTablesItemCell:Range()
            oTablesItemCellRange:Text  := uData

            cText       += AllTrim( uData ) + Chr( 9 )

         next

         oBrowse:Skip( 1 )

         SysRefresh()

         if ::lMeter .AND. Mod( nRow, nEvery ) == 0
            ::oWaitMeter:RefreshMeter( nRow )
         end

      next

      oTablesItem:AutoFitBehavior( 1 )

      if !Empty( oBrowse:cAlias ) .AND. Upper( oBrowse:cAlias ) <> "ARRAY" .AND. Upper( oBrowse:cAlias ) <> "_TXT_"
         ( oBrowse:cAlias )->( dbGoTo( nRec ) )
      end

      oBrowse:nAt       := nBrowseAt

      if ::lMeter
         ::oWaitMeter:RefreshMeter( nBrowseLen )
      end

      ::oWord:Visible   := .T.

   RECOVER USING oError

      msgStop( "Error al exportar a Word." + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

Return ( Self )



UTILITY STATIC function TOleWord_End() ; local Self AS CLASS TOleWord := QSelf() AS CLASS TOleWord

   if !Empty( ::oWord )
      ::oWord           := nil
   end

   if ::lMeter .AND. !Empty( ::oWaitMeter )
      ::oWaitMeter:End()
   end

Return ( Self )
