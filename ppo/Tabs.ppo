#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 28 ".\Prg\Tabs.prg"
_HB_CLASS TTabs ; UTILITY FUNCTION TTabs(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TTabs" , {TControl():classh} ) ) ; ;

   _HB_MEMBER {AS LOGICAL lRegistered} ; IIF( !.F., s_oClass:AddMultiClsData("LOGICAL",, nScope + IIF( .F., 32, 0 ) + 64, { "lRegistered" }, .F. ), )


   _HB_MEMBER { aProperties} ; IIF( !.F., s_oClass:AddMultiClsData(, { "aPrompts", "nAlign", "nClrText", "nClrPane", "nOption", "nTop", "nLeft", "nWidth", "nHeight", "Cargo" }, nScope + IIF( .F., 32, 0 ) + 64, { "aProperties" }, .F. ), )

   _HB_MEMBER { aPrompts, aSizes} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aPrompts" , "aSizes" }, .F., .F. ), )
   _HB_MEMBER { nOption} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nOption" }, .F., .F. ), )
   _HB_MEMBER { bAction} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bAction" }, .F., .F. ), )
   _HB_MEMBER { cMode} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cMode" }, .F., .F. ), )



   _HB_MEMBER New( nTop, nLeft, aPrompts, bAction, oWnd, nOption, nClrFore, nClrBack, lPixel, lDesign, nWidth, nHeight, cMsg, cMode) AS CLASS TTabs; IIF( .F., s_oClass:ModMethod( "New", @TTabs_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TTabs_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER ReDefine( nId, aPrompts, bAction, oWnd, nOption, nClrFore, nClrBack) AS CLASS TTabs; IIF( .F., s_oClass:ModMethod( "ReDefine", @TTabs_ReDefine(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReDefine", @TTabs_ReDefine(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Display(); IIF( .F., s_oClass:ModMethod( "Display", @TTabs_Display(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Display", @TTabs_Display(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Paint(); IIF( .F., s_oClass:ModMethod( "Paint", @TTabs_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Paint", @TTabs_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Initiate( hDlg); IIF( .F., s_oClass:ModMethod( "Initiate", @TTabs_Initiate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Initiate", @TTabs_Initiate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER LButtonDown( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "LButtonDown", @TTabs_LButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LButtonDown", @TTabs_LButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Default(); IIF( .F., s_oClass:ModMethod( "Default", @TTabs_Default(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Default", @TTabs_Default(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER AddItem( cItem); IIF( .F., s_oClass:ModMethod( "AddItem", @TTabs_AddItem(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AddItem", @TTabs_AddItem(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DelItem(); IIF( .F., s_oClass:ModMethod( "DelItem", @TTabs_DelItem(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DelItem", @TTabs_DelItem(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetOption( nOption); IIF( .F., s_oClass:ModMethod( "SetOption", @TTabs_SetOption(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetOption", @TTabs_SetOption(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetTabs( aTabs, nOption); IIF( .F., s_oClass:ModMethod( "SetTabs", @TTabs_SetTabs(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetTabs", @TTabs_SetTabs(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GetHotPos( nChar); IIF( .F., s_oClass:ModMethod( "GetHotPos", @TTabs_GetHotPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetHotPos", @TTabs_GetHotPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SysCommand( nType, nLoWord, nHiWord); IIF( .F., s_oClass:ModMethod( "SysCommand", @TTabs_SysCommand(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SysCommand", @TTabs_SysCommand(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Inspect( cData); IIF( .F., s_oClass:ModMethod( "Inspect", @TTabs_Inspect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Inspect", @TTabs_Inspect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER EditPrompts(); IIF( .F., s_oClass:ModMethod( "EditPrompts", @TTabs_EditPrompts(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "EditPrompts", @TTabs_EditPrompts(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TTabs ;




UTILITY STATIC function TTabs_New( nTop, nLeft, aPrompts, bAction, oWnd, nOption, nClrFore, nClrBack, lPixel, lDesign, nWidth, nHeight, cMsg, cMode) ; local Self AS CLASS TTabs := QSelf() AS CLASS TTabs















   IIF( nTop == nil, nTop := 0, ) ; IIF( nLeft == nil, nLeft := 0, ); IIF( aPrompts == nil, aPrompts := { "&One", "&Two", "T&hree" }, ); IIF( oWnd == nil, oWnd := GetWndDefault(), ); IIF( nOption == nil, nOption := 1, ); IIF( nClrFore == nil, nClrFore := oWnd:nClrText, ); IIF( nClrBack == nil, nClrBack := GetSysColor( 15 ), ); IIF( lPixel == nil, lPixel := .F., ); IIF( lDesign == nil, lDesign := .F., ); IIF( nWidth == nil, nWidth := 200, ); IIF( nHeight == nil, nHeight := 24, ); IIF( cMode == nil, cMode := "BOTTOM", );


   ::nStyle    = nOR( 1073741824, 268435456, If( lDesign, 67108864, 0 ), 65536 )
   ::nId       = ::GetNewId()
   ::oWnd      = oWnd
   ::aPrompts  = aPrompts
   ::bAction   = bAction
   ::nOption   = nOption
   ::cMsg      = cMsg
   ::nTop      = If( lPixel, nTop, nTop * 15 )
   ::nLeft     = If( lPixel, nLeft, nLeft * 6 )
   ::nBottom   = ::nTop + nHeight - 1
   ::nRight    = ::nLeft + nWidth - 1
   ::lDrag     = lDesign
   ::lCaptured = .F.
   ::oFont     = TFont():New( "Ms Sans Serif", 0, -9 )
   ::nClrText  = nClrFore
   ::nClrPane  = nClrBack
   ::cMode     = cMode

   ::oBrush := TBrush():New( Upper("TABS"),,,,, )





   ::Register()

   if ! Empty( oWnd:hWnd )
      ::Create()
      oWnd:AddControl( Self )
   else
      oWnd:DefControl( Self )
   endif

   ::Default()

   if lDesign
      ::CheckDots()
   endif

return Self




UTILITY STATIC function TTabs_ReDefine( nId, aPrompts, bAction, oWnd, nOption, nClrFore, nClrBack) ; local Self AS CLASS TTabs := QSelf() AS CLASS TTabs



   IIF( nOption == nil, nOption := 1, ) ; IIF( nClrFore == nil, nClrFore := oWnd:nClrText, ); IIF( nClrBack == nil, nClrBack := GetSysColor( 15 ), );

   ::nId      = nId
   ::oWnd     = oWnd
   ::aPrompts = aPrompts
   ::bAction  = bAction
   ::nOption  = nOption
   ::oFont    = TFont():New( "Ms Sans Serif", 0, -9 )
   ::nClrText = nClrFore
   ::nClrPane = nClrBack
   ::cMode    = "BOTTOM"

   ::Register()

   oWnd:DefControl( Self )

return Self



UTILITY STATIC function TTabs_Display() ; local Self AS CLASS TTabs := QSelf() AS CLASS TTabs

   ::BeginPaint()
   ::Paint()
   ::EndPaint()

return 0



UTILITY STATIC function TTabs_Paint() ; local Self AS CLASS TTabs := QSelf() AS CLASS TTabs

   local n
   local hOldFont
   local hOldBrush
   local hOldPen
   local nCol        := 5
   local hDC         := ::GetDC()
   local hDarkPen    := CreatePen( 0, 1, GetSysColor( 16 ) )
   local hGrayPen    := CreatePen( 0, 1, ::nClrPane )
   local hLightPen   := CreatePen( 0, 1, GetSysColor( 20 ) )
   local hGrayBrush  := CreateSolidBrush( ::nClrPane )
   local hDarkBrush  := CreateSolidBrush( GetSysColor( 3 ) )

   hOldFont  = SelectObject( hDC, ::oFont:hFont )
   hOldPen   = SelectObject( hDC, hDarkPen )
   hOldBrush = SelectObject( hDC, hDarkBrush )

   if Len( ::aSizes ) < Len( ::aPrompts )
      ::Default()
   endif

   if ::cMode == "BOTTOM"

      SelectObject( hDC, hGrayPen )
      MoveTo( hDC, 0, 1 )
      LineTo( hDC, ::nWidth(), 1 )
      MoveTo( hDC, 0, 2 )
      LineTo( hDC, ::nWidth(), 2 )

      SetBlackPen( hDC )
      MoveTo( hDC, 0, 3 )
      LineTo( hDC, ::nWidth(), 3 )

      for n = 1 to Len( ::aPrompts )

         if n == ::nOption

            SelectObject( hDC, hGrayBrush )
            SetBlackPen( hDC )



            PolyPolygon( hDC, {  { nCol, 3 }, { nCol , 20 }, { nCol + 4 + ::aSizes[ n ] + 8, 20 }, { nCol + 4 + ::aSizes[ n ] + 8 + 17, 3 } } )

            SelectObject( hDC, hLightPen )
            MoveTo( hDC, nCol , 3 )
            LineTo( hDC, nCol , 20 )

            SelectObject( hDC, hGrayPen )
            MoveTo( hDC, nCol , 3 )
            LineTo( hDC, nCol + 4 + ::aSizes[ n ] + 8 + 17, 3 )

            SetTextColor( hDC, ::nClrText )
            SetBkColor( hDC, ::nClrPane )


            DrawText( hDC, ::aPrompts[ n ], { 5, nCol + 4, 19, nCol + 5 + ::aSizes[ n ] + 5 }, nOr( 1, 4 ) )

         else

            SelectObject( hDC, hDarkBrush )
            SetBlackPen( hDC )



            PolyPolygon( hDC, {  { nCol, 3 }, { nCol , 20 }, { nCol + 4 + ::aSizes[ n ] + 8, 20 }, { nCol + 4 + ::aSizes[ n ] + 8 + 17, 3 } } )

            SelectObject( hDC, hGrayPen )
            MoveTo( hDC, nCol , 4 )
            LineTo( hDC, nCol , 20 )

            SetTextColor( hDC, 16777215 )
            SetBkColor( hDC, GetSysColor( 3 ) )


            DrawText( hDC, ::aPrompts[ n ], { 5, nCol + 3, 19, nCol + 5 + ::aSizes[ n ] + 6 }, nOr( 1, 4 ) )

         endif

         nCol += 4 + ::aSizes[ n ] + 26

      next

   elseif ::cMode == "TOP"

      MoveTo( hDC, 0, ::nHeight() )
      LineTo( hDC, ::nWidth(), ::nHeight() )

      SetWhitePen( hDC )
      MoveTo( hDC, 0, ::nHeight() -3  )
      LineTo( hDC, ::nWidth(), ::nHeight() - 3 )

      for n = 1 to Len( ::aPrompts )

         if n == ::nOption

            SelectObject( hDC, hGrayBrush )
            SetBlackPen( hDC )



            PolyPolygon( hDC, {  { nCol, ::nHeight() - 3 }, { nCol , ::nHeight() - 20 }, { nCol + 4 + ::aSizes[ n ] + 8, ::nHeight() - 20 }, { nCol + 4 + ::aSizes[ n ] + 8, ::nHeight() - 3 } } )

            SelectObject( hDC, hLightPen )
            MoveTo( hDC, nCol , ::nHeight() - 3 )
            LineTo( hDC, nCol , ::nHeight() - 20 )

            SelectObject( hDC, hGrayPen )
            MoveTo( hDC, nCol , ::nHeight() - 3 )
            LineTo( hDC, nCol + 4 + ::aSizes[ n ] + 8, ::nHeight() - 3 )

            SetTextColor( hDC, 0 )
            SetBkColor( hDC, ::nClrPane )


            DrawText( hDC, ::aPrompts[ n ], { ::nHeight() - 19, nCol + 4, ::nHeight() - 5, nCol + 5 + ::aSizes[ n ] + 5 }, nOr( 1, 4 ) )

         else








            SelectObject( hDC, hGrayPen )
            MoveTo( hDC, nCol , ::nHeight() - 4 )
            LineTo( hDC, nCol , ::nHeight() - 20 )

            SetTextColor( hDC, 16777215 )
            SetBkColor( hDC, ::nClrPane )


            DrawText( hDC, ::aPrompts[ n ], { ::nHeight() - 19 , nCol + 3, ::nHeight() - 5, nCol + 5 + ::aSizes[ n ] + 6 }, nOr( 1, 4 ) )


         end

        nCol += 4 + ::aSizes[ n ] + 26

      next

   end

   SelectObject( hDC, hOldPen )
   SelectObject( hDC, hOldFont )
   SelectObject( hDC, hOldBrush )

   DeleteObject( hDarkPen )
   DeleteObject( hGrayPen )
   DeleteObject( hLightPen )
   DeleteObject( hDarkBrush )
   DeleteObject( hGrayBrush )

   ::ReleaseDC()

return nil



UTILITY STATIC function TTabs_Initiate( hDlg) ; local Self AS CLASS TTabs := QSelf() AS CLASS TTabs

   ::TControl:Initiate( hDlg )

   if ::oBrush == nil
      ::oBrush := TBrush():New( Upper("TABS"),,,,, )
   endif

   ::Default()

return nil



UTILITY STATIC function TTabs_LButtonDown( nRow, nCol, nFlags) ; local Self AS CLASS TTabs := QSelf() AS CLASS TTabs

   local n := 1, nPos := 5

   if ::lDrag
      return ::TControl:LButtonDown( nRow, nCol, nFlags )
   else
      if nRow <= 22
         while nCol > nPos + ::aSizes[ n ] + 30 .AND. n < Len( ::aPrompts )
            nPos += ::aSizes[ n ] + 30
            n++
         end
         ::SetOption( n )
      endif
   endif

return nil



UTILITY STATIC function TTabs_Default() ; local Self AS CLASS TTabs := QSelf() AS CLASS TTabs

   local n

   ::aSizes = Array( Len( ::aPrompts ) )

   for n = 1 to Len( ::aPrompts )

      ::aSizes[ n ] = GetTextWidth( 0, StrTran( ::aPrompts[ n ], "&", "" ), ::oFont:hFont )
   next

return nil



UTILITY STATIC function TTabs_AddItem( cItem) ; local Self AS CLASS TTabs := QSelf() AS CLASS TTabs

   AAdd( ::aPrompts, cItem )
   ::Default()
   ::Refresh()

return nil



UTILITY STATIC function TTabs_DelItem() ; local Self AS CLASS TTabs := QSelf() AS CLASS TTabs

   if Len( ::aPrompts ) > 1
      ::aPrompts = ADel( ::aPrompts, ::nOption )
      ::aPrompts = ASize( ::aPrompts, Len( ::aPrompts ) - 1 )
   else
      ::aPrompts = { "No Defined" }
   endif
   ::Default()
   ::Refresh()

return nil



UTILITY STATIC function TTabs_SetOption( nOption) ; local Self AS CLASS TTabs := QSelf() AS CLASS TTabs

   if nOption <> ::nOption
      ::nOption = nOption
      ::Paint()
      if ! Empty( ::bAction )
         Eval( ::bAction, nOption )
      endif
   endif

return nil



UTILITY STATIC function TTabs_GetHotPos( nChar) ; local Self AS CLASS TTabs := QSelf() AS CLASS TTabs

   local n := 1
   local nAt

   while n <= Len( ::aPrompts )

     if ( nAt := At( "&", ::aPrompts[ n ] ) ) <> 0 .AND.  Lower( SubStr( ::aPrompts[ n ], nAt + 1, 1 ) ) == Chr( nChar )
        return n
     endif
     n++
   end

return 0



UTILITY STATIC function TTabs_SysCommand( nType, nLoWord, nHiWord) ; local Self AS CLASS TTabs := QSelf() AS CLASS TTabs

   local nItem

   do case
      case nType == 61696
           if ( nItem := ::GetHotPos( nLoWord ) ) > 0
              ::SetOption( nItem )
              return 0
           endif
   endcase

return nil



UTILITY STATIC function TTabs_SetTabs( aTabs, nOption) ; local Self AS CLASS TTabs := QSelf() AS CLASS TTabs

   IIF( aTabs == nil, aTabs := { "&One", "&Two", "T&hree" }, ) ; IIF( nOption == nil, nOption := 1, );

   ::aPrompts = aTabs
   ::nOption  = nOption
   ::Default()
   ::Refresh()

return nil



UTILITY STATIC function TTabs_Inspect( cData) ; local Self AS CLASS TTabs := QSelf() AS CLASS TTabs

   if cData == "aPrompts"
      return { || ::EditPrompts() }
   endif

return nil



UTILITY STATIC function TTabs_EditPrompts() ; local Self AS CLASS TTabs := QSelf() AS CLASS TTabs

   local oDlg, n
   local cPrompts := ""
   local oFont
   local lOk := .F.
   local aPrompts := {}

   for n = 1 to Len( ::aPrompts )
      cPrompts += ::aPrompts[ n ] + Chr(13)+Chr(10)
   next

   oFont := TFont():New( "Ms Sans Serif", 0, -9,,,,,,,,,,,,,, )

   oDlg = TDialog():New(,,,, "Edit prompts",,, .F.,,,,,, .F.,, oFont,, 300, 178, .F., )

   TMultiGet():New( 0.2, 0.3, { | u | If( PCount()==0, cPrompts, cPrompts:= u ) },, 145, 70,, .F.,,,, .F.,, .F.,, .F., .F., .F.,,, .F.,, )

   TButton():New( 7.5, 10.1, "&Ok",, {|| ( lOk := .T., oDlg:End() )}, 30, 11,,, .F., .F., .F.,, .F.,,, .F. )
   TButton():New( 7.5, 22.1, "&Cancel",, {|| oDlg:End()}, 30, 11,,, .F., .F., .F.,, .F.,,, .F. )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if lOk
      for n = 1 to MLCount( cPrompts )
         AAdd( aPrompts, AllTrim( MemoLine( cPrompts,, n ) ) )
      next
      ::SetTabs( aPrompts, 1 )
   endif

return nil
