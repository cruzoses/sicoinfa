#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 7 ".\Prg\ActualizaCosto.prg"
_HB_CLASS ActualizaCosto ; UTILITY FUNCTION ActualizaCosto(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "ActualizaCosto" , {TInfGen():classh} ) ) ; ;

   _HB_MEMBER {AS OBJECT oDbfArt} ; IIF( !.F., s_oClass:AddMultiData( "OBJECT",, nScope + IIF( .F., 32, 0 ), { "oDbfArt" }, .F., .F. ), )
   _HB_MEMBER {AS OBJECT oDbfDiv} ; IIF( !.F., s_oClass:AddMultiData( "OBJECT",, nScope + IIF( .F., 32, 0 ), { "oDbfDiv" }, .F., .F. ), )
   _HB_MEMBER {AS OBJECT oProduccT} ; IIF( !.F., s_oClass:AddMultiData( "OBJECT",, nScope + IIF( .F., 32, 0 ), { "oProduccT" }, .F., .F. ), )
   _HB_MEMBER {AS OBJECT oMetMsg} ; IIF( !.F., s_oClass:AddMultiData( "OBJECT",, nScope + IIF( .F., 32, 0 ), { "oMetMsg" }, .F., .F. ), )

   _HB_MEMBER OpenFiles(); IIF( .F., s_oClass:ModMethod( "OpenFiles", @ActualizaCosto_OpenFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "OpenFiles", @ActualizaCosto_OpenFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CloseFiles(); IIF( .F., s_oClass:ModMethod( "CloseFiles", @ActualizaCosto_CloseFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CloseFiles", @ActualizaCosto_CloseFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Activate( oMenuItem, oWnd); IIF( .F., s_oClass:ModMethod( "Activate", @ActualizaCosto_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Activate", @ActualizaCosto_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Search(); IIF( .F., s_oClass:ModMethod( "Search", @ActualizaCosto_Search(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Search", @ActualizaCosto_Search(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS ActualizaCosto ;



UTILITY STATIC function ActualizaCosto_OpenFiles() ; local Self AS CLASS ActualizaCosto := QSelf() AS CLASS ActualizaCosto

   local lOpen    := .T.
   local oBlock   := ErrorBlock( {| oError | ApoloBreak( oError ) } )

   BEGIN SEQUENCE

      ::oDbfArt := DbfServer( "ARTICULO.DBF", ):NewOpen( "ARTICULO.DBF",, ( cDriver() ),, ( cPatArt() ), .F., .T., .F., .F. ) ; ::oDbfArt:AddBag( "ARTICULO.CDX" ) ; ::oDbfArt:AddBag( ) ; ::oDbfArt:AutoIndex()

      ::oDbfDiv := DbfServer( "DIVISAS.DBF", ):NewOpen( "DIVISAS.DBF",, ( cDriver() ),, ( cPatDat() ), .F., .T., .F., .F. ) ; ::oDbfDiv:AddBag( "DIVISAS.CDX" ) ; ::oDbfDiv:AddBag( ) ; ::oDbfDiv:AutoIndex()

      ::oProduccT    :=  TProduccion():Create( cPatEmp() )
      ::oProduccT:OpenFiles()

   RECOVER

      msgStop( "Imposible abrir todas las bases de datos.", "Atención" )

      ::CloseFiles()

      lOpen := .F.

   end

   ErrorBlock( oBlock )

RETURN( lOpen )



UTILITY STATIC function ActualizaCosto_CloseFiles() ; local Self AS CLASS ActualizaCosto := QSelf() AS CLASS ActualizaCosto

   if !Empty( ::oDbfArt )
      ::oDbfArt:End()
   end

   if !Empty( ::oProduccT )
      ::oProduccT:end()
   end

   if !Empty( ::oDbfDiv )
      ::oDbfDiv:End()
   end

   ::oDbfArt   := nil
   ::oDbfDiv   := nil
   ::oProduccT := nil

RETURN ( Self )



UTILITY STATIC function ActualizaCosto_Activate( oMenuItem, oWnd) ; local Self AS CLASS ActualizaCosto := QSelf() AS CLASS ActualizaCosto

   local oDlg
   local nLevel
   local nMetMsg        := 0
   local oCodArt
   local cCodArt        := ""
   local oSayArt
   local cSayArt        := ""
   local oBmp

   IIF( oMenuItem == nil, oMenuItem := "04008", ) ;
   IIF( oWnd == nil, oWnd := oWnd(), ) ;



   nLevel               := nLevelUsr( oMenuItem )
   if nAnd( nLevel, 1 ) <> 0
      msgStop( "Acceso no permitido." )
      return nil
   end



   if oWnd <> nil
      SysRefresh(); oWnd:CloseAll(); SysRefresh()
   end

   if !::OpenFiles()
      Return ( Self )
   end

   oDlg = TDialog():New(,,,,, "ACTUALIZACOSTOS",, .F.,,,,, oWnd(), .F.,,,,,, .F., )




   oBmp := TBitmap():ReDefine( 800, "PreciosManodeObra",, oDlg,,, .F., .F.,,, .F.,,, .F. )

   ::oDefIniInf( 100, oDlg )
   ::oDefFinInf( 110, oDlg )






   oCodArt := TGetHlp():ReDefine( ( 120 ), { | u | If( PCount()==0, cCodArt, cCodArt:= u ) }, oDlg,,, {||    cArticulo( oCodArt, ::oDbfArt:cAlias, oSayArt )},,,,,, .F.,,, .F., .F.,,,,, {|Self|BrwArticulo( oCodArt, oSayArt )}, nil, "LUPA",, )




   oSayArt := TGetHlp():ReDefine( ( 130 ), { | u | If( PCount()==0, cSayArt, cSayArt:= u ) }, oDlg,,,,,,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )




   ::oMetMsg := TMeter():ReDefine( 140, { | u | If( PCount()==0, nMetMsg, nMetMsg:= u ) }, ( ::oProduccT:oDbf:Lastrec() ), oDlg, .F.,,, .F.,,,, )




   TButton():ReDefine( 500, {||( ::Search( cCodArt, oDlg ) )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 550, {||( oDlg:End() )}, oDlg,,, .F.,,,, .F. )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   ::CloseFiles()

   oBmp:End()

RETURN ( Self )



UTILITY STATIC function ActualizaCosto_Search( cCodArt, oDlg) ; local Self AS CLASS ActualizaCosto := QSelf() AS CLASS ActualizaCosto

   local cExpHead          := ""
   local nTotCostoPersonal := 0
   local nTotLitros        := 0



   if Empty( cCodArt )
      MsgStop( "Tiene que seleccionar el artículo al que va a cambiar el costo" )
      return .F.
   end

   if ::dFinInf < ::dIniInf
      MsgStop( "Margen de fecha erróneo" )
      return .F.
   end



   ::oProduccT:oDbf:OrdSetFocus( "dFecOrd" )

   cExpHead       := 'dFecOrd >= Ctod( "' + Dtoc( ::dIniInf ) + '" ) .and. dFecFin <= Ctod( "' + Dtoc( ::dFinInf ) + '" )'

   ::oProduccT:oDbf:AddTmpIndex( cCurUsr(), GetFileNoExt( ::oProduccT:oDbf:cFile ), ::oProduccT:oDbf:OrdKey(), ( cExpHead ), , , , , , , , .T. )

   ::oMetMsg:SetTotal( ::oProduccT:oDbf:OrdKeyCount() )

   ::oProduccT:oDbf:GoTop()

   while !::oProduccT:oDbf:Eof()

      nTotCostoPersonal    += ::oProduccT:nTotalPersonal( ::oProduccT:oDbf:cSerOrd + Str( ::oProduccT:oDbf:nNumOrd ) + ::oProduccT:oDbf:cSufOrd )

      if ::oProduccT:oDetProduccion:oDbf:Seek( ::oProduccT:oDbf:cSerOrd + Str( ::oProduccT:oDbf:nNumOrd ) + ::oProduccT:oDbf:cSufOrd )

         while ::oProduccT:oDetProduccion:oDbf:cSerOrd + Str( ::oProduccT:oDetProduccion:oDbf:nNumOrd ) + ::oProduccT:oDetProduccion:oDbf:cSufOrd == ::oProduccT:oDbf:cSerOrd + Str( ::oProduccT:oDbf:nNumOrd ) + ::oProduccT:oDbf:cSufOrd .AND. !::oProduccT:oDetProduccion:oDbf:eof()

            nTotLitros     += NotCaja( ::oProduccT:oDetProduccion:oDbf:nCajOrd ) * NotCero( ::oProduccT:oDetProduccion:oDbf:nUndOrd ) * NotCero( ::oProduccT:oDetProduccion:oDbf:nVolumen )

            ::oProduccT:oDetProduccion:oDbf:Skip()

         end

      end

      ::oProduccT:oDbf:Skip()

      ::oMetMsg:Set( ::oProduccT:oDbf:OrdKeyNo() )

   end

   ::oProduccT:oDbf:IdxDelete( cCurUsr(), GetFileNoExt( ::oProduccT:oDbf:cFile ) )

   ::oMetMsg:Set( ::oProduccT:oDbf:Lastrec() )






   if ApoloMsgNoYes( "Se va a cambiar costo del artículo."                                         + Chr(13)+Chr(10) +  AllTrim( cCodArt ) + " - " + AllTrim( oRetFld( cCodArt, ::oDbfArt ) ) + ";"   + Chr(13)+Chr(10) +  "el nuevo costo será : " + AllTrim( Trans( ( nTotCostoPersonal / nTotLitros ), cPinDiv( cDivEmp(), ::oDbfDiv ) ) ) + cSimDiv( cDivEmp(), ::oDbfDiv ) , "¿ Desea proceder ?" )

      if ::oDbfArt:SeekInOrd( cCodArt, "Codigo" )

         ::oDbfArt:Load()
         ::oDbfArt:pCosto  := ( nTotCostoPersonal / nTotLitros )
         ::oDbfArt:Save()

         msgInfo( "El precio del artículo se ha actualizado correctamente", AllTrim( cCodArt ) + " - " + AllTrim( oRetFld( cCodArt, ::oDbfArt ) ) )

      end

   end

RETURN ( oDlg:End() )
