#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 19 ".\Prg\Tutil.prg"
function lSetBuffer( oDbf, cOnOff )

    local lBuf := .F.
    local cType := "C"

    if ValType( oDbf ) == "O"
        lBuf := oDbf:lBuffer
        if cOnOff == nil
            lBuf := .F.
        else
            cType := ValType( cOnOff )
            if cType == "C"
                cOnOff := upper( cOnOff )
                if cOnOff $ "ON TRUE ACTIVE"
                    lBuf := .T.
                elseif cOnOff $ "OFF FALSE DEACTIVE"
                    lBuf := .F.
                endif
            elseif cType == "L"
                lBuf := cOnOff
            endif
        endif
        oDbf:SetBuffer( lBuf )
    endif

return( lBuf )




Function DbRow( oDb )

    loca aRet := {}

    AEval( oDb:aTField, { | oFld | AAdd( aRet, oFld:AsString ) } )

return( aRet )






Function OrdListLen()

    local nRet := 0
    local n    := 0

    while !empty( OrdName( ++n ) )
        ++nRet
    end

return( nRet )





function GetRecord( nRec )

   local nRecNo  := RecNo()
   local nHeader := Header()
   local nLenRec := RecSize()
   local nHdl    := DbfHdl()
   local nOffSet := 0
   local cBuffer := space( nLenRec )

   nRec := if( ValType( nRec ) <> "N", RecNo(), nRec )
   nOffSet := ( nLenRec * ( nRec - 1 ) ) + nHeader

   FSeek( nHdl, nOffSet, 0 )
   FRead( nHdl, @cBuffer, nLenRec )

   DbGoTo( nRecNo )

return( cBuffer )






function lCheckDbf( oDbf, bRecord )

   local i
   local nPos
   local lMemo
   local nCount
   local cFileNew
   local cMemoNew
   local cFileName
   local cMemoName

   if !IsObject( oDbf )
      return .F.
   end

   nCount            := 0
   lMemo             := oDbf:lMemo
   cFileName         := Upper( oDbf:cFile )
   cMemoName         := StrTran( Upper( oDbf:cFile ), ".DBF", ".FPT" )


   while lExistTable( cFileNew := oDbf:cPath + "FNew" + PadL( ++nCount, 3, "0" ) + ".DBF" ) .OR.  lExistTable( cMemoNew := oDbf:cPath + "FNew" + PadL( nCount, 3, "0" ) + ".FPT" )
   end





   if oDbf:Used()
      oDbf:Close()
   end





   oDbf:IdxFDel()





   if fRenameTable( cFileName, cFileNew, oDbf:cRDD ) <> 0
      return .F.
   end

   if lMemo .AND. fRenameTable( cMemoName, cMemoNew, oDbf:cRDD ) <> 0
      return .F.
   end





   oDbf:Activate( .F., .F. )

   if File( cFileNew )

      dbUseArea( .T., oDbf:cRDD, cFileNew, "_WNew", .F. )

      nCount := oDbf:fCount()

      while !_WNew->( Eof() )

         ( oDbf:nArea )->( DbAppend() )

         for i := 1 to nCount
            nPos  := _WNew->( FieldPos( ( oDbf:nArea )->( FieldName( i ) ) ) )
            if nPos <> 0
               ( oDbf:nArea )->( FieldPut( i, _WNew->( FieldGet( nPos ) ) ) )
            end
         next

         IIF( ValType( bRecord ) == "B", Eval( bRecord, oDbf ), )

         _WNew->( dbSkip() )

      end

      _WNew->( dbCloseArea() )

   end

   if lExistTable( cFileNew, oDbf:cRDD )
      fEraseTable( cFileNew, oDbf:cRDD )
   end

   if lMemo .AND. lExistTable( cMemoNew, oDbf:cRDD )
      fEraseTable( cMemoNew, oDbf:cRDD )
   end

   oDbf:Close()

return( .T. )



function xArea( uWA )

    local nArea := 0
    local nType := ValType( uWA )

    if nType == "O"
        nArea := uWA:nArea
    elseif nType == "C"
        nArea := Select( uWA )
    else
        nArea := Select()
    endif

return( nArea )



function aType( cType )

    local aTipo   := { "ALL" }

    cType         := upper( cType )

    do case
        case cType $ "CM"
            aTipo := { "CHARACTER" }
        case cType == "N"
            aTipo := { "NUMERIC" }
        case cType == "D"
            aTipo := { "DATE" }
        case cType == "L"
            aTipo := { "BOOL" }
        case cType == "B"
            aTipo := { "BLOCK" }
    end

return( aTipo )



Function UpTime( oGet )

   local cTime    := oGet:VarGet()
   local nHora    := Val( SubStr( cTime, 1, 2 ) )
   local nMinuto  := Val( SubStr( cTime, 3, 2 ) )

   ++nMinuto

   if nMinuto > 59
      nMinuto     := 0
      ++nHora
      if nHora > 23
         nHora    := 0
      end
   end

   oGet:cText( StrZero( nHora, 2 ) + StrZero( nMinuto, 2 ) )

Return ( .T. )



Function DwTime( oGet )

   local cTime    := oGet:VarGet()
   local nHora    := Val( SubStr( cTime, 1, 2 ) )
   local nMinuto  := Val( SubStr( cTime, 3, 2 ) )

   --nMinuto

   if nMinuto < 0
      nMinuto     := 59
      --nHora
      if nHora < 0
         nHora    := 23
      end
   end

   oGet:cText( StrZero( nHora, 2 ) + StrZero( nMinuto, 2 ) )

Return ( .T. )



Function ValidTime( oGet )

   local cTime       := oGet:VarGet()
   local cHora       := SubStr( cTime, 1, 2 )
   local nHora       := Val( cHora )
   local cMinuto     := SubStr( cTime, 3, 2 )
   local nMinuto     := Val( cMinuto )

   if nHora < 0 .OR. nHora > 23
      return .F.
   end

   if nMinuto < 0 .OR. nMinuto > 59
      return .F.
   end

   if Empty( cMinuto ) .AND. !Empty( cTime )

      if nHora <= 9
         cHora := "0" + AllTrim( Str( nHora ) )
      end

      oGet:cText( cHora + "00" )
      oGet:Refresh()
   end

Return .T.



Function nElapTime( cTimeInicial, cTimeFinal )

   local nTotalMinutos  := 0

   nTotalMinutos        := ( Val( SubStr( cTimeFinal, 1, 2 ) ) * 60 ) + Val( SubStr( cTimeFinal, 3, 2 ) )
   nTotalMinutos        -= ( Val( SubStr( cTimeInicial, 1, 2 ) ) * 60 ) + Val( SubStr( cTimeInicial, 3, 2 ) )

   if nTotalMinutos < 0
      nTotalMinutos  += 1440
   end

Return ( nTotalMinutos )






Function nTiempoEntreFechas( dFecInicio, dFecFin, cTimeInicio, cTimeFin )

   local nTotalHoras    := 0
   local nTotalMinutos  := 0
   local nDiferencia    := 0

   nDiferencia          := dFecFin - dFecInicio

   nTotalMinutos        := ( Val( SubStr( cTimeFin, 1, 2 ) ) * 60 ) + Val( SubStr( cTimeFin, 3, 2 ) )
   nTotalMinutos        -= ( Val( SubStr( cTimeInicio, 1, 2 ) ) * 60 ) + Val( SubStr( cTimeInicio, 3, 2 ) )


   if nDiferencia == 0
      nTotalHoras       := ( nDiferencia ) * 24
   else
      if nTotalMinutos  >= 0
         nTotalHoras       := ( nDiferencia ) * 24
      else
         nTotalHoras       := ( nDiferencia - 1 ) * 24
      end

   end

   if nTotalMinutos < 0
      nTotalHoras          += ( ( nTotalMinutos + 1440 ) / 60 )
   else
      nTotalHoras          += ( nTotalMinutos / 60 )
   end

Return ( nTotalHoras )






Function cFormatoDDHHMM( nHoras )

   local nDias       := 0
   local nHor        := 0
   local nMinutos    := 0
   local nCalculo    := 0
   local cFormato    := ""

   if nHoras > 0

      nCalculo       := nHoras / 24
      nDias          := Int( nCalculo )
      nCalculo       := ( nCalculo - Int( nCalculo ) ) * 24
      nHor           := Int( nCalculo )
      nCalculo       := ( nCalculo - Int( nCalculo ) ) * 60
      nMinutos       := Int( Round( nCalculo, 0 ) )

      do case
         case nDias > 1
         cFormato    := AllTrim( Str( nDias ) ) + " días, " + AllTrim( Str( nHor ) ) + "h " + AllTrim( Str( nMinutos ) ) + " min"
         case nDias == 1
         cFormato    := AllTrim( Str( nDias ) ) + " día, " + AllTrim( Str( nHor ) ) + "h " + AllTrim( Str( nMinutos ) ) + " min"
         case nDias < 1
         cFormato    := AllTrim( Str( nHor ) ) + "h " + AllTrim( Str( nMinutos ) ) + " min"
      end

   end

Return ( cFormato )



Function cAllTrimer( cCadena )

Return ( StrTran( cCadena, " ", "" ) )







Function MsgBeepYesNo( cText, cTitle )

    ArtBeep()

Return ApoloMsgNoYes( cText, cTitle )







Function MsgBeepStop( cText, cTitle )

   IIF( cText == nil, cText := "Stop", ) ;
   IIF( cTitle == nil, cTitle := "Stop", ) ;

    ArtBeep()

Return MsgStop( cText, cTitle )







Function MsgBeepWait( cText, cTitle, nTime )

    ArtBeep()

Return MsgWait( cText, cTitle, nTime )



Function ArtBeep()

    Tone( 100, 1 )
    Tone( 300, 1 )
    Tone( 100, 1 )
    Tone( 300, 1 )

Return .T.










Function c2Block( cExp )

   local bExp

   if !Empty( cExp )
      bExp     := &( "{|| " + cExp + " }" )
   end

Return ( bExp )





function GetFileNoExt( cFullFile )

   local cNameFile := AllTrim( GetFileName( cFullFile ) )
   local n         := AT( ".", cNameFile )

return AllTrim( if( n > 0, left( cNameFile, n - 1 ), cNameFile ) )





function GetFileName( cFullFile )

   local nPos  := Rat( "\", cFullFile )
   local cFile := ""

   if !empty( cFullFile )
      if nPos == 0
         nPos  := At( ":", cFullFile )
      endif
      cFile    := SubStr( cFullFile, nPos + 1 )
   endif

return( cFile )



function lChkSer( cSer, aSer )

   if Empty( cSer )
      cSer     := "A"
   end

return ( aSer[ Min( Max( Asc( cSer ) - 64, 1 ), len( aSer ) ) ] )



function RetFld( cCod, cAlias, xFld, nOrd )

   local nRec
   local nAnt
   local xRet     := ""

   if Empty( cAlias )
      return xRet
   end

   if Empty( xFld )
      xFld        := 2
   end

   if Empty( nOrd )
      nOrd        := 1
   end

   nAnt           := ( cAlias )->( OrdSetFocus( nOrd ) )
   nRec           := ( cAlias )->( Recno() )






   ( cAlias )->( dbgotop() )

   if !( cAlias )->( dbSeek( cCod ) )
       ( cAlias )->( dbGoBottom() )
       ( cAlias )->( dbSkip() )
   endif

   do case
   case ( valType( xFld ) == "N" )

      xRet        := ( cAlias )->( fieldget( xFld ) )

   case ( valType( xFld ) == "C" )

      xFld        := ( cAlias )->( fieldpos( xFld ) )
      xRet        := ( cAlias )->( fieldget( xFld ) )

   end

   ( cAlias )->( OrdSetFocus( nAnt ) )
   ( cAlias )->( dbGoTo( nRec ) )

return ( xRet )





function GetPath( cFile )

    local nPos := 0
    local cPath := ""

    if ( nPos := rat( "\", cFile ) ) <> 0
        cPath := upper( SubStr( cFile, 1, nPos ) )
    endif

return( cPath )





function GetFileExt( cFullFile )

   local cExt := AllTrim( GetFileName( cFullFile ) )
   local n    := rat( ".", cExt )
   local nLen := len( cExt )

return AllTrim( if( n > 0 .AND. nLen > n, right( cExt, nLen - n ), "" ) )





function NextVal( uVal )

   local nLen

   if ValType( uVal ) == "C"
      nLen  := Len( uVal )
      uVal  := Val( uVal )
      uVal  := AllTrim( Str( ++uVal ) )
      uVal  := Padr( uVal, nLen )
   else
      uVal++
   end

return( uVal )





function NextKey( uVal, uAlias, cChar, nLen )

   local nRec
   local nOrd

   if IsChar( ValType( uVal ) )

      if IsChar( uAlias )

         if IsNil( nLen )
            nLen  := Len( uVal )
         end

         nOrd     := ( uAlias )->( OrdSetFocus( 1 ) )
         nRec     := ( uAlias )->( OrdKeyNo() )

         ( uAlias )->( OrdKeyGoto( ( uAlias )->( OrdKeyCount() ) ) )

         if ( uAlias )->( OrdKeyVal() ) <> nil
            uVal  := ( uAlias )->( OrdKeyVal() )
         else
            uVal  := ""
         end









         while .T.

            uVal     := AllTrim( Str( Val( uVal ) + 1 ) )

            if !Empty( cChar )
               uVal  := RJust( uVal, cChar, nLen )
            end

            if ( uAlias )->( dbSeek( uVal ) )
               loop
            else
               exit
            end

         end

         ( uAlias )->( OrdSetFocus( nOrd ) )
         ( uAlias )->( OrdKeyGoTo( nRec ) )

      else

         nOrd     := uAlias:OrdSetFocus( 1 )
         nRec     := uAlias:OrdKeyNo()

         uAlias:OrdKeyGoto( uAlias:OrdKeyCount() )

         if uAlias:OrdKeyVal() <> nil
            uVal  := uAlias:OrdKeyVal()
         else
            uVal  := ""
         end

         uVal     := AllTrim( Str( Val( uVal ) + 1 ) )

         uAlias:OrdSetFocus( nOrd )
         uAlias:OrdKeyGoTo( nRec )

      end

      uVal     := Padr( uVal, nLen )

   else

      if IsChar( Valtype( uAlias ) )
         uVal  := ( uAlias )->( OrdKeyCount() ) + 1
      else
         uVal  := uAlias:OrdKeyCount() + 1
      end

   end

return ( uVal )




































function oRetFld( cCod, oDbf, xFld, nOrd )

   local nRec
   local nAnt
   local xRet     := ""

   if Empty( oDbf )
      return xRet
   end

   if xFld == nil
      xFld        := 2
   end

   nRec           := oDbf:Recno()

   if nOrd <> nil
      nAnt        := oDbf:OrdSetFocus( nOrd )
   end






   if !oDbf:Seek( cCod )
       oDbf:GoBottom()
       oDbf:Skip()
   end

   if ( valType( xFld ) == "N" )

       xRet  := oDbf:FieldGet( xFld )

   elseif ( valType( xFld ) == "C" )

       xFld  := oDbf:FieldPos( xFld )
       xRet  := oDbf:FieldGet( xFld )

   end

   oDbf:GoTo( nRec )

   if nAnt <> nil
      oDbf:OrdSetFocus( nAnt )
   end

return ( xRet )



function cGetFilename( cExt, cText, oGet )

   local cPathFile

   IIF( cExt == nil, cExt := "Doc ( *.* ) | *.*", ) ;
   IIF( cText == nil, cText := "Seleccione el nombre del fichero", ) ;

   cPathFile         := cGetFile( cExt, cText )

   if !Empty( cPathFile ) .AND. !Empty( oGet )
      oGet:cText( Padr( cPathFile, len( oGet:VarGet() ) )  )
   end

return ( cPathFile )
