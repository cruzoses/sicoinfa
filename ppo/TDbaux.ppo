#line 112 "\xHarbour\Include\HBClass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 5 ".\Prg\TDbaux.prg"
_HB_CLASS TDbAux ; UTILITY FUNCTION TDbAux(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TDbAux" , { HBObject():Classh } ) ) ;

   _HB_MEMBER {AS ARRAY aBuffer} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY",, nScope + IIF( .F., 32, 0 ), { "aBuffer" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aFldNames} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY",, nScope + IIF( .F., 32, 0 ), { "aFldNames" }, .F., .F. ), )

   _HB_MEMBER New( oDbf) AS CLASS TDbAux; IIF( .F., s_oClass:ModMethod( "New", @TDbAux_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TDbAux_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER FieldGet(nPos); IIF( .F., s_oClass:ModInline( "FieldGet", {|Self,nPos | Self, ::aBuffer[ nPos ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "FieldGet", {|Self,nPos | Self, ::aBuffer[ nPos ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER FieldPut(nPos, uValue); IIF( .F., s_oClass:ModInline( "FieldPut", {|Self,nPos, uValue | Self, ::aBuffer[ nPos ] := uValue }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "FieldPut", {|Self,nPos, uValue | Self, ::aBuffer[ nPos ] := uValue }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER FieldPos( cMsg); IIF( .F., s_oClass:ModMethod( "FieldPos", @TDbAux_FieldPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FieldPos", @TDbAux_FieldPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER OnError(cMsg, nError); s_oClass:SetOnError( @TDbAux_OnError() ) ;

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TDbAux ;



UTILITY STATIC function TDbAux_New( oDbf) ; local Self AS CLASS TDbAux := QSelf() AS CLASS TDbAux

   local i
   local nLen  := oDbf:FCount()

   ::aFldNames := {}
   ::aBuffer   := Array( nLen )

   for i := 1 to nLen
      AAdd( ::aFldNames, oDbf:FieldName( i ) )
   next

return( Self )



UTILITY STATIC function TDbAux_FieldPos( cMsg) ; local Self AS CLASS TDbAux := QSelf() AS CLASS TDbAux

return ( AScan( ::aFldNames, { | cField | cMsg == RTrim( SubStr( cField, 1, 9 ) ) } ) )



UTILITY STATIC function TDbAux_OnError(cMsg, nError) ; local Self AS CLASS TDbAux := QSelf() AS CLASS TDbAux

   local nField

   if SubStr( cMsg, 1, 1 ) == "_"
      if( ( nField := ::FieldPos( SubStr( cMsg, 2 ) ) ) <> 0 )
         ::FieldPut( nField, GetParam( 1, 1 ) )
      else
         _ClsSetError( _GenError( nError, ::ClassName(), SubStr( cMsg, 2 ) ) )
      endif
   else
      if( ( nField := ::FieldPos( cMsg ) ) <> 0 )
         return ::FieldGet( nField )
      else
         _ClsSetError( _GenError( nError, ::ClassName(), cMsg ) )
      endif
   endif

return nil
