#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 14 ".\Prg\Tgethlp.prg"
_HB_CLASS TGetHlp ; UTILITY FUNCTION TGetHlp(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TGetHlp" , {TGet():classh} ) ) ; ;

   _HB_MEMBER { bHelp} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bHelp" }, .F., .F. ), )
   _HB_MEMBER { bMult} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bMult" }, .F., .F. ), )
   _HB_MEMBER { cBmp} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cBmp" }, .F., .F. ), )
   _HB_MEMBER { oBmp} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBmp" }, .F., .F. ), )
   _HB_MEMBER { oSay} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oSay" }, .F., .F. ), )
   _HB_MEMBER { oHelpText} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oHelpText" }, .F., .F. ), )
   _HB_MEMBER { cHelpText} ; IIF( !.F., s_oClass:AddMultiData(, Space( 50 ), nScope + IIF( .F., 32, 0 ), { "cHelpText" }, .F., .F. ), )

   _HB_MEMBER { lGotFocus} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lGotFocus" }, .F., .F. ), )
   _HB_MEMBER { lNeedGetFocus} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lNeedGetFocus" }, .F., .F. ), )

   _HB_MEMBER { bOldWhen} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOldWhen" }, .F., .F. ), )
   _HB_MEMBER { bOldValid} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOldValid" }, .F., .F. ), )
   _HB_MEMBER { bOldLostFocus} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOldLostFocus" }, .F., .F. ), )

   _HB_MEMBER { nMargin} ; IIF( !.F., s_oClass:AddMultiData(, 16, nScope + IIF( .F., 32, 0 ), { "nMargin" }, .F., .F. ), )

   _HB_MEMBER New() AS CLASS TGetHlp; IIF( .F., s_oClass:ModMethod( "New", @TGetHlp_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TGetHlp_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ReDefine() AS CLASS TGetHlp; IIF( .F., s_oClass:ModMethod( "ReDefine", @TGetHlp_ReDefine(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReDefine", @TGetHlp_ReDefine(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Display(); IIF( .F., s_oClass:ModMethod( "Display", @TGetHlp_Display(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Display", @TGetHlp_Display(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Destroy(); IIF( .F., s_oClass:ModMethod( "Destroy", @TGetHlp_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Destroy", @TGetHlp_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER EvalHelp(); IIF( .F., s_oClass:ModMethod( "EvalHelp", @TGetHlp_EvalHelp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "EvalHelp", @TGetHlp_EvalHelp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER KeyChar( nKey, nFlags); IIF( .F., s_oClass:ModMethod( "KeyChar", @TGetHlp_KeyChar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "KeyChar", @TGetHlp_KeyChar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetPicture(cPicture); IIF( .F., s_oClass:ModInline( "SetPicture", {|Self,cPicture | Self, ( ::cPicture  := cPicture, ::oGet:Picture := cPicture, ::Refresh()  ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetPicture", {|Self,cPicture | Self, ( ::cPicture  := cPicture, ::oGet:Picture := cPicture, ::Refresh()  ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Home(); IIF( .F., s_oClass:ModInline( "Home", {|Self | Self, ( ::oGet:Home(), ::SetPos( ::oGet:Pos ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Home", {|Self | Self, ( ::oGet:Home(), ::SetPos( ::oGet:Pos ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER EvalMult(); IIF( .F., s_oClass:ModInline( "EvalMult", {|Self | Self, ( if( ::bMult <> nil, Eval( ::bMult, Self ), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "EvalMult", {|Self | Self, ( if( ::bMult <> nil, Eval( ::bMult, Self ), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Hide(); IIF( .F., s_oClass:ModInline( "Hide", {|Self | Self, ( if( ::oSay <> nil, ::oSay:Hide(), ), if( ::oHelpText <> nil, ::oHelpText:Hide(), ), ::TGet:Hide() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Hide", {|Self | Self, ( if( ::oSay <> nil, ::oSay:Hide(), ), if( ::oHelpText <> nil, ::oHelpText:Hide(), ), ::TGet:Hide() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Show(); IIF( .F., s_oClass:ModInline( "Show", {|Self | Self, ( if( ::oSay <> nil, ::oSay:Show(), ), if( ::oHelpText <> nil, ::oHelpText:Show(), ), ::TGet:Show() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Show", {|Self | Self, ( if( ::oSay <> nil, ::oSay:Show(), ), if( ::oHelpText <> nil, ::oHelpText:Show(), ), ::TGet:Show() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetText(cText); IIF( .F., s_oClass:ModInline( "SetText", {|Self,cText | Self, ( if( ::oSay <> nil, ::oSay:SetText( cText ), ::cText( cText ) ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetText", {|Self,cText | Self, ( if( ::oSay <> nil, ::oSay:SetText( cText ), ::cText( cText ) ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER HardEnable(); IIF( .F., s_oClass:ModMethod( "HardEnable", @TGetHlp_HardEnable(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HardEnable", @TGetHlp_HardEnable(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER HardDisable(); IIF( .F., s_oClass:ModMethod( "HardDisable", @TGetHlp_HardDisable(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HardDisable", @TGetHlp_HardDisable(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GotFocus(); IIF( .F., s_oClass:ModMethod( "GotFocus", @TGetHlp_GotFocus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GotFocus", @TGetHlp_GotFocus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GetDlgCode( nLastKey); IIF( .F., s_oClass:ModMethod( "GetDlgCode", @TGetHlp_GetDlgCode(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetDlgCode", @TGetHlp_GetDlgCode(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER LostFocus( hCtlFocus); IIF( .F., s_oClass:ModMethod( "LostFocus", @TGetHlp_LostFocus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LostFocus", @TGetHlp_LostFocus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER lOldValid(); IIF( .F., s_oClass:ModMethod( "lOldValid", @TGetHlp_lOldValid(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lOldValid", @TGetHlp_lOldValid(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TGetHlp ;







UTILITY STATIC function TGetHlp_New( nRow, nCol, bSetGet, oWnd, nWidth, nHeight, cPict, bValid, nClrFore, nClrBack, oFont, lDesign, oCursor, lPixel, cMsg, lUpdate, bWhen, lCenter, lRight, bChanged, lReadOnly, lPassword, lNoBorder, nHelpId, lSpinner, bUp, bDown, bMin, bMax, bHelp, bMult, cBmp) ; local Self AS CLASS TGetHlp := QSelf() AS CLASS TGetHlp

   IIF( cBmp == nil, cBmp := "", ) ;





   ::TGet:New(  nRow, nCol, bSetGet, oWnd, nWidth, nHeight, cPict, bValid, nClrFore, nClrBack, oFont, lDesign, oCursor, lPixel, cMsg, lUpdate, bWhen, lCenter, lRight, bChanged, lReadOnly, lPassword, lNoBorder, nHelpId, lSpinner, bUp, bDown, bMin, bMax )

   ::bHelp           := bHelp
   ::bMult           := bMult
   ::cBmp            := cBmp

   ::lNeedGetFocus   := .F.
   ::lGotFocus       := .F.

return Self






UTILITY STATIC function TGetHlp_ReDefine( nId, bSetGet, oWnd, nHelpId, cPict, bValid, nClrFore, nClrBack, oFont, oCursor, cMsg, lUpdate, bWhen, bChanged, lReadOnly, lSpinner, bUp, bDown, bMin, bMax, bHelp, bMult, cBmp, nIdSay, nIdText) ; local Self AS CLASS TGetHlp := QSelf() AS CLASS TGetHlp

   IIF( cBmp == nil, cBmp := "", ) ;
   IIF( nIdSay == nil, nIdSay := 0, ) ;



   ::TGet:ReDefine(   nId, bSetGet, oWnd, nHelpId, cPict, bValid, nClrFore, nClrBack, oFont, oCursor, cMsg, lUpdate, bWhen, bChanged, lReadOnly, lSpinner, bUp, bDown, bMin, bMax )

   ::bHelp           := bHelp
   ::bMult           := bMult
   ::cBmp            := cBmp

   ::lNeedGetFocus   := .F.
   ::lGotFocus       := .F.

   if !Empty( nIdSay )
      ::oSay         := TSay():ReDefine( nIdSay, nil, oWnd )
   end

   if !Empty( nIdText )
      ::oHelpText    := TGet():ReDefine( nIdText, { | u | If( PCount() == 0, ::cHelpText, ::cHelpText := u ) }, oWnd,,,,,,,,, .F., {||.F.} )
   end

Return Self



UTILITY STATIC function TGetHlp_Display() ; local Self AS CLASS TGetHlp := QSelf() AS CLASS TGetHlp

   if !Empty( ::cBmp ) .AND. Empty( ::oBmp )

      ::oBmp               := TBitmap():New( 0, Self:nWidth - ( ::nMargin + 4 ),,, ::cBmp, ,.T., Self, {|| ::EvalHelp()},,,,,,,,.T. )
      ::oBmp:lTransparent  := .T.

      SendMessage( ::hWnd, 211, nOr( 1, 2 ), nMakeLong( 0, ::nMargin ) )

   end

Return ::TGet:display()



UTILITY STATIC function TGetHlp_Destroy() ; local Self AS CLASS TGetHlp := QSelf() AS CLASS TGetHlp

   if ::oBmp <> nil
      ::oBmp:End()
   end

   if ::oSay <> nil
      ::oSay:End()
   end

   if ::oHelpText <> nil
      ::oHelpText:End()
   end

Return ( ::TGet:Destroy() )



UTILITY STATIC function TGetHlp_KeyChar( nKey, nFlags) ; local Self AS CLASS TGetHlp := QSelf() AS CLASS TGetHlp

   local nHi, nLo
   local lAccept
   local bKeyAction := SetKey( nKey )

   if nKey == 27
      ::oWnd:KeyChar( nKey, nFlags )
      return 1
   endif

   if ! Empty( ::cPicture ) .AND. "@!" $ ::cPicture
      nKey = Asc( Upper( Chr( nKey ) ) )
   endif

   if bKeyAction <> nil .AND. lAnd( nFlags, 16777216 )
      Eval( bKeyAction, ProcName( 4 ), ProcLine( 4 ), Self )
      return 0
   endif

   if ::lReadOnly
      if nKey == 27
         ::oWnd:End()
      endif
      return 0
   endif

   do case
      case nKey == 43 .AND. ::bHelp <> nil
         ::EvalHelp()

      case nKey == 42 .AND. ::bMult <> nil
         ::EvalMult()

      case nKey == 8
           return 0

      case nKey == 9 .AND. GetKeyState( 16 )
           if ::bChange <> nil
              lAccept = Eval( ::bChange, nKey, nFlags, Self )
              if ValType( lAccept ) == "L" .AND. lAccept
                 if Upper( ::oWnd:ClassName() ) == "TCOMBOBOX"
                    ::oWnd:oWnd:GoPrevCtrl( ::hWnd )
                 else
                    ::oWnd:GoPrevCtrl( ::hWnd )
                 endif
              endif
           else
              if Upper( ::oWnd:ClassName() ) == "TCOMBOBOX"
                 ::oWnd:oWnd:GoPrevCtrl( ::hWnd )
              else
                 ::oWnd:GoPrevCtrl( ::hWnd )
              endif
           endif
           return 0

      case nKey == 9 .OR. nKey == 13
           if ::bChange <> nil .AND. ( ::oGet:Changed .OR. ( ::oGet:buffer <> nil .AND. ::oGet:UnTransform() <> ::oGet:Original ) )
              lAccept = Eval( ::bChange, nKey, nFlags, Self )
              if ValType( lAccept ) == "L" .AND. lAccept
                 ::oWnd:GoNextCtrl( ::hWnd )
              endif
           else
              ::oWnd:GoNextCtrl( ::hWnd )
           endif


               if nKey == 13
                  ::TGet:KeyChar( nKey, nFlags )
               endif


           return 0

      case nKey >= 32 .AND. nKey < 256



              if ::oGet:buffer == nil
                 return 0
              endif


           ::GetSelPos( @nLo, @nHi )



           if nHi <> nLo
              ::GetDelSel( nLo, nHi )
              ::EditUpdate()
           endif


           if ::oGet:Type == "N" .AND.  ( Chr( nKey ) == "." .OR. Chr( nKey ) == "," )
              ::oGet:ToDecPos()
           else
              if Set( 29 )
                 ::oGet:Insert( Chr( nKey ) )
              else
                 ::oGet:Overstrike( Chr( nKey ) )
              end
           endif

           if ::oGet:Rejected
              if Set( 26 )
                 MsgBeep()
              endif
           endif

           ::EditUpdate()

           if ::oGet:TypeOut
              if ! Set( 27 )
                 ::oWnd:nLastKey = 13
                 ::oWnd:GoNextCtrl( ::hWnd )
              else
                 if Set( 26 )
                    MsgBeep()
                 endif
              endif
           endif

           ::oGet:Assign()

           if ::bChange <> nil
              lAccept = Eval( ::bChange, nKey, nFlags, Self )
              if ValType( lAccept ) == "L" .AND. ! lAccept
                 return 0
              endif
           endif


           Eval( ::bPostKey, Self, ::oGet:Buffer )


      otherwise
           return ::TGet:KeyChar( nKey, nFlags )

   endcase

return ( 0 )



UTILITY STATIC function TGetHlp_EvalHelp() ; local Self AS CLASS TGetHlp := QSelf() AS CLASS TGetHlp

   if ValType( ::bLostFocus ) == "B"
      ::bOldLostFocus   := ::bLostFocus
      ::bLostFocus      := nil
   endif

   if ValType( ::bValid ) == "B"
      ::bOldValid       := ::bValid
      ::bValid          := nil
   endif

   if ValType( ::bHelp ) == "B"
      Eval( ::bHelp, Self )
   end

   if ValType( ::bOldLostFocus ) == "B"
      ::bLostFocus      := ::bOldLostFocus
      ::bOldLostFocus   := nil
   endif

   if ValType( ::bOldValid ) == "B"
      ::bValid          := ::bOldValid
      ::bOldValid       := nil
   endif

   if ValType( ::bLostFocus ) == "B"
      Eval( ::bLostFocus )
   endif

   if ValType( ::bValid ) == "B"
      Eval( ::bValid )
   endif

RETURN Self



UTILITY STATIC function TGetHlp_HardEnable() ; local Self AS CLASS TGetHlp := QSelf() AS CLASS TGetHlp

   ::bWhen     := ::bOldWhen

Return ( ::Enable() )



UTILITY STATIC function TGetHlp_HardDisable() ; local Self AS CLASS TGetHlp := QSelf() AS CLASS TGetHlp

   ::bOldWhen  := ::bWhen
   ::bWhen     := {|| .F. }

return ( ::Disable() )



UTILITY STATIC function TGetHlp_GotFocus() ; local Self AS CLASS TGetHlp := QSelf() AS CLASS TGetHlp

    ::lFocused = .T.


       ::oGet:VarGet()


    if ! Empty( ::cPicture ) .AND. ::oGet:type == "N"
       ::oGet:Picture := StrTran( ::cPicture, ",", "" )
    endif

    if ! ::lDrag
       ::oGet:KillFocus()
       ::oGet:SetFocus()
       if Upper( ::oWnd:ClassName() ) == "TCOMBOBOX"
          ::oGet:Buffer := ::oGet:Original
       endif
       ::DispText()
       if ::oGet:type $ "DN"
          ::nPos := 1
       endif
       ::oGet:Pos := ::nPos
       ::SetPos( ::nPos )
       CallWindowProc( ::nOldProc, ::hWnd, 7 )
       if Set( 29 )
          DestroyCaret()
          CreateCaret( ::hWnd, 0, 6, ::nGetChrHeight() )
          ShowCaret( ::hWnd )
       endif
    else
       HideCaret( ::hWnd )
    endif





   if ::oGet:type == "C"
      ::SetSel( 0, Len( Rtrim( ::oGet:VarGet() ) ) )
   else
      ::SelectAll()
   end



return 0



UTILITY STATIC function TGetHlp_GetDlgCode( nLastKey) ; local Self AS CLASS TGetHlp := QSelf() AS CLASS TGetHlp

   if Len( ::oWnd:aControls ) == 1
      return 4
   endif

   ::oWnd:nLastKey = nLastKey

return 4



UTILITY STATIC function TGetHlp_LostFocus( hCtlFocus) ; local Self AS CLASS TGetHlp := QSelf() AS CLASS TGetHlp

   ::TGet:LostFocus( hCtlFocus )

   if !::lPassword
      if ::oGet:buffer <> GetWindowText( ::hWnd )
         ::oGet:buffer  := GetWindowText( ::hWnd )
         ::oGet:Assign()
      endif
   endif

   if !Empty( ::cPicture ) .AND. ::oGet:type == "N"
      ::oGet:Assign()
      ::oGet:Picture    := ::cPicture
      ::oGet:UpdateBuffer()
      ::oGet:KillFocus()
   endif

   ::oGet:SetFocus()

   if !::oGet:BadDate .AND. !::lReadOnly .AND. ( ::oGet:changed .OR. ::oGet:unTransform() <> ::oGet:original )
      ::oGet:Assign()
      ::oGet:UpdateBuffer()
   endif

   ::DispText()

   if !::oGet:BadDate
      ::oGet:KillFocus()
   else
      ::oGet:Pos        := 1
      ::nPos            := 1

      ::oGet:TypeOut    := .F.

   endif

   if ::lNeedGetFocus
      ::lGotFocus       := .T.
   end

return nil



UTILITY STATIC function TGetHlp_lOldValid() ; local Self AS CLASS TGetHlp := QSelf() AS CLASS TGetHlp

   local lRet := .T.

   if ::oGet:BadDate
      ::oGet:KillFocus()
      ::oGet:SetFocus()
      MsgBeep()
      return .F.
   else
      ::oGet:Assign()
      if ValType( ::bOldValid ) == "B"
         lRet := Eval( ::bOldValid, Self  )
         if !lRet
            ::oWnd:nLastKey = 0
         endif
      endif
   endif

return lRet
