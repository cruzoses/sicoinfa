#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 10 ".\Prg\IXbrowse.prg"
_HB_CLASS IXBrowse ; UTILITY FUNCTION IXBrowse(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "IXBrowse" , {TXBrowse():classh} ) ) ; ;

   _HB_MEMBER { dbfUsr} ; IIF( !.F., s_oClass:AddMultiClsData(,, nScope + IIF( .F., 32, 0 ) + 64, { "dbfUsr" }, .F. ), )
   _HB_MEMBER {AS LOGIC lOpenData} ; IIF( !.F., s_oClass:AddMultiClsData("LOGIC", .F., nScope + IIF( .F., 32, 0 ) + 64, { "lOpenData" }, .F. ), )

   _HB_MEMBER {AS CHARACTER cOriginal} ; IIF( !.F., s_oClass:AddMultiData( "CHARACTER", "", nScope + IIF( .F., 32, 0 ), { "cOriginal" }, .F., .F. ), )
   _HB_MEMBER {AS CHARACTER cName} ; IIF( !.F., s_oClass:AddMultiData( "CHARACTER", "", nScope + IIF( .F., 32, 0 ), { "cName" }, .F., .F. ), )

   _HB_MEMBER { bToolTip} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bToolTip" }, .F., .F. ), )
   _HB_MEMBER { oToolTip} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oToolTip" }, .F., .F. ), )
   _HB_MEMBER { oTimer} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oTimer" }, .F., .F. ), )

   _HB_MEMBER {AS LOGIC lOnProcess} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .F., nScope + IIF( .F., 32, 0 ), { "lOnProcess" }, .F., .F. ), )

   _HB_MEMBER {AS NUMERIC nToolTip} ; IIF( !.F., s_oClass:AddMultiClsData("NUMERIC", 900, nScope + IIF( .F., 32, 0 ) + 64, { "nToolTip" }, .F. ), )

   _HB_MEMBER GetOriginal(); IIF( .F., s_oClass:ModInline( "GetOriginal", {|Self | Self, ( ::cOriginal := ::SaveState() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetOriginal", {|Self | Self, ( ::cOriginal := ::SaveState() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER SetOriginal(); IIF( .F., s_oClass:ModInline( "SetOriginal", {|Self | Self, ( ::RestoreState( ::cOriginal ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetOriginal", {|Self | Self, ( ::RestoreState( ::cOriginal ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Load(); IIF( .F., s_oClass:ModInline( "Load", {|Self | Self, ( ::OpenData(), ::LoadData(), ::CloseData(), ::Refresh() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Load", {|Self | Self, ( ::OpenData(), ::LoadData(), ::CloseData(), ::Refresh() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER Save(); IIF( .F., s_oClass:ModInline( "Save", {|Self | Self, ( ::OpenData(), ::SaveData( .T.), ::CloseData() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Save", {|Self | Self, ( ::OpenData(), ::SaveData( .T.), ::CloseData() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER CreateData( cPath); IIF( .F., s_oClass:ModMethod( "CreateData", @IXBrowse_CreateData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateData", @IXBrowse_CreateData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ReindexData( cPath); IIF( .F., s_oClass:ModMethod( "ReindexData", @IXBrowse_ReindexData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReindexData", @IXBrowse_ReindexData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER LoadData(); IIF( .F., s_oClass:ModMethod( "LoadData", @IXBrowse_LoadData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LoadData", @IXBrowse_LoadData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SaveData( lSaveBrowseState); IIF( .F., s_oClass:ModMethod( "SaveData", @IXBrowse_SaveData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SaveData", @IXBrowse_SaveData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CleanData(); IIF( .F., s_oClass:ModMethod( "CleanData", @IXBrowse_CleanData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CleanData", @IXBrowse_CleanData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DeleteData(); IIF( .F., s_oClass:ModMethod( "DeleteData", @IXBrowse_DeleteData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DeleteData", @IXBrowse_DeleteData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CloseData(); IIF( .F., s_oClass:ModMethod( "CloseData", @IXBrowse_CloseData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CloseData", @IXBrowse_CloseData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER OpenData( cPath); IIF( .F., s_oClass:ModMethod( "OpenData", @IXBrowse_OpenData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "OpenData", @IXBrowse_OpenData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER RButtonDown( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "RButtonDown", @IXBrowse_RButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RButtonDown", @IXBrowse_RButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CheckExtendInfo(); IIF( .F., s_oClass:ModMethod( "CheckExtendInfo", @IXBrowse_CheckExtendInfo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CheckExtendInfo", @IXBrowse_CheckExtendInfo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ShowExtendInfo(); IIF( .F., s_oClass:ModMethod( "ShowExtendInfo", @IXBrowse_ShowExtendInfo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ShowExtendInfo", @IXBrowse_ShowExtendInfo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetRDD( lAddColumns, lAutoOrder, aFldNames); IIF( .F., s_oClass:ModMethod( "SetRDD", @IXBrowse_SetRDD(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetRDD", @IXBrowse_SetRDD(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));




; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS IXBrowse ;



UTILITY STATIC function IXBrowse_CreateData( cPath) ; local Self AS CLASS IXBrowse := QSelf() AS CLASS IXBrowse

   IIF( cPath == nil, cPath := cPatEmp(), ) ;

   if !lExistTable( cPath + "CfgUse.Dbf" )
      dbCreate( cPath + "CfgUse.Dbf", aSqlStruct( aItmHea() ), cDriver() )
   end

   Return ( Self )



UTILITY STATIC function IXBrowse_ReindexData( cPath) ; local Self AS CLASS IXBrowse := QSelf() AS CLASS IXBrowse

   local dbfUse

   IIF( cPath == nil, cPath := cPatEmp(), ) ;

   if !lExistTable( cPath + "CfgUse.Dbf" )
      ::CreateData( cPath )
   end

   dbUseArea( .T., cDriver(), cPath + "CfgUse.Dbf", cCheckArea( "CfgUse", @dbfUse ), .F. )

   if !( dbfUse )->( neterr() )

      ( dbfUse )->( __dbPack() )

      ( dbfUse )->( ordCondSet( "!Deleted()", {|| !Deleted() }  ) )
      ( dbfUse )->( ordCreate( cPath + "CfgUse.Cdx", "cCodUse", "cCodUse + cNomCfg", {|| Field->cCodUse + Field->cNomCfg } ) )

      ( dbfUse )->( dbCloseArea() )

   else

      msgStop( "Imposible abrir en modo exclusivo la tabla de ventanas" )

   end

   Return ( self )



UTILITY STATIC function IXBrowse_LoadData() ; local Self AS CLASS IXBrowse := QSelf() AS CLASS IXBrowse

   local oBlock
   local oError

   ::bClrSel            := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
   ::bClrSelFocus       := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

   oBlock               := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      ::cOriginal       := ::SaveState()

      if !Empty( ::dbfUsr ) .AND. ( ::dbfUsr )->( Used() )

         if ( ::dbfUsr )->( dbSeek( cCurUsr() + ::cName ) )

            if !Empty( ( ::dbfUsr )->cBrwCfg )
               ::RestoreState( ( ::dbfUsr )->cBrwCfg )
            end

         end

      end

   RECOVER USING oError

      msgStop( "Error al establecer la configuración de columnas." + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

Return ( Self )



UTILITY STATIC function IXBrowse_SaveData( lSaveBrowseState) ; local Self AS CLASS IXBrowse := QSelf() AS CLASS IXBrowse

   local oError
   local oBlock

   IIF( lSaveBrowseState == nil, lSaveBrowseState := .T., ) ;

   oBlock                        := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE



   if !Empty( ::dbfUsr ) .AND. ( ::dbfUsr )->( Used() )

      if ( ::dbfUsr )->( dbSeek( cCurUsr() + ::cName ) )

         if ( ::dbfUsr )->( dbRLock() )
            ( ::dbfUsr )->cBrwCfg   := ::SaveState()
            ( ::dbfUsr )->( dbRUnLock() )
         end

      else

         ( ::dbfUsr )->( dbAppend() )
         if !( ::dbfUsr )->( neterr() )
            ( ::dbfUsr )->cCodUse   := cCurUsr()
            ( ::dbfUsr )->cNomCfg   := ::cName
            ( ::dbfUsr )->cBrwCfg   := ::SaveState()
         end
         ( ::dbfUsr )->( dbRUnLock() )

      end

      if lSaveBrowseState
         msgInfo( "Configuración de columnas guardada.", ::cName )
      end

   end

   RECOVER USING oError

      msgStop( "Imposible salvar las configuraciones de columnas" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   Return ( Self )



UTILITY STATIC function IXBrowse_CleanData() ; local Self AS CLASS IXBrowse := QSelf() AS CLASS IXBrowse



   if !Empty( ::dbfUsr ) .AND. ( ::dbfUsr )->( Used() )
      while ( ::dbfUsr )->( dbSeek( cCurUsr() + ::cName ) )
         dbDel( ::dbfUsr )
      end
   end

   Return ( Self )



UTILITY STATIC function IXBrowse_DeleteData() ; local Self AS CLASS IXBrowse := QSelf() AS CLASS IXBrowse

   fErase( cPatEmp() + "CfgUse.Dbf" )
   fErase( cPatEmp() + "CfgUse.Cdx" )

   Return ( Self )



UTILITY STATIC function IXBrowse_CloseData() ; local Self AS CLASS IXBrowse := QSelf() AS CLASS IXBrowse

   if !Empty( ::dbfUsr ) .AND. ( ::dbfUsr )->( Used() )
      ( ::dbfUsr )->( dbCloseArea() )
   end

   ::lOpenData          := .F.

Return ( Self )



UTILITY STATIC function IXBrowse_OpenData( cPath) ; local Self AS CLASS IXBrowse := QSelf() AS CLASS IXBrowse

   local oBlock
   local oError

   IIF( cPath == nil, cPath := cPatEmp(), ) ;

   if !lExistTable( cPath + "CfgUse.Dbf" )
      ::CreateData( cPath )
   end

   if !lExistIndex( cPath + "CfgUse.Cdx" )
      ::ReindexData( cPath )
   end

   oBlock               := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      if !::lOpenData

         dbUseArea( .T., cDriver(), ( cPath + "CfgUse.Dbf" ), ( ::dbfUsr := cCheckArea( "CfgUse" ) ), .T. )
         IIF( !lAIS(), ( ::dbfUsr )->( OrdListAdd( cPath + "CfgUse.Cdx" ) ), ( ::dbfUsr )->( OrdSetFocus( 1 ) ) )

         ::lOpenData    := .T.

      end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   Return ( Self )



UTILITY STATIC function IXBrowse_RButtonDown( nRow, nCol, nFlags) ; local Self AS CLASS IXBrowse := QSelf() AS CLASS IXBrowse

   local oCol
   local oMenu
   local bMenuSelect





   oMenu             := MenuBegin( .T. )
   bMenuSelect       := ::bMenuSelect

   ::bMenuSelect     := nil

   MenuAddItem( "Columnas", "Columnas de la rejilla de datos", .F., .T., , , "Column_16", oMenu )

   MenuBegin( .F.,,, .F. )

   for each oCol in ::aCols
      MenuAddItem( oCol:cHeader, , !oCol:lHide, ( Len( ::aDisplay ) <> 1 .OR. oCol:nPos <> 1 ), GenMenuBlock( oCol ) )
   next

   MenuEnd()

   if !Empty( ::cName )

      MenuAddItem( "Guardar vista actual", "Guarda la vista actual de la rejilla de datos", .F., .T., {|| ::Save() }, , "Column_Disk_16", oMenu )

      MenuAddItem( "Cargar vista por defecto", "Carga la vista por defecto de la rejilla de datos", .F., .T., {|| ::SetOriginal() }, , "Column_Refresh_16", oMenu )

   end

   MenuAddItem( "Seleccionar &todo", "Selecciona todas las filas de la rejilla", .F., .T., {|| ::SelectAll() }, , "Table_Selection_All_16", oMenu )

   MenuAddItem( "&Quitar selección", "Quita la selección de todas las filas de la rejilla", .F., .T., {|| ::SelectNone() }, , "Table_Sql_16", oMenu )

   MenuAddItem()

   MenuAddItem( "Exportar a E&xcel", "Exportar rejilla de datos a Excel", .F., .T., {|| ::ToExcel() }, , "Text_Sum_16", oMenu )

   MenuEnd()

   oMenu:Activate( nRow, nCol, Self )

   ::bMenuSelect     := bMenuSelect

   oMenu:end()

   ::SetFocus()

Return ( Self )



static function GenMenuBlock( oCol )

return {|| iif( oCol:lHide, oCol:Show(), oCol:Hide() ) }



UTILITY STATIC function IXBrowse_CheckExtendInfo() ; local Self AS CLASS IXBrowse := QSelf() AS CLASS IXBrowse

   if Empty( ::bToolTip )
      Return ( Self )
   endif

   if !Empty( ::oToolTip )
      ::oToolTip:End()
      ::oToolTip  := nil
   endif

   if !Empty( ::oTimer )
      ::oTimer:End()
      ::oTimer    := nil
   endif

   if !::lOnProcess
      ::oTimer             := TTimer():New( ::nToolTip, {|| ::ShowExtendInfo(), if( ::oTimer <> nil, ::oTimer:End(), nil ), ::oTimer := nil }, )
      ::oTimer:hWndOwner   := GetActiveWindow()
      ::oTimer:Activate()
   end





   if !Empty( ::oToolTip )
      ::oToolTip:End()
   end

Return ( Self )



UTILITY STATIC function IXBrowse_ShowExtendInfo() ; local Self AS CLASS IXBrowse := QSelf() AS CLASS IXBrowse

   local nRow
   local oBlock

   ::lOnProcess      := .T.

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if ::oToolTip == nil

      ::oToolTip     := CheckEval( ::bToolTip )

      if Valtype( ::oToolTip ) == "O"

         nRow           := ( ::nRowSel * ::DataHeight ) + ::HeaderHeight()

         if ( nRow + ::oToolTip:nHeight() ) >= ( ::BrwHeight() - 100 )
            nRow     -= ( ::oToolTip:nHeight() + ::DataHeight + 108 )
         else
            nRow     += 4
         end

         ::oToolTip:Activate( , , , .F., , .F., {|o| o:Move( nRow, ( ::BrwWidth() - ::oToolTip:nWidth() - 4 ), ::oToolTip:nWidth(), ::oToolTip:nHeight() ) } )

         ::SetFocus()

         if !Empty( ::oTimer )
            ::oTimer:End()
            ::oTimer := nil
         endif

      end

   end

   end

   ErrorBlock( oBlock )

   ::lOnProcess      := .F.

return nil













































































UTILITY STATIC function IXBrowse_SetRDD( lAddColumns, lAutoOrder, aFldNames) ; local Self AS CLASS IXBrowse := QSelf() AS CLASS IXBrowse

   local oCol, aStruct
   local cAlias
   local nFields, nFor
   local bOnSkip

   if Empty( ::cAlias )
      ::cAlias                   := Alias()
      if Empty( ::cAlias )
         return nil
      endif
   endif

   cAlias                      := ::cAlias
   ::nDataType                 := 1

   IIF( lAddColumns == nil, lAddColumns := .F., ) ;
   IIF( lAutoOrder == nil, lAutoOrder := ::lAutoSort, ) ;







   IIF( ::bGoTop == nil, ::bGoTop := {|| if( ( cAlias )->( Used() ), ( cAlias )->( DbGoTop() ), ) }, ) ; IIF( ::bGoBottom == nil, ::bGoBottom := {|| if( ( cAlias )->( Used() ), ( cAlias )->( DbGoBottom() ), ) }, ); IIF( ::bSkip == nil, ::bSkip := {| n | iif( n == nil, n := 1, ), if( ( cAlias )->( Used() ), ( cAlias )->( DbSkipper( n ) ), 0 ) }, ); IIF( ::bBof == nil, ::bBof := {|| if( ( cAlias )->( Used() ), ( cAlias )->( Bof() ), .T. ) }, ); IIF( ::bEof == nil, ::bEof := {|| if( ( cAlias )->( Used() ), ( cAlias )->( Eof() ), .T. ) }, ); IIF( ::bBookMark == nil, ::bBookMark := {| n | iif( n == nil, if( ( cAlias )->( Used() ), ( cAlias )->( RecNo() ), 0 ), if( ( cAlias )->( Used() ), ( cAlias )->( DbGoto( n ) ), 0 ) ) }, ); IIF( ::bKeyNo == nil, ::bKeyNo := {| n | iif( n == nil, if( ( cAlias )->( Used() ), ( cAlias )->( OrdKeyNo() ), 0 ), if( ( cAlias )->( Used() ), ( cAlias )->( OrdKeyGoto( n ) ), 0 ) ) }, ); IIF( ::bKeyCount == nil, ::bKeyCount := {|| if( ( cAlias )->( Used() ), ( cAlias )->( OrdKeyCount() ), 0 ) }, );
            ::bLock            := {|| if( ( cAlias )->( Used() ), ( cAlias )->( DbrLock() ), .F. ) }
            ::bUnlock          := {|| if( ( cAlias )->( Used() ), ( cAlias )->( DbrUnlock() ), .F. ) }

   if lAutoOrder
      for nFor := 1 to Len( ::aCols )
         if ( ::cAlias )->( OrdNumber( ::aCols[ nFor ]:cHeader ) ) > 0
            ::aCols[nFor]:cSortOrder := ::aCols[ nFor ]:cHeader
         else
            ::aCols[nFor]:cSortOrder := ( cAlias )->( FindTag( ::aCols[ nFor ]:cHeader ) )
         endif
      next
   endif

   if ::lCreated
      ::Adjust()
      ::Refresh()
   endif

return nil



static function FindTag( cFld, nOrder )

   local nOrders  := OrdCount()
   local cTag, nAt, cKey, n, nLen, aOrders := {}

   cFld     := Upper( Trim( cFld ) )
   nLen     := Len( cFld )

   for n := 1 to nOrders
      cKey  := OrdKey( n )
      cKey  := Upper( StrTran( cKey, " ","" ) )
      if Left( cKey, nLen ) == cFld
         nOrder   := n
         cTag     := OrdName( n )
         exit
      endif
   next
   if Empty( cTag )
      for n := 1 to nOrders
         cKey  := OrdKey( n )
         cKey  := Upper( StrTran( cKey, " ","" ) )
         if ( nAt := At( "(", cKey ) ) > 0
            cKey  := SubStr( cKey, nAt + 1 )
            if Left( cKey, nLen ) == cFld
               nOrder   := n
               cTag     := OrdName( n )
               exit
            endif
         endif
      next
   endif

return cTag
