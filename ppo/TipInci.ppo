#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 12 ".\Prg\TipInci.prg"
static oWndBrw
static bEdit      := { |aTmp, aGet, dbf, oBrw, bWhen, bValid, nMode | EdtRec( aTmp, aGet, dbf, oBrw, bWhen, bValid, nMode ) }



static dbfInci








STATIC FUNCTION OpenFiles()

   local lOpen    := .T.
   local oBlock   := ErrorBlock( {| oError | ApoloBreak( oError ) } )

   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "TIPINCI.DBF" ), ( cCheckArea( "TIPINCI", @dbfInci ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "TIPINCI.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   RECOVER

      msgStop( "Imposible abrir todas las bases de datos" )
      CloseFiles()
      lOpen          := .F.

   end

   ErrorBlock( oBlock )

RETURN ( lOpen )



STATIC FUNCTION CloseFiles()


   if dbfInci <> nil
      ( dbfInci )->( dbCloseArea() )
   end

   dbfInci     := nil

   oWndBrw     := nil

RETURN .T.



FUNCTION TipInci( oMenuItem, oWnd )

   local nLevel

   IIF( oMenuItem == nil, oMenuItem := "01089", ) ;
   IIF( oWnd == nil, oWnd := oWnd(), ) ;

   if oWndBrw == nil





      nLevel            := nLevelUsr( oMenuItem )

      if nAnd( nLevel, 1 ) <> 0
         msgStop( "Acceso no permitido." )
         return nil
      end





      if oWnd <> nil
         SysRefresh(); oWnd:CloseAll(); SysRefresh()
      end





      if !OpenFiles()
         return nil
      end





      AddMnuNext( "Tipos de incidencias", ProcName() )














   oWndBrw := TShell():New( 2, 10, 18, 70, "Tipos de incidencias",, oWnd,,, .F.,,, ( dbfInci ),,,,, {"Código", "Nombre"}, {||( WinAppRec( oWndBrw:oBrw, bEdit, dbfInci ) )}, {||( WinEdtRec( oWndBrw:oBrw, bEdit, dbfInci ) )}, {||( WinDelRec( oWndBrw:oBrw, dbfInci ) )}, {||( WinDupRec( oWndBrw:oBrw, bEdit, dbfInci ) )}, nil, nLevel, "Camera_16", ( 104 + ( 0 * 256 ) + ( 63 * 65536 ) ),,, .T. )

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodInci"
         :bEditValue       := {|| ( dbfInci )->cCodInci }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cNomInci"
         :bEditValue       := {|| ( dbfInci )->cNomInci }
         :nWidth           := 300
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      oWndBrw:cHtmlHelp    := "Tipos de incidencias"

      oWndBrw:CreateXFromCode()





      oWndBrw:NewAt( "BUS",,, {||( oWndBrw:SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )

      oWndBrw:AddSeaBar()








      oWndBrw:NewAt( "NEW",,, {||( oWndBrw:RecAdd() )}, "(A)ñadir", "A",,, 2,, .F. )







      oWndBrw:NewAt( "EDIT",,, {||( oWndBrw:RecEdit() )}, "(M)odificar", "M",,, 4,, .F. )







      oWndBrw:NewAt( "ZOOM",,, {||( WinZooRec( oWndBrw:oBrw, bEdit, dbfInci ) )}, "(Z)oom", "Z",,, 8,, .F. )







      oWndBrw:NewAt( "DEL",,, {||( oWndBrw:RecDel() )}, "(E)liminar", "E",,, 16,, .F. )








      oWndBrw:NewAt( "IMP",,, {||( TInfListInci():New( "Listado de incidencias" ):Play() )}, "(L)istado", "L",,, 32,, .F. )







      oWndBrw:NewAt( "END",,, {||( oWndBrw:end() )}, "(S)alir", "S",,,,, .F. )

      oWndBrw:Activate(, oWndBrw:bLClicked, oWndBrw:bRClicked, oWndBrw:bMoved, oWndBrw:bResized, oWndBrw:bPainted, oWndBrw:bKeyDown, oWndBrw:bInit,,,,,,,,, {|| ( CloseFiles() )},, oWndBrw:bLButtonUp )

   ELSE

      oWndBrw:SetFocus()

   end

RETURN NIL



STATIC FUNCTION EdtRec( aTmp, aGet, dbfInci, oBrw, bWhen, bValid, nMode )

   local oDlg

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "tipos de incidencias", "TipArt",, .F.,,,,,, .F.,,,,,, .F., )







      aGet[ ( dbfInci )->( FieldPos( "CCODINCI" ) ) ] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ ( dbfInci )->( FieldPos( "CCODINCI" ) ) ], aTmp[ ( dbfInci )->( FieldPos( "CCODINCI" ) ) ]:= u ) }, oDlg,,, {||    ( !Empty( aTmp[ ( dbfInci )->( FieldPos( "cCodInci" ) ) ] ) .AND. NotValid( aGet[ ( dbfInci )->( FieldPos( "cCodInci" ) ) ], dbfInci ) )},,,,,, .T., {||     ( nMode == 1 )},, .F., .F.,,,,,, nil,,, )





      aGet[ ( dbfInci )->( FieldPos( "cNomInci" ) ) ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ ( dbfInci )->( FieldPos( "cNomInci" ) ) ], aTmp[ ( dbfInci )->( FieldPos( "cNomInci" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      TButton():ReDefine( 1, {||( lPreSave( aTmp, aGet, dbfInci, nMode, oDlg ) )}, oDlg,,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )




      TButton():ReDefine( 9, {||( ChmHelp( "TipoIncidencia" ) )}, oDlg,,, .F.,,,, .F. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| lPreSave( aTmp, aGet, dbfInci, nMode, oDlg ) } )
   end

   oDlg:AddFastKey ( 112, {|| ChmHelp( "TipoIncidencia" ) } )

   oDlg:bStart := { || aGet[ ( dbfInci )->( FieldPos( "CCODINCI" ) ) ]:SetFocus() }

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

RETURN ( oDlg:nResult == 1 )



Static Function lPreSave( aTmp, aGet, dbfInci, nMode, oDlg )

   if nMode == 1

      if Empty( aTmp[ ( dbfInci )->( FieldPos( "cCodInci" ) ) ] )
         MsgStop( "El código del tipo de incidencia no puede estar vacío." )
         aGet[ ( dbfInci )->( FieldPos( "cCodInci" ) ) ]:SetFocus()
         Return nil
      end

      if dbSeekInOrd( aTmp[ ( dbfInci )->( FieldPos( "cCodInci" ) ) ], "CCODINCI", dbfInci )
         MsgStop( "Código ya existe " + Rtrim( aTmp[ ( dbfInci )->( FieldPos( "cCodInci" ) ) ] ) )
         return nil
      end

   end

   if Empty( aTmp[ ( dbfInci )->( FieldPos( "cNomInci" ) ) ] )
      MsgStop( "El nombre del tipo de incidencia no puede estar vacío." )
      aGet[ ( dbfInci )->( FieldPos( "cNomInci" ) ) ]:SetFocus()
      Return nil
   end

   WinGather( aTmp, aGet, dbfInci, nil, nMode )

Return ( oDlg:end( 1 ) )


































FUNCTION cNomInci( cCodInci, dbfInci )

   local cNomInci    := ""

   if !Empty( dbfInci ) .AND. ( dbfInci )->( Used() )

      if dbSeekInOrd( cCodInci, "cCodInci", dbfInci )

         cNomInci    := ( dbfInci )->cNomInci

      end

   end

RETURN cNomInci



FUNCTION BrwIncidencia( dbfInci, oGet, oGet2 )

   local oDlg
   local oBrw
   local oFont
   local oBtn
   local oGet1
   local cGet1
   local nOrdAnt        := 1
   local oCbxOrd
   local aCbxOrd        := { "Código", "Nombre" }
   local cCbxOrd
   local nLevel         := nLevelUsr( "01089" )
   local oSayText
   local cSayText       := "Listado de incidencias"

   nOrdAnt              := Min( Max( nOrdAnt, 1 ), len( aCbxOrd ) )
   cCbxOrd              := aCbxOrd[ nOrdAnt ]

   nOrdAnt              := ( dbfInci )->( OrdSetFocus( nOrdAnt ) )

   ( dbfInci )->( dbGoTop() )


   oDlg = TDialog():New(,,,, "Seleccionar tipos de incidencia", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F., )




























      oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,, {||    ( OrdClearScope( oBrw, dbfInci ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, dbfInci ) ) }, .F., .F.,,,,,, nil, "FIND",, )






      oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,, {|Self|( ( dbfInci )->( OrdSetFocus( oCbxOrd:nAt ) ), oBrw:refresh(), oGet1:SetFocus(), oCbxOrd:Refresh() )},,,, .F.,,,,,, )



      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias          := dbfInci

      oBrw:nMarqueeStyle   := 5
      oBrw:cName           := "Browse.Tipos de incidencias"

      with object ( oBrw:AddCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodInci"
         :bEditValue       := {|| ( dbfInci )->cCodInci }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cNomInci"
         :bEditValue       := {|| ( dbfInci )->cNomInci }
         :nWidth           := 300
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }
      oBrw:bRClicked       := {| nRow, nCol, nFlags | oBrw:RButtonDown( nRow, nCol, nFlags ) }

      oBrw:CreateFromResource( 105 )

   if ( "PDA" $ cParamsMain() )



      oSayText := TSay():ReDefine( 100, {|| cSayText}, oDlg,,,, .F.,, .F., .F. )

   end

   if !( "PDA" $ cParamsMain() )





   TButton():ReDefine( 500, {||( WinAppRec( oBrw, bEdit, dbfInci ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 2 ) <> 0 )},,, .F. )





   TButton():ReDefine( 501, {||( WinEdtRec( oBrw, bEdit, dbfInci ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 4 ) <> 0 )},,, .F. )

   oDlg:AddFastKey( 113, {|| if( nAnd( nLevel, 2 ) <> 0, WinAppRec( oBrw, bEdit, dbfInci ), ) } )
   oDlg:AddFastKey( 114, {|| if( nAnd( nLevel, 4 ) <> 0, WinEdtRec( oBrw, bEdit, dbfInci ), ) } )

   end




   TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

   oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )
   oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )
























   if oDlg:nResult == 1

      oGet:cText( ( dbfInci )->cCodInci )
      oGet:lValid()

      if ValType( oGet2 ) == "O"
         oGet2:cText( ( dbfInci )->cNomInci )
      end

   end

   DestroyFastFilter( dbfInci )

   SetBrwOpt( "BrwIncidencia", ( dbfInci )->( OrdNumber() ) )

   oGet:SetFocus()

Return ( .T. )



FUNCTION cTipInci( oGet, dbfInci, oGet2, lMessage )

   local oBlock
   local oError
   local nOrdAnt
   local lValid      := .F.
   local lClose      := .F.
   local xValor      := oGet:varGet()

   IIF( lMessage == nil, lMessage := .T., ) ;

   if Empty( xValor )
        RETURN .T.
    end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if (dbfInci) == NIL

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "TIPINCI.DBF" ), ( cCheckArea( "TIPINCI", @dbfInci ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "TIPINCI.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClose         := .T.

   else

      nOrdAnt        := ( dbfInci )->( ordSetFocus( 1 ) )

   end

   if ( dbfInci )->( dbSeek( xValor ) )

      oGet:cText( ( dbfInci )->CCODINCI )

      if oGet2 <> NIL
         oGet2:cText( (dbfInci)->CNOMINCI )
      end

      lValid         := .T.

   else

      if lMessage
         msgStop( "Tipo de incidencia no encontrado", "Aviso del sistema" )
      end

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClose
      (dbfInci)->( dbCloseArea() )
   else
      ( dbfInci )->( ordSetFocus( nOrdAnt ) )
   end

RETURN lValid



FUNCTION mkInci( cPath, lAppend, cPathOld, oMeter )

   local dbfInci

   IIF( cPath == nil, cPath := cPatEmp(), ) ;
   IIF( lAppend == nil, lAppend := .F., ) ;

   if !lExistTable( cPath + "TipInci.Dbf" )
      dbCreate( cPath + "TipInci.Dbf", aSqlStruct( aItmInci() ),  cDriver() )
   end

   if lAppend .AND. lIsDir( cPathOld )
      dbUseArea( .T., cDriver(), cPath + "TipInci.Dbf", cCheckArea( "TipInci", @dbfInci ), .F. )
      if !( dbfInci )->( neterr() )
         ( dbfInci )->( __dbApp( cPathOld + "TipInci.Dbf" ) )
         ( dbfInci )->( dbCloseArea() )
      end
   end

   rxInci( cPath, oMeter )

RETURN .T.



function aItmInci()

   local aBase  := {}

   aAdd( aBase, { "CCODINCI",   "C",  3, 0, "Código incidencia",    "'@!'",               "" } )
   aAdd( aBase, { "CNOMINCI",   "C", 50, 0, "Nombre incidencia",    "",                   "" } )

return ( aBase )



FUNCTION rxInci( cPath, oMeter )

   local dbfInci

   IIF( cPath == nil, cPath := cPatEmp(), ) ;

   if !lExistTable( cPath + "TIPINCI.DBF" )
      mkInci( cPath )
   end

   fEraseIndex( cPath + "TIPINCI.CDX" )

   if lExistTable( cPath + "TIPINCI.DBF" )

      dbUseArea( .T., cDriver(), cPath + "TIPINCI.DBF", cCheckArea( "TIPINCI", @dbfInci ), .F. )

      if !( dbfInci )->( neterr() )
         ( dbfInci )->( __dbPack() )

         ( dbfInci )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
         ( dbfInci )->( ordCreate( cPath + "TIPINCI.CDX", "CCODINCI", "Field->CCODINCI", {|| Field->CCODINCI } ) )

         ( dbfInci )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
         ( dbfInci )->( ordCreate( cPath + "TIPINCI.CDX", "CNOMINCI", "Field->CNOMINCI", {|| Field->CNOMINCI } ) )

         ( dbfInci )->( dbCloseArea() )
      else
         msgStop( "Imposible abrir en modo exclusivo los tipos de incidencias" )
      end

   end

RETURN NIL



Function IsTipInci()

   local oError
   local oBlock
   local dbfInci

   if !lExistTable( cPatEmp() + "TIPINCI.Dbf" )
      mkInci( cPatEmp() )
   end

   if !lExistIndex( cPatEmp() + "TIPINCI.Cdx" )
      rxInci( cPatEmp() )
   end

   oBlock                     := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "TIPINCI.Dbf" ), ( cCheckArea( "CCODINCI", @dbfInci ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "TIPINCI.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   ( dbfInci )->( dbCloseArea() )

Return ( .T. )
