#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 26 ".\Prg\Tvisor.prg"
_HB_CLASS TVisor ; UTILITY FUNCTION TVisor(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TVisor" , { HBObject():Classh } ) ) ;

   _HB_MEMBER {AS LOGIC lCreated} ; IIF( !.F., s_oClass:AddMultiClsData("LOGIC", .F., nScope + IIF( .F., 32, 0 ) + 64, { "lCreated" }, .F. ), )

   _HB_MEMBER { oPrn} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oPrn" }, .F., .F. ), )

   _HB_MEMBER { cPort} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPort" }, .F., .F. ), )
   _HB_MEMBER { nBitsSec} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nBitsSec" }, .F., .F. ), )
   _HB_MEMBER { nBitsParada} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nBitsParada" }, .F., .F. ), )
   _HB_MEMBER { nBitsDatos} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nBitsDatos" }, .F., .F. ), )
   _HB_MEMBER { nBitsParidad} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nBitsParidad" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nHComm} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nHComm" }, .F., .F. ), )
   _HB_MEMBER { cLastError} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cLastError" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nLineas} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 2, nScope + IIF( .F., 32, 0 ), { "nLineas" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nChrLineas} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 20, nScope + IIF( .F., 32, 0 ), { "nChrLineas" }, .F., .F. ), )
   _HB_MEMBER { cRetroceso} ; IIF( !.F., s_oClass:AddMultiData(, Space( 50 ), nScope + IIF( .F., 32, 0 ), { "cRetroceso" }, .F., .F. ), )
   _HB_MEMBER { cAvanceChr} ; IIF( !.F., s_oClass:AddMultiData(, Space( 50 ), nScope + IIF( .F., 32, 0 ), { "cAvanceChr" }, .F., .F. ), )
   _HB_MEMBER { cAvanceLinea} ; IIF( !.F., s_oClass:AddMultiData(, Space( 50 ), nScope + IIF( .F., 32, 0 ), { "cAvanceLinea" }, .F., .F. ), )
   _HB_MEMBER { cReset} ; IIF( !.F., s_oClass:AddMultiData(, Space( 50 ), nScope + IIF( .F., 32, 0 ), { "cReset" }, .F., .F. ), )
   _HB_MEMBER { cActiveCursor} ; IIF( !.F., s_oClass:AddMultiData(, Space( 50 ), nScope + IIF( .F., 32, 0 ), { "cActiveCursor" }, .F., .F. ), )
   _HB_MEMBER { cInactiveCursor} ; IIF( !.F., s_oClass:AddMultiData(, Space( 50 ), nScope + IIF( .F., 32, 0 ), { "cInactiveCursor" }, .F., .F. ), )
   _HB_MEMBER { cNormalWrite} ; IIF( !.F., s_oClass:AddMultiData(, Space( 50 ), nScope + IIF( .F., 32, 0 ), { "cNormalWrite" }, .F., .F. ), )
   _HB_MEMBER { cOffsetWrite} ; IIF( !.F., s_oClass:AddMultiData(, Space( 50 ), nScope + IIF( .F., 32, 0 ), { "cOffsetWrite" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nPosInit} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 0, nScope + IIF( .F., 32, 0 ), { "nPosInit" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nPosEnd} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 0, nScope + IIF( .F., 32, 0 ), { "nPosEnd" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nFirstRow} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 0, nScope + IIF( .F., 32, 0 ), { "nFirstRow" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nFirstCol} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 0, nScope + IIF( .F., 32, 0 ), { "nFirstCol" }, .F., .F. ), )
   _HB_MEMBER { cWellcomeLine1} ; IIF( !.F., s_oClass:AddMultiData(, Space( 50 ), nScope + IIF( .F., 32, 0 ), { "cWellcomeLine1" }, .F., .F. ), )
   _HB_MEMBER { cWellcomeLine2} ; IIF( !.F., s_oClass:AddMultiData(, Space( 50 ), nScope + IIF( .F., 32, 0 ), { "cWellcomeLine2" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nInact} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 10, nScope + IIF( .F., 32, 0 ), { "nInact" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nRetardo} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nRetardo" }, .F., .F. ), )

   _HB_MEMBER { aTextLine} ; IIF( !.F., s_oClass:AddMultiData(, Array( 2 ), nScope + IIF( .F., 32, 0 ), { "aTextLine" }, .F., .F. ), )

   _HB_MEMBER { oTimer} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oTimer" }, .F., .F. ), )

   _HB_MEMBER Create() AS CLASS TVisor; IIF( .F., s_oClass:ModMethod( "Create", @TVisor_Create(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Create", @TVisor_Create(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER New( cPort, nBitsSec, nBitsParada, nBitsDatos, nBitsParidad, cApertura); IIF( .F., s_oClass:ModMethod( "New", @TVisor_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TVisor_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Wellcome(); IIF( .F., s_oClass:ModMethod( "Wellcome", @TVisor_Wellcome(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Wellcome", @TVisor_Wellcome(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Say( cWellcomeLine1, cWellcomeLine2); IIF( .F., s_oClass:ModMethod( "Say", @TVisor_Say(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Say", @TVisor_Say(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetBufferLine( cTextLine, nLine); IIF( .F., s_oClass:ModMethod( "SetBufferLine", @TVisor_SetBufferLine(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetBufferLine", @TVisor_SetBufferLine(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER WriteBufferLine(); IIF( .F., s_oClass:ModMethod( "WriteBufferLine", @TVisor_WriteBufferLine(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "WriteBufferLine", @TVisor_WriteBufferLine(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER End(); IIF( .F., s_oClass:ModMethod( "End", @TVisor_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "End", @TVisor_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TVisor ;



UTILITY STATIC function TVisor_Create( cCodImp) ; local Self AS CLASS TVisor := QSelf() AS CLASS TVisor

   local oBlock
   local oError
   local dbfVisor



   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatDat() + "Visor.Dbf" ), ( cCheckArea( "Visor", @dbfVisor ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatDat() + "Visor.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

   if !Empty( cCodImp ) .AND. ( dbfVisor )->( dbSeek( cCodImp ) )



      ::cPort              := ( dbfVisor )->cPort
      ::nBitsSec           := Str( ( dbfVisor )->nBitSec )
      ::nBitsParada        := Str( ( dbfVisor )->nBitPar )
      ::nBitsDatos         := Str( ( dbfVisor )->nBitDat )
      ::nBitsParidad       := ( dbfVisor )->cBitPari
      ::nLineas            := ( dbfVisor )->nLinea
      ::nChrLineas         := ( dbfVisor )->nChaLin
      ::cRetroceso         := ( dbfVisor )->cRetro
      ::cAvanceChr         := ( dbfVisor )->cAvCha
      ::cAvanceLinea       := ( dbfVisor )->cAvLin
      ::cReset             := ( dbfVisor )->cReset
      ::cActiveCursor      := ""
      ::cInactiveCursor    := ""
      ::cNormalWrite       := ( dbfVisor )->cEscNor
      ::cOffsetWrite       := ( dbfVisor )->cEscDes
      ::nPosInit           := ( dbfVisor )->cPosIni
      ::nPosEnd            := ( dbfVisor )->cPosFin
      ::nFirstRow          := ( dbfVisor )->cPriFil
      ::nFirstCol          := ( dbfVisor )->cPriCol
      ::cWellcomeLine1     := Rtrim( ( dbfVisor )->cText1 )
      ::cWellcomeLine2     := Rtrim( ( dbfVisor )->cText2 )
      ::nInact             := ( dbfVisor )->nInact

   else



      ::cPort              := "COM1"
      ::nBitsSec           := "9600"
      ::nBitsParada        := "0"
      ::nBitsDatos         := "8"
      ::nBitsParidad       := "Sin paridad"
      ::nLineas            := 2
      ::nChrLineas         := 20
      ::cRetroceso         := ""
      ::cAvanceChr         := ""
      ::cAvanceLinea       := ""
      ::cReset             := ""
      ::cActiveCursor      := ""
      ::cInactiveCursor    := ""
      ::cNormalWrite       := ""
      ::cOffsetWrite       := ""
      ::nPosInit           := ""
      ::nPosEnd            := ""
      ::nFirstRow          := ""
      ::nFirstCol          := ""
      ::cWellcomeLine1     := "Bienvenidos a"
      ::cWellcomeLine2     := "Gestool" + Space( 1 ) + "2K13"
      ::nInact             := 10

   end



   if dbfVisor <> nil
      ( dbfVisor )->( dbCloseArea() )
   end

   dbfVisor                := nil

   ::oPrn                  := TPort():New( ::cPort, ::nBitsSec, ::nBitsParada, ::nBitsDatos, ::nBitsParidad, .F. )

   if ::oPrn:lCreated

      ::lCreated           := .T.

      if ::nInact <> 0
         ::oTimer          := TTimer():New( ::nInact * 1000, {|| ::Wellcome() } )
      end

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

RETURN Self



UTILITY STATIC function TVisor_New( cPort, nBitsSec, nBitsParada, nBitsDatos, nBitsParidad, lMessage) ; local Self AS CLASS TVisor := QSelf() AS CLASS TVisor

   IIF( lMessage == nil, lMessage := .F., ) ;





   ::oPrn               := TPort():New( ::cPort, nBitsSec, nBitsParada, nBitsDatos, nBitsParidad, lMessage )

   if ::oPrn:lCreated

      ::lCreated        := .T.

      if !Empty( ::oTimer )
         ::oTimer:Activate()
      end

   end

Return ( ::lCreated )




UTILITY STATIC function TVisor_Wellcome() ; local Self AS CLASS TVisor := QSelf() AS CLASS TVisor

   if ::lCreated

      if !Empty( ::cReset )
         ::oPrn:Write( ::cReset )
      end


      ::oPrn:Write(  PadC( ::cWellcomeLine1, ::nChrLineas ) +  PadC( ::cWellcomeLine2, ::nChrLineas ) )
   end

RETURN ( Self )



UTILITY STATIC function TVisor_Say( cTxtLine1, cTxtLine2) ; local Self AS CLASS TVisor := QSelf() AS CLASS TVisor

   if ::lCreated

      if ::oTimer <> nil
         ::oTimer:DeActivate()
      end

      ::oPrn:Write( PadR( cTxtLine1, ::nChrLineas ) + PadL( cTxtLine2, ::nChrLineas ) )

      if ::oTimer <> nil
         ::oTimer:Activate()
      end

   end

Return ( Self )



UTILITY STATIC function TVisor_End() ; local Self AS CLASS TVisor := QSelf() AS CLASS TVisor

   if !Empty( ::oPrn )
      ::oPrn:End()
   end

   if ::oTimer <> nil
      ::oTimer:End()
   end

Return ( Self )



UTILITY STATIC function TVisor_SetBufferLine( cTxtLine, nLine) ; local Self AS CLASS TVisor := QSelf() AS CLASS TVisor

   local nLen

   IIF( nLine == nil, nLine := 1, ) ;

   if Valtype( cTxtLine ) == "A"

      nLen                 := Len( AllTrim( cTxtLine[ 2 ] ) ) + 1
      ::aTextLine[ nLine ] := PadR( cTxtLine[ 1 ], ::nChrLineas - nLen ) + PadL( AllTrim( cTxtLine[ 2 ] ), nLen )

   else

      ::aTextLine[ nLine ] := PadR( cTxtLine, ::nChrLineas )

   end

Return ( Self )



UTILITY STATIC function TVisor_WriteBufferLine() ; local Self AS CLASS TVisor := QSelf() AS CLASS TVisor

   ::Say( ::aTextLine[ 1 ], ::aTextLine[ 2 ] )

Return ( Self )
