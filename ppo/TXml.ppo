#line 112 "\xHarbour\Include\hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 62 ".\Prg\TXml.prg"
_HB_CLASS TXMLNode ; UTILITY FUNCTION TXMLNode(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TXMLNode" , { HBObject():Classh } ) ) ;
   _HB_MEMBER { nType} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nType" }, .F., .F. ), )
   _HB_MEMBER { cName} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cName" }, .F., .F. ), )
   _HB_MEMBER { aAttributes} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aAttributes" }, .F., .F. ), )
   _HB_MEMBER { nBeginLine} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nBeginLine" }, .F., .F. ), )
   _HB_MEMBER { cData} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cData" }, .F., .F. ), )

   _HB_MEMBER { oNext} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oNext" }, .F., .F. ), )
   _HB_MEMBER { oPrev} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oPrev" }, .F., .F. ), )
   _HB_MEMBER { oParent} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oParent" }, .F., .F. ), )
   _HB_MEMBER { oChild} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oChild" }, .F., .F. ), )

   _HB_MEMBER New( nType, cName, aAttributes, cData) AS CLASS TXMLNode; IIF( .F., s_oClass:ModMethod( "New", @TXMLNode_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TXMLNode_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Clone(); IIF( .F., s_oClass:ModInline( "Clone", {|Self | Self, HBXml_node_clone( Self ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Clone", {|Self | Self, HBXml_node_clone( Self ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER CloneTree(); IIF( .F., s_oClass:ModInline( "CloneTree", {|Self | Self, HBXml_node_clone_tree( Self ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "CloneTree", {|Self | Self, HBXml_node_clone_tree( Self ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Unlink(); IIF( .F., s_oClass:ModInline( "Unlink", {|Self | Self, HBXml_node_unlink( Self ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Unlink", {|Self | Self, HBXml_node_unlink( Self ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER NextInTree(); IIF( .F., s_oClass:ModMethod( "NextInTree", @TXMLNode_NextInTree(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "NextInTree", @TXMLNode_NextInTree(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER InsertBefore(oNode); IIF( .F., s_oClass:ModInline( "InsertBefore", {|Self,oNode | Self, HBXml_node_insert_before( Self, oNode ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "InsertBefore", {|Self,oNode | Self, HBXml_node_insert_before( Self, oNode ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER InsertAfter(oNode); IIF( .F., s_oClass:ModInline( "InsertAfter", {|Self,oNode | Self, HBXml_node_insert_after( Self, oNode ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "InsertAfter", {|Self,oNode | Self, HBXml_node_insert_after( Self, oNode ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER InsertBelow(oNode); IIF( .F., s_oClass:ModInline( "InsertBelow", {|Self,oNode | Self, HBXml_node_insert_below( Self, oNode ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "InsertBelow", {|Self,oNode | Self, HBXml_node_insert_below( Self, oNode ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER AddBelow(oNode); IIF( .F., s_oClass:ModInline( "AddBelow", {|Self,oNode | Self, HBXml_node_add_below( Self, oNode ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "AddBelow", {|Self,oNode | Self, HBXml_node_add_below( Self, oNode ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER GetAttribute( xAttrib); IIF( .F., s_oClass:ModMethod( "GetAttribute", @TXMLNode_GetAttribute(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetAttribute", @TXMLNode_GetAttribute(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetAttribute( cAttrib, xValue); IIF( .F., s_oClass:ModMethod( "SetAttribute", @TXMLNode_SetAttribute(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetAttribute", @TXMLNode_SetAttribute(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Depth(); IIF( .F., s_oClass:ModMethod( "Depth", @TXMLNode_Depth(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Depth", @TXMLNode_Depth(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Path(); IIF( .F., s_oClass:ModMethod( "Path", @TXMLNode_Path(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Path", @TXMLNode_Path(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ToString(nStyle); IIF( .F., s_oClass:ModInline( "ToString", {|Self,nStyle | Self, HBXml_node_to_string( Self, nStyle ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ToString", {|Self,nStyle | Self, HBXml_node_to_string( Self, nStyle ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER Write(fHandle, nStyle); IIF( .F., s_oClass:ModInline( "Write", {|Self,fHandle, nStyle | Self, HBXml_node_write( Self, fHandle, nStyle ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Write", {|Self,fHandle, nStyle | Self, HBXml_node_write( Self, fHandle, nStyle ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER ToArray(); IIF( .F., s_oClass:ModInline( "ToArray", {|Self | Self, { ::nType, ::cName, ::aAttributes, ::cData } }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ToArray", {|Self | Self, { ::nType, ::cName, ::aAttributes, ::cData } }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER AttribCount(); IIF( .F., s_oClass:ModInline( "AttribCount", {|Self | Self, Len(::aAttributes) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "AttribCount", {|Self | Self, Len(::aAttributes) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER GetValues(); IIF( .F., s_oClass:ModInline( "GetValues", {|Self | Self, HGetValues(::aAttributes) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetValues", {|Self | Self, HGetValues(::aAttributes) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER GetKeys(); IIF( .F., s_oClass:ModInline( "GetKeys", {|Self | Self, HGetKeys(::aAttributes) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetKeys", {|Self | Self, HGetKeys(::aAttributes) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER GetPair(nPos); IIF( .F., s_oClass:ModInline( "GetPair", {|Self,nPos | Self, HGetPairAt(::aAttributes,nPos) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetPair", {|Self,nPos | Self, HGetPairAt(::aAttributes,nPos) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TXMLNode ;


UTILITY STATIC function TXMLNode_New( nType, cName, aAttributes, cData) ; local Self AS CLASS TXMLNode := QSelf() AS CLASS TXMLNode


   IF nType == NIL
      ::nType := 0
   ELSEIF HB_isNumeric( nType)
      ::nType := nType
   ENDIF

   IF HB_isHash( aAttributes )
      ::aAttributes := aAttributes
   ELSE
      ::aAttributes := {=>}
   ENDIF

   IF HB_isString( cName )
      ::cName := cName
   ENDIF

   IF HB_isString( cData )
     ::cData := cData
   ENDIF

RETURN Self


UTILITY STATIC function TXMLNode_GetAttribute( xAttrib) ; local Self AS CLASS TXMLNode := QSelf() AS CLASS TXMLNode

Local xRet

if ! empty( xAttrib )

    if HB_IsString( xAttrib )
       xRet := iif( HHasKey( ::aAttributes, xAttrib), HGet(::aAttributes, xAttrib ), NIL )
    elseif HB_isNumeric( xAttrib )
       xRet := iif( Len( ::aAttributes ) >= xAttrib, HGetValueAt( ::aAttributes, xAttrib ), NIL )
    endif

endif

RETURN xRet


UTILITY STATIC function TXMLNode_SetAttribute( xAttrib, xValue) ; local Self AS CLASS TXMLNode := QSelf() AS CLASS TXMLNode


if ! empty( xAttrib )

   if HB_isString( xAttrib )

      ::aAttributes[ xAttrib ] := xValue

   elseif HB_isNumeric( xAttrib )

      if Len( ::aAttributes ) >= xAttrib
         HSetValueAt( ::aAttributes, xAttrib, xValue )
      endif

   endif

endif

RETURN xValue


UTILITY STATIC function TXMLNode_NextInTree() ; local Self AS CLASS TXMLNode := QSelf() AS CLASS TXMLNode

LOCAL oNext := NIL, oTemp

   IF ::oChild <> NIL
      oNext := ::oChild
   ELSEIF ::oNext <> NIL
      oNext := ::oNext
   ELSE
      oTemp := ::oParent
      while oTemp <> NIL
         IF oTemp:oNext <> NIL
            oNext := oTemp:oNext
            EXIT
         ENDIF
         oTemp := oTemp:oParent
      ENDDO
   ENDIF

RETURN oNext


UTILITY STATIC function TXMLNode_Depth() ; local Self AS CLASS TXMLNode := QSelf() AS CLASS TXMLNode

   IF ::oParent <> NIL
      RETURN ::oParent:Depth() + 1
   ENDIF
RETURN 0


UTILITY STATIC function TXMLNode_Path() ; local Self AS CLASS TXMLNode := QSelf() AS CLASS TXMLNode

   IF ::nType == 6
      RETURN ""
   ENDIF

   IF ::cName <> NIL
      IF ::oParent <> NIL
         IF ::oParent:Path() <> NIL
            RETURN ::oParent:Path() + "/" + ::cName
         ENDIF
      ELSE
         RETURN "/" + ::cName
      ENDIF
   ENDIF
RETURN NIL




_HB_CLASS TXmlIterator ; UTILITY FUNCTION TXmlIterator(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TXmlIterator" , { HBObject():Classh } ) ) ;
   _HB_MEMBER New( oNodeTop) AS CLASS TXmlIterator; IIF( .F., s_oClass:ModMethod( "New", @TXmlIterator_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TXmlIterator_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Next(); IIF( .F., s_oClass:ModMethod( "Next", @TXmlIterator_Next(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Next", @TXmlIterator_Next(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Rewind(); IIF( .F., s_oClass:ModInline( "Rewind", {|Self | Self, ::oNode := ::oTop }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Rewind", {|Self | Self, ::oNode := ::oTop }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER GetNode(); IIF( .F., s_oClass:ModInline( "GetNode", {|Self | Self, ::oNode }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetNode", {|Self | Self, ::oNode }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER SetContext(); IIF( .F., s_oClass:ModMethod( "SetContext", @TXmlIterator_SetContext(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetContext", @TXmlIterator_SetContext(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Clone(); IIF( .F., s_oClass:ModMethod( "Clone", @TXmlIterator_Clone(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Clone", @TXmlIterator_Clone(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Find( cName, cAttribute, cValue, cData); IIF( .F., s_oClass:ModMethod( "Find", @TXmlIterator_Find(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Find", @TXmlIterator_Find(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER FindNext(); IIF( .F., s_oClass:ModMethod( "FindNext", @TXmlIterator_FindNext(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FindNext", @TXmlIterator_FindNext(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER { lRegex} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lRegex" }, .F., .F. ), )

nScope := 8

   _HB_MEMBER { cName} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cName" }, .F., .F. ), )
   _HB_MEMBER { cAttribute} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cAttribute" }, .F., .F. ), )
   _HB_MEMBER { cValue} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cValue" }, .F., .F. ), )
   _HB_MEMBER { cData} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cData" }, .F., .F. ), )

   _HB_MEMBER { nTopLevel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nTopLevel" }, .F., .F. ), )

   _HB_MEMBER { oNode} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oNode" }, .F., .F. ), )
   _HB_MEMBER { oTop} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oTop" }, .F., .F. ), )

   _HB_MEMBER MatchCriteria( oNode); IIF( .F., s_oClass:ModMethod( "MatchCriteria", @TXmlIterator_MatchCriteria(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MatchCriteria", @TXmlIterator_MatchCriteria(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TXmlIterator ;


UTILITY STATIC function TXmlIterator_New( oNodeTop) ; local Self AS CLASS TXmlIterator := QSelf() AS CLASS TXmlIterator

   ::oTop  := oNodeTop
   ::oNode := oNodeTop
   ::nTopLevel := oNodeTop:Depth()
RETURN Self



UTILITY STATIC function TXmlIterator_Clone() ; local Self AS CLASS TXmlIterator := QSelf() AS CLASS TXmlIterator

   LOCAL oRet

   oRet := TXmlIterator():New( ::oNodeTop )
   oRet:cName := ::cName
   oRet:cAttribute := ::cAttribute
   oRet:cValue := ::cValue
   oRet:cData := ::cData
RETURN oRet


UTILITY STATIC function TXmlIterator_SetContext() ; local Self AS CLASS TXmlIterator := QSelf() AS CLASS TXmlIterator

   ::oTop := ::oNode
RETURN Self


UTILITY STATIC function TXmlIterator_Next() ; local Self AS CLASS TXmlIterator := QSelf() AS CLASS TXmlIterator

   LOCAL oNext := ::oNode:NextInTree()

   if oNext <> NIL .AND. oNext:Depth() <= ::nTopLevel
      RETURN NIL
   endif

   ::oNode := oNext

RETURN oNext


UTILITY STATIC function TXmlIterator_Find( cName, cAttribute, cValue, cData) ; local Self AS CLASS TXmlIterator := QSelf() AS CLASS TXmlIterator


   ::cName      := cName
   ::cAttribute := cAttribute
   ::cValue     := cValue
   ::cData      := cData

   ::Rewind()

   IF ::oNode:nType == 6
      IF ::oNode:oChild == NIL
         RETURN NIL
      ENDIF
      ::oNode := ::oNode:oChild
   ENDIF

   if ! ::MatchCriteria( ::oNode )
      ::FindNext()
   endif

RETURN ::oNode


UTILITY STATIC function TXmlIterator_FindNext() ; local Self AS CLASS TXmlIterator := QSelf() AS CLASS TXmlIterator


   IF ::cName = NIL .AND. ::cAttribute = NIL .AND. ::cValue = NIL .AND. ::cData = NIL
      RETURN NIL
   ENDIF

   ::oNode := ::oNode:NextInTree()

   WHILE ::oNode <> NIL

      IF ::oNode:Depth() <= ::nTopLevel
         RETURN NIL
      ENDIF

      IF ::MatchCriteria( ::oNode )
         exit
      ENDIF

      ::oNode := ::oNode:NextInTree()

   ENDDO

RETURN ::oNode


UTILITY STATIC function TXmlIterator_MatchCriteria( oNode) ; local Self AS CLASS TXmlIterator := QSelf() AS CLASS TXmlIterator

Local lFound := .F.


   if ::cName <> NIL .AND. oNode:cName <> NIL
      if ::lRegex
         lFound := ( oNode:cName LIKE ::cName )
      else
         lFound := ( oNode:cName == ::cName  )
      endif
   endif

   if ::cAttribute <> NIL .AND. ! empty( oNode:aAttributes )
      if ::lRegex
         lFound := ( HScan( oNode:aAttributes, {|cKey| cKey LIKE ::cAttribute } ) > 0 )
      else
         lFound := ( ::cAttribute IN oNode:aAttributes )
      endif
   endif

   if ::cValue <> NIL .AND. ! empty( oNode:aAttributes )
      if ::lRegex
         lFound := ( HScan( oNode:aAttributes, {| ,cValue| cValue LIKE ::cValue } ) > 0 )
      else
         lFound := ( HScan( oNode:aAttributes, ::cValue ) <> 0 )
      endif
   endif

   if ::cData <> NIL .AND. oNode:cData <> NIL
      if ::lRegex
         lFound :=  ( oNode:cData HAS ::cData )
      else
         lFound := ( oNode:cData == ::cData )
      endif
   endif


RETURN lFound







_HB_CLASS TxmlIteratorScan ; UTILITY FUNCTION TxmlIteratorScan(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TxmlIteratorScan" , {TxmlIterator():classh} ) ) ; ;
  _HB_MEMBER New( oNodeTop) AS CLASS TxmlIteratorScan; IIF( .F., s_oClass:ModMethod( "New", @TxmlIteratorScan_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TxmlIteratorScan_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
  _HB_MEMBER Next(); IIF( .F., s_oClass:ModInline( "Next", {|Self | Self, ::TxmlIterator:FindNext() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Next", {|Self | Self, ::TxmlIterator:FindNext() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TxmlIteratorScan ;

UTILITY STATIC function TxmlIteratorScan_New( oNodeTop) ; local Self AS CLASS TxmlIteratorScan := QSelf() AS CLASS TxmlIteratorScan
  ::TxmlIterator:New( oNodeTop )
Return Self


_HB_CLASS TxmlIteratorRegex ; UTILITY FUNCTION TxmlIteratorRegex(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TxmlIteratorRegex" , {TxmlIterator():classh} ) ) ; ;
  _HB_MEMBER New( oNodeTop) AS CLASS TxmlIteratorRegex; IIF( .F., s_oClass:ModMethod( "New", @TxmlIteratorRegex_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TxmlIteratorRegex_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
  _HB_MEMBER Next(); IIF( .F., s_oClass:ModInline( "Next", {|Self | Self, ::TxmlIterator:FindNext() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Next", {|Self | Self, ::TxmlIterator:FindNext() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TxmlIteratorRegex ;

UTILITY STATIC function TxmlIteratorRegex_New( oNodeTop) ; local Self AS CLASS TxmlIteratorRegex := QSelf() AS CLASS TxmlIteratorRegex
  ::TxmlIterator:New( oNodeTop )
  ::lRegex:= .T.
Return Self







_HB_CLASS TXmlDocument ; UTILITY FUNCTION TXmlDocument(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TXmlDocument" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { oRoot} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oRoot" }, .F., .F. ), )
   _HB_MEMBER { nStatus} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nStatus" }, .F., .F. ), )
   _HB_MEMBER { nError} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nError" }, .F., .F. ), )
   _HB_MEMBER { nLine} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nLine" }, .F., .F. ), )
   _HB_MEMBER { oErrorNode} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oErrorNode" }, .F., .F. ), )
   _HB_MEMBER { nNodeCount} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nNodeCount" }, .F., .F. ), )
   _HB_MEMBER { cSignature} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cSignature" }, .F., .F. ), )

   _HB_MEMBER New( uXml, nStyle) AS CLASS TXmlDocument; IIF( .F., s_oClass:ModMethod( "New", @TXmlDocument_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TXmlDocument_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Read( xData, nStyle); IIF( .F., s_oClass:ModMethod( "Read", @TXmlDocument_Read(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Read", @TXmlDocument_Read(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ToString(nStyle); IIF( .F., s_oClass:ModInline( "ToString", {|Self,nStyle | Self, iif( ::nStatus = 1, ::oRoot:ToString( nStyle ) ,"") }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ToString", {|Self,nStyle | Self, iif( ::nStatus = 1, ::oRoot:ToString( nStyle ) ,"") }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER Write( cFileName, nStyle); IIF( .F., s_oClass:ModMethod( "Write", @TXmlDocument_Write(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Write", @TXmlDocument_Write(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER FindFirst( cName, cAttrib, cValue, cData); IIF( .F., s_oClass:ModMethod( "FindFirst", @TXmlDocument_FindFirst(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FindFirst", @TXmlDocument_FindFirst(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER FindFirstRegex( cName, cAttrib, cValue, cData); IIF( .F., s_oClass:ModMethod( "FindFirstRegex", @TXmlDocument_FindFirstRegex(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FindFirstRegex", @TXmlDocument_FindFirstRegex(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER FindNext(); IIF( .F., s_oClass:ModInline( "FindNext", {|Self | Self, iif( ::nStatus = 1, ::oIterator:FindNext(), NIL ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "FindNext", {|Self | Self, iif( ::nStatus = 1, ::oIterator:FindNext(), NIL ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER Next(); IIF( .F., s_oClass:ModInline( "Next", {|Self | Self, iif( ::nStatus = 1, ::oIterator:Next(), NIL ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Next", {|Self | Self, iif( ::nStatus = 1, ::oIterator:Next(), NIL ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER GetContext(); IIF( .F., s_oClass:ModMethod( "GetContext", @TXmlDocument_GetContext(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetContext", @TXmlDocument_GetContext(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER CurNode(); IIF( .F., s_oClass:ModInline( "CurNode", {|Self | Self, iif( ::nStatus = 1, ::oIterator:GetNode(), NIL ) }, 1, .F. ), s_oClass:AddInline( "CurNode", {|Self | Self, iif( ::nStatus = 1, ::oIterator:GetNode(), NIL ) }, 1, .F. ) )
   _HB_MEMBER ErrorMsg(); IIF( .F., s_oClass:ModInline( "ErrorMsg", {|Self | Self, HB_XMLERRORDESC( ::nError ) }, 1, .F. ), s_oClass:AddInline( "ErrorMsg", {|Self | Self, HB_XMLERRORDESC( ::nError ) }, 1, .F. ) )

nScope := 8

   _HB_MEMBER { oIterator} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oIterator" }, .F., .F. ), )
   _HB_MEMBER { cHeader} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cHeader" }, .F., .F. ), )

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TXmlDocument ;


UTILITY STATIC function TXmlDocument_New( uXml, nStyle) ; local Self AS CLASS TXmlDocument := QSelf() AS CLASS TXmlDocument

Local nh, lNew

   ::nStatus := 1
   ::nError := 0
   ::nLine := 1
   ::nNodeCount := 0
   ::cSignature := ""

   lNew := .F.

   IF uXml == NIL
      ::oRoot := TXmlNode():New( 6 )
      ::cHeader := '<?xml version="1.0"?>'
      lNew := .T.
   ELSE
      SWITCH ValType( uXml )
         CASE "O"
            ::oRoot = uXml
            EXIT
         CASE "N"
            ::oRoot := TXmlNode():New( 6 )
            ::Read( uXml, nStyle )
            EXIT
         CASE "C"
            if ! file( uXml )
               ::oRoot := TXmlNode():New( 6 )
               ::Read( uXml, nStyle )
            else
               nh := FOpen( uXml )
               if nh == -1
                  ::nStatus := 0
                  ::nError := 1
               else
                  ::oRoot := TXmlNode():New( 6 )
                  ::Read( nh, nStyle )
                  FClose( nh )
               endif
            endif
            EXIT
         DEFAULT
            ::nStatus := 0
            ::nError := 13
      END
   ENDIF

   if ::nStatus = 1
      if empty( ::cHeader ) .AND. lNew .AND. ::oRoot:oChild <> NIL .AND. ::oRoot:oChild:cName == "xml"
         ::cHeader := "<?xml "+::oRoot:oChild:cData+"?>"
      endif
      ::oIterator := TXmlIterator():New( ::oRoot )
   else
      ::nStatus := 0
      ::nError := 4
   endif

RETURN Self


UTILITY STATIC function TXmlDocument_FindFirst( cName, cAttrib, cValue, cData) ; local Self AS CLASS TXmlDocument := QSelf() AS CLASS TXmlDocument

Local oNode

   if ::nStatus = 1
      ::oIterator:lRegex := .F.
      oNode := ::oIterator:Find( cName, cAttrib, cValue, cData )
   endif

RETURN oNode



UTILITY STATIC function TXmlDocument_FindFirstRegex( cName, cAttrib, cValue, cData) ; local Self AS CLASS TXmlDocument := QSelf() AS CLASS TXmlDocument

Local oNode

   if ::nStatus = 1
      ::oIterator:lRegex := .T.
      oNode := ::oIterator:Find( cName, cAttrib, cValue, cData )
   endif

RETURN oNode


UTILITY STATIC function TXmlDocument_GetContext() ; local Self AS CLASS TXmlDocument := QSelf() AS CLASS TXmlDocument

   LOCAL oDoc

   if ::nStatus = 1
      oDoc := TXmlDocument():New()
      oDoc:oRoot := ::oIterator:GetNode()
   endif

RETURN oDoc


UTILITY STATIC function TXmlDocument_Write( xFile, nStyle) ; local Self AS CLASS TXmlDocument := QSelf() AS CLASS TXmlDocument

Local fHandle, cHeader, lOK := .F., cFileName

  if empty( xFile ) .OR. ::nStatus <> 1
     return .F.
  endif

  if nStyle = NIL
     nStyle := 1
  endif

  cHeader := ::cHeader

  if nStyle <> 16  .AND. ! empty( cHeader )
     cHeader += hb_osnewline()
  endif


  if hb_isString( xFile )

     cFilename := alltrim( xFile )

     if ! "." in cFileName .AND. ! ".xml" in lower( cFileName )
        cFileName += ".xml"
     endif

     fHandle := FCreate( cFileName )

     lOK := ( FError() == 0 )

  elseif hb_isNumeric( xFile )
     fHandle := xFile
     lOK := .T.
  else
     return .F.
  endif

  if lOK
     if ! empty( ::cSignature )
        FWrite( fHandle, ::cSignature, len( ::cSignature ) )
        lOK := ( FError() == 0 )
     endif
     if lOK .AND. ! empty( cHeader )
        FWrite( fHandle, cHeader, len(cHeader) )
        lOK := ( FError() == 0 )
     endif
     if lOK
        ::oRoot:Write( fHandle, nStyle )
        lOK := ( FError() == 0 )
     endif
     if hb_isString( xFile )
        FClose(fHandle)
     endif
  endif

  if ! lOK
     ::nStatus := 0
     ::nError  := 1
  endif

Return lOK


UTILITY STATIC function TXmlDocument_Read( xData, nStyle) ; local Self AS CLASS TXmlDocument := QSelf() AS CLASS TXmlDocument



Local cBOM

 if ValType( xData ) == "N"
    FSeek( xData, 0, 0 )
    cBOM := FReadStr( xData, 3 )
    FSeek( xData, 0, 0 )
 elseif valtype( xData ) == "C"
    cBOM := Left(xData,3)
 else
    ::nStatus  := 5
    ::nError   := 4
    Return Self
 endif








 if Asc( cBOM[1] ) = 239 .AND. Asc( cBOM[2] ) = 187 .AND. Asc( cBOM[3] ) = 191
    ::cSignature := cBOM
 endif

 ::nStatus := HBXML_DATAREAD( Self, xData, nStyle )

Return Self
