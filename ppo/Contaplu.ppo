#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 39 ".\Prg\Contaplu.prg"
static cDiario
static cCuenta
static cSubCuenta
static cEmpresa

static aLenSubCuenta       := {}

static cProyecto

static dFechaInicioEmpresa
static dFechaFinEmpresa

static lOpenDiario         := .F.
static lOpenSubCuenta      := .F.

static aSerie              := {"A","B","C","D","E","F","G","H","I","J","K","M","N","O","P","O","R","S","T","U","V","W","X","Y","Z"}



Function ChkRuta( cRutaConta, lMessage )

   local lReturn     := .F.

   IIF( lMessage == nil, lMessage := .F., ) ;

   if Empty( cRutaConta )
      Return .F.
   end

   cRutaConta        := cPath( cRutaConta )



   if file( cRutaConta + "\CONTAPLW.EXE" )      .OR.  file( cRutaConta + "\CONTAPLU.EXE" )      .OR.  file( cRutaConta + "\CONTABILIDAD.EXE" )

      lReturn := .T.

   else

      if lMessage
         msgStop( "Ruta invalida, fichero Contaplus no encontrado" + Chr(13)+Chr(10) + "en ruta " + cRutaConta + "." )
      end

      lReturn        := .F.

   end

RETURN lReturn







FUNCTION ChkFecha( cRuta, cCodEmp, dFecha, lMessage, oTree, cText )

   local lClose      := .F.
   local lValidFecha := .T.

   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;
   IIF( cCodEmp == nil, cCodEmp := cEmpCnt(), ) ;
   IIF( lMessage == nil, lMessage := .F., ) ;
   IIF( cText == nil, cText := Space( 1 ), ) ;

   if Empty( cRuta )
      return .F.
   end

   if ( Empty( dFecha ) .OR. Empty( cRuta ) )
      return .T.
   end

   if Empty( cEmpresa )
      cEmpresa       := OpnEmpresa( cRuta, lMessage )
      if Empty( cEmpresa )
         return .F.
      else
         lClose      := .T.
      end
   end

   if ( cEmpresa )->( dbSeek( cCodEmp ) )

      dFechaInicioEmpresa  := ( cEmpresa )->FechaIni
      dFechaFinEmpresa     := ( cEmpresa )->FechaFin

   else

      lValidFecha          := .F.
      cText                += "Empresa no encontrada"

      if lMessage
         msgStop( cText )
      end

   end

   if lClose
      CloEmpresa()
   end

   if lValidFecha

      if ( dFecha >= dFechaInicioEmpresa .AND. dFecha <= dFechaFinEmpresa )

         lValidFecha       := .T.

      else

         cText             += "fecha del documento " + Dtoc( dFecha ) + " fuera de intervalo de empresa " + cCodEmp + " desde " + Dtoc( dFechaInicioEmpresa ) + " hasta " + Dtoc( dFechaFinEmpresa ) + "."

         if lMessage
            msgStop( cText )
         end

         if !Empty( oTree )
            oTree:Select( oTree:Add( Alltrim( cText ) ) )
         end

         lValidFecha       := .F.

      end

   end

RETURN ( lValidFecha )







FUNCTION ChkEmpresaContaplus( cRuta, cCodEmp, oGetEmp, lMessage )

   local lClose      := .F.
   local lEmpresa    := .T.

   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;
   IIF( cCodEmp == nil, cCodEmp := cEmpCnt(), ) ;
   IIF( lMessage == nil, lMessage := .F., ) ;

   if Empty( cRuta )
      Return ( .F. )
   end

   if Empty( cCodEmp )
      if !Empty( oGetEmp )
         oGetEmp:cText( "" )
      end
      Return ( .F. )
   end

   if Empty( cEmpresa )
      cEmpresa       := OpnEmpresa( cRuta, lMessage )
      if Empty( cEmpresa )
         Return ( .F. )
      else
         lClose      := .T.
      end
   end

   lEmpresa          := ( cEmpresa )->( dbSeek( cCodEmp ) )
   if lEmpresa
      if !Empty( oGetEmp )
         oGetEmp:cText( ( cEmpresa )->Nombre )
      end
   else
      if lMessage
         msgStop( "Empresa no encontrada" )
      end
   end

   if lClose
      CloEmpresa()
   end

Return ( lEmpresa )



FUNCTION cEmpresaContaplus( cRuta, cCodEmp )

   local lClose      := .F.
   local cNbrEmp     := ""

   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;
   IIF( cCodEmp == nil, cCodEmp := cEmpCnt(), ) ;

   if Empty( cRuta )
      Return ( cNbrEmp )
   end

   if Empty( cCodEmp )
      Return ( cNbrEmp )
   end

   if Empty( cEmpresa )
      cEmpresa       := OpnEmpresa( cRuta, .F. )
      if Empty( cEmpresa )
         Return ( cNbrEmp )
      else
         lClose      := .T.
      end
   end

   if ( cEmpresa )->( dbSeek( cCodEmp ) )
      cNbrEmp        := ( cEmpresa )->Nombre
   else
      cNbrEmp        := ""
   end

   if lClose
      CloEmpresa()
   end

RETURN ( cNbrEmp )



FUNCTION BrwEmpresaContaplus( cRuta, oGetEmp )

   local oDlg
    local oBrw
    local oGet1
    local cGet1
   local lClose      := .F.
    local oCbxOrd
   local aCbxOrd     := { "Código", "Empresa" }
   local cCbxOrd     := "Código"

   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;

   if Empty( cRuta )
      return .F.
   end

   if Empty( cEmpresa )
      cEmpresa       := OpnEmpresa( cRuta, .T. )
      if Empty( cEmpresa )
         return .F.
      else
         lClose      := .T.
      end
   end

   ( cEmpresa )->( dbGoTop() )

   oDlg = TDialog():New(,,,, "Empresas de contaplus ®", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F., )






   oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,, {||    ( OrdClearScope( oBrw, cEmpresa ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, cEmpresa ) ) }, .F., .F.,,,,,, nil, "Find",, )





   oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,,,,,, .F.,,,,,, )

   oBrw                 := IXBrowse():New( oDlg )

   oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
   oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

   oBrw:cAlias          := cEmpresa
   oBrw:nMarqueeStyle   := 5
   oBrw:cName           := "Browse.Empresas contaplus"

      with object ( oBrw:AddCol() )
         :cHeader       := "Código"
         :cSortOrder    := "Cod"
         :bEditValue    := {|| ( cEmpresa )->Cod }
         :nWidth        := 60
         :bLClickHeader := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader       := "Empresa"
         :cSortOrder    := "Nombre"
         :bEditValue    := {|| ( cEmpresa )->Nombre }
         :nWidth        := 420
         :bLClickHeader := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

   oBrw:CreateFromResource( 105 )

   oBrw:bLDblClick      := {|| oDlg:end( 1 ) }
   oBrw:bKeyDown        := {|nKey, nFalg| if( nKey == 13, oDlg:end( 1 ), ) }





   TButton():ReDefine( 500, {||( nil )}, oDlg,,, .F., {||     ( .F. )},,, .F. )





   TButton():ReDefine( 501, {||( nil )}, oDlg,,, .F., {||     ( .F. )},,, .F. )




   TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )





   TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )
   oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if oDlg:nResult == 1 .AND. !Empty( oGetEmp )
      oGetEmp:cText( ( cEmpresa )->Cod )
   end

   if lClose
      CloEmpresa()
   end

RETURN ( nil )






Function nLenSubCta( cRuta, cCodEmp, lMensaje )

Return ( nLenCuentaContaplus( cRuta, cCodEmp, lMensaje ) + 3 )



FUNCTION nLenCuentaContaplus( cRuta, cCodEmp, lMensaje )

   local nLenCuentaContaplus  := nLenSubcuentaContaplus( cRuta, cCodEmp, lMensaje )

   if nLenCuentaContaplus <> 0
      nLenCuentaContaplus -= 3
   end

Return ( nLenCuentaContaplus )



FUNCTION nLenSubcuentaContaplus( cRuta, cCodEmp, lMensaje )

   local lClose      := .F.
   local nReturn     := 0
   local nPosition   := aScan( aLenSubCuenta, {|a| a[ 1 ] == cCodEmp } )

   if nPosition <> 0
      Return ( aLenSubCuenta[ nPosition, 2 ] )
   end

   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;
   IIF( cCodEmp == nil, cCodEmp := cEmpCnt(), ) ;
   IIF( lMensaje == nil, lMensaje := .F., ) ;

   if Empty( cRuta )
      if lMensaje
         msgAlert( "Ruta vacia" )
      end
      Return ( nReturn )
   end

   if Empty( cEmpresa )
      cEmpresa       := OpnEmpresa( cRuta, lMensaje )
      if Empty( cEmpresa )
         Return ( nReturn )
      else
         lClose      := .T.
      end
   end

   if ( cEmpresa )->( dbSeek( cCodEmp ) )





      nReturn        := ( cEmpresa )->Nivel





      aAdd( aLenSubCuenta, { cCodEmp, nReturn } )

   else

      if lMensaje
         MsgStop( "Empresa " + cCodEmp + " no encontrada." )
      end

   end

   if lClose
      CloEmpresa()
   end

Return ( nReturn )







FUNCTION ChkCta( cCodCuenta, oGetCta, lMessage, cRuta, cCodEmp )

    local cArea
   local lOld        := .T.
   local lReturn     := .T.

   IIF( lMessage == nil, lMessage := .F., ) ;
   IIF( cCodEmp == nil, cCodEmp := cEmpCnt( "A" ), ) ;
   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;

   if Empty( cRuta )
      Return .F.
   end

   cRuta             := cPath( cRuta )

   if Empty( cCodCuenta )
      Return .T.
   end

   if OpnCta( cRuta, cCodEmp, @cArea, lMessage )

      if ( cArea )->( dbSeek( cCodCuenta ) )

         if oGetCta <> nil

            do case
               case oGetCta:ClassName() == "TGET" .OR. oGetCta:ClassName() == "TGETHLP"
                  oGetCta:cText( ( cArea )->Descrip )
               case oGetCta:ClassName() == "TSAY"
                  oGetCta:SetText( ( cArea )->Descrip )
            end

         end

      else

         if lMessage
            msgStop( "Cuenta no encontrada" )
         end

            lReturn = .F.

      end

      ( cArea )->( dbCloseArea() )

   end

RETURN lReturn



FUNCTION ChkSubCta( cRuta, cCodEmp, cCodSubCta, oGetCta, lMessage, lEmpty )

   local lClose      := .F.
   local lReturn     := .T.

   IIF( cCodEmp == nil, cCodEmp := cEmpCnt( "A" ), ) ;
   IIF( lMessage == nil, lMessage := .F., ) ;
   IIF( lEmpty == nil, lEmpty := .T., ) ;
   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;

   if Empty( cRuta )
      Return .F.
   end

   cRuta             := cPath( cRuta )
   cCodSubCta        := Padr( cCodSubCta, 12 )

   if ( Empty( cCodSubCta ) .OR. Empty( cRuta ) ) .AND. lEmpty
      return .T.
   end

   if Empty( cSubCuenta )
      cSubCuenta     := OpnSubCuenta( cRuta, cCodEmp, lMessage )
      if Empty( cSubCuenta )
         return .F.
      else
         lClose      := .T.
      end
   end

   if ( cSubCuenta )->( dbSeek( cCodSubCta ) )

      if !Empty( oGetCta )
         oGetCta:cText( ( cSubCuenta )->Titulo )
      end

   else

      if lMessage
         msgStop( "Subcuenta : " + cCodSubCta + Chr(13)+Chr(10) + "no encontrada", "Contaplus" )
      end

      lReturn        := .F.

   end

   if lClose
      CloSubCuenta()
   end

RETURN ( lReturn )



FUNCTION BrwChkCta( oCodCta, oGetCta, cRuta, cCodEmp )

    local oDlg
    local oBrw
    local oGet1
    local cGet1
    local oCbxOrd
    local cArea
   local aCbxOrd     := { "Código", "Cuenta" }
   local cCbxOrd     := "Código"

   IIF( cCodEmp == nil, cCodEmp := cEmpCnt( "A" ), ) ;
   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;

   if Empty( cRuta )
      Return .F.
   end

   cRuta             := cPath( cRuta )

   if OpnCta( cRuta, cCodEmp, @cArea )

      ( cArea )->( dbSetFilter( {|| !Empty( Field->Cta ) }, "!Empty( Field->Cta )" ) )
      ( cArea )->( dbGoTop() )

      oDlg = TDialog():New(,,,, "Cuentas de contaplus ®", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F., )






        oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,, {||    ( OrdClearScope( oBrw, cArea ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, cArea ) ) }, .F., .F.,,,,,, nil, "FIND",, )





        oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,,,,,, .F.,,,,,, )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias          := cArea
      oBrw:nMarqueeStyle   := 5
      oBrw:cName           := "Browse.Cuenta contaplus"

         with object ( oBrw:AddCol() )
            :cHeader       := "Código"
            :cSortOrder    := "Cta"
            :bEditValue    := {|| ( cArea )->Cta }
            :nWidth        := 60
            :bLClickHeader := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
         end

         with object ( oBrw:AddCol() )
            :cHeader       := "Cuenta"
            :cSortOrder    := "Descrip"
            :bEditValue    := {|| ( cArea )->Descrip }
            :nWidth        := 420
            :bLClickHeader := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
         end

      oBrw:CreateFromResource( 105 )

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }
      oBrw:bKeyDown        := {|nKey, nFalg| if( nKey == 13, oDlg:end( 1 ), ) }





      TButton():ReDefine( 500, {||( nil )}, oDlg,,, .F., {||     ( .F. )},,, .F. )





        TButton():ReDefine( 501, {||( nil )}, oDlg,,, .F., {||     ( .F. )},,, .F. )




      TButton():ReDefine( 1, {||( oDlg:end(1) )}, oDlg,,, .F.,,,, .F. )





        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

      oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )
      oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )

      oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

      if oDlg:nResult == 1

         oCodCta:cText( ( cArea )->Cta )

         do case
            case oGetCta:ClassName() == "TGET" .OR. oGetCta:ClassName() == "TGETHLP"
               oGetCta:cText( ( cArea )->Descrip )
            case oGetCta:ClassName() == "TSAY"
               oGetCta:SetText( ( cArea )->Descrip )
         end

      end

        ( cArea )->( dbCloseArea() )

   end

    oCodCta:setFocus()

RETURN ( nil )



FUNCTION BrwChkSubCta( oCodCta, oGetCta, cRuta, cCodEmp )

    local oDlg
    local oBrw
    local oGet1
    local cGet1
    local oCbxOrd
   local cArea
   local cCbxOrd     := "Cuenta"

   IIF( cCodEmp == nil, cCodEmp := cEmpCnt( "A" ), ) ;
   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;

   if Empty( cRuta )
      Return .F.
   end

   cRuta             := cPath( cRuta )

   if OpenSubCuenta( cRuta, cCodEmp, @cArea, .F. )

        ( cArea )->( dbGoTop() )

      oDlg = TDialog():New(,,,, "Subcuentas de contaplus ®", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F., )





            oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,,,,,,,, .F.,, {|nKey,nFlags,Self| AutoSeek( nKey, nFlags, Self, oBrw, cArea ) }, .F., .F.,,,,,, nil, "FIND",, )





            oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, { "Cuenta", "Nombre" }, oDlg,,,,,,, .F.,,,,,, )

















         oBrw                 := IXBrowse():New( oDlg )

         oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
         oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

         oBrw:cAlias          := cArea
         oBrw:nMarqueeStyle   := 5
         oBrw:cName           := "Browse.Cuentas de contaplus"

         with object ( oBrw:AddCol() )
            :cHeader          := "Cuenta"
            :cSortOrder       := "Cods"
            :bEditValue       := {|| ( cArea )->Cod }
            :nWidth           := 80
            :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
         end

         with object ( oBrw:AddCol() )
            :cHeader          := "Nombre"
            :cSortOrder       := "Tits"
            :bEditValue       := {|| ( cArea )->Titulo }
            :nWidth           := 400
            :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
         end

         oBrw:bLDblClick      := {|| oDlg:end( 1 ) }
         oBrw:bRClicked       := {| nRow, nCol, nFlags | oBrw:RButtonDown( nRow, nCol, nFlags ) }

         oBrw:CreateFromResource( 105 )





         TButton():ReDefine( 500, {||( nil )}, oDlg,,, .F., {||     ( .F. )},,, .F. )





         TButton():ReDefine( 501, {||( nil )}, oDlg,,, .F., {||     ( .F. )},,, .F. )




         TButton():ReDefine( 1, {||( oDlg:end(1) )}, oDlg,,, .F.,,,, .F. )





            TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

         oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )
         oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )

         oDlg:bStart := {|| oBrw:Load() }

      oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

      if oDlg:nResult == 1

         oCodCta:cText( ( cArea )->Cod )

         do case
            case oGetCta:ClassName() == "TGET" .OR. oGetCta:ClassName() == "TGETHLP"
               oGetCta:cText( ( cArea )->Titulo )
            case oGetCta:ClassName() == "TSAY"
               oGetCta:SetText( ( cArea )->Titulo )
         end

      end

        ( cArea )->( dbCloseArea() )

   else

      Return .F.

   end

    oCodCta:setFocus()

Return ( nil )







FUNCTION MkSubCta( oGetSubCta, aTemp, oGet, cRuta, cCodEmp, oGetDebe, oGetHaber, oGetSaldo )

   local n
   local cArea
   local nSumaDB     := 0
   local nSumaHB     := 0
   local cTitCta     := ""
   local cCodSubCta  := oGetSubCta:VarGet()
   local aEmpProced  := {}

   IIF( cCodEmp == nil, cCodEmp := cEmpCnt( "A" ), ) ;
   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;

   if Empty( cRuta )
      Return .F.
   end

   cRuta             := cPath( cRuta )

   cCodSubCta        := PntReplace( oGetSubCta, "0", nLenSubCta() )
   cCodSubCta        := PadR( cCodSubCta, nLenSubCta() )
   cCodSubCta        := AllTrim( cCodSubCta )








   if !Empty( cCodSubCta )

      for n := 1 to len( aSerie )

         cCodEmp     := cCodEmpCnt( aSerie[ n ] )

         if !Empty( cCodEmp ) .AND. aScan( aEmpProced, cCodEmp ) == 0

            if OpenSubCuenta( cRuta, cCodEmp, @cArea )

               if !( cArea )->( dbSeek( cCodSubCta, .T. ) ) .AND. !Empty( aTemp )



                  if ApoloMsgNoYes( "Subcuenta : " + Rtrim( cCodSubCta ) + " no existe en empresa : " + cCodEmp + Chr(13)+Chr(10) +  "¿ Desea crearla ?" , "Contabilidad" )

                     aSize( aTemp, 10 )

                     ( cArea )->( DbAppend() )
                     ( cArea )->Cod       := cCodSubCta

                     if ( cArea )->( FieldPos( "IDNIF" ) ) <> 0
                        ( cArea )->IdNif     := 1
                     end

                     if aTemp[ 2 ] <> nil
                        ( cArea )->Titulo    := aTemp[ 2 ]
                     end

                     if aTemp[ 3 ] <> NIL
                        ( cArea )->Nif       := aTemp[ 3 ]
                     end

                     if aTemp[ 4 ] <> NIL
                        ( cArea )->Domicilio := aTemp[ 4 ]
                     end

                     if aTemp[ 5 ] <> NIL
                        ( cArea )->Poblacion := aTemp[ 5 ]
                     end

                     if aTemp[ 6 ] <> NIL
                        ( cArea )->Provincia := aTemp[ 6 ]
                     end

                     if aTemp[ 7 ] <> NIL
                        ( cArea )->CodPostal := aTemp[ 7 ]
                     end

                     if aTemp[ 8 ] <> NIL
                        ( cArea )->Telef01   := aTemp[ 8 ]
                     end

                     if aTemp[ 9 ] <> NIL
                        ( cArea )->Fax01     := aTemp[ 9 ]
                     end

                     if aTemp[ 10 ] <> nil
                        ( cArea )->eMail     := aTemp[ 10 ]
                     end

                     ( cArea )->( DbCommit() )

                     if Empty( cTitCta )
                        cTitCta              := ( cArea )->Titulo
                     end





                  end

               else

                  if Empty( cTitCta )
                     cTitCta                 := ( cArea )->Titulo
                  end
                  nSumaDB                    += ( cArea )->SumaDBEU
                  nSumaHB                    += ( cArea )->SumaHBEU

               end

               ( cArea )->( dbCloseArea() )

               aAdd( aEmpProced, cCodEmp )

            end

         end

      next

   end

   if ValType( oGet ) == "O"
      do case
         case oGet:ClassName() == "TGET" .OR. oGet:ClassName() == "TGETHLP"
            oGet:cText( cTitCta )
         case oGet:ClassName() == "TSAY"
            oGet:SetText( cTitCta )
      end
   end

   if ValType( oGetDebe ) == "O"
      oGetDebe:cText( nSumaDB )
   elseif ValType( oGetDebe ) == "N"
      oGetDebe := nSumaDB
   end

   if ValType( oGetHaber ) == "O"
      oGetHaber:cText( nSumaHB )
   elseif ValType( oGetHaber ) == "N"
      oGetHaber := nSumaHB
   end

   if ValType( oGetSaldo ) == "O"
      oGetSaldo:cText( nSumaDB - nSumaHB )
   end

Return .T.



FUNCTION LoadSubCta( cCodSubCta, cRuta, dbfTmp )

   local n
   local cCodEmp
   local dbfDiario
   local aEmpProced  := {}

   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;

   if Empty( cRuta )
      Return .F.
   end

   cRuta             := cPath( cRuta )

   ( dbfTmp )->( __dbZap() )

   if Empty( AllTrim( cCodSubCta ) )
      return .T.
   end

   for n := 1 to len( aSerie )

      cCodEmp        := cCodEmpCnt( aSerie[ n ] )

      if !Empty( cCodEmp ) .AND. aScan( aEmpProced, cCodEmp ) == 0

         dbfDiario   := OpnDiario( cRuta, cCodEmp, .F. )
         if dbfDiario <> nil

            ( dbfDiario )->( OrdSetFocus( "SubCd" ) )

            if ( dbfDiario )->( dbSeek( cCodSubCta ) )

               while ( dbfDiario )->SubCta == cCodSubCta .AND. !( dbfDiario )->( eof() )

                  ( dbfTmp )->( dbAppend() )

                  ( dbfTmp )->nAsiento  := ( dbfDiario )->Asien
                  ( dbfTmp )->dFecha    := ( dbfDiario )->Fecha
                  ( dbfTmp )->cConcepto := ( dbfDiario )->Concepto
                  ( dbfTmp )->nDebe     := ( dbfDiario )->EuroDebe
                  ( dbfTmp )->nHaber    := ( dbfDiario )->EuroHaber
                  ( dbfTmp )->cDeparta  := ( dbfDiario )->Departa + "." + ( dbfDiario )->Clave
                  ( dbfTmp )->nFactura  := ( dbfDiario )->Factura
                  ( dbfTmp )->nBase     := ( dbfDiario )->BaseEuro
                  ( dbfTmp )->nIva      := ( dbfDiario )->Iva

                  ( dbfDiario )->( dbSkip() )

               end

            end

         end

         ( dbfDiario )->( dbCloseArea() )

         aAdd( aEmpProced, cCodEmp )

      end

   next

   ( dbfTmp )->( dbGoTop() )

RETURN .T.




FUNCTION RetCtaEsp( nCuenta, cRuta, cCodEmp, lMessage )

    local cArea
   local oBlock
    local cCtaEsp        := ""

    IIF( nCuenta == nil, nCuenta := 1, ) ;
   IIF( cCodEmp == nil, cCodEmp := cEmpCnt( "A" ), ) ;
   IIF( lMessage == nil, lMessage := .F., ) ;
   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;

   if Empty( cRuta )
      Return ( cCtaEsp )
   end

   cRuta             := cPath( cRuta )

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   do case
   case File( cRuta + "EMP" + cCodEmp + "\TCTA" + cCodEmp + ".DBF" )

      dbUseArea( .T., ( cLocalDriver() ), ( cRuta + "EMP" + cCodEmp + "\TCTA" + cCodEmp + ".DBF" ), ( cCheckArea( "CUENTA", @cArea ) ), if(.F. .OR. .F., !.F., NIL), .F.,, )

   case File( cRuta + "EMP" + cCodEmp + "\TCTA.DBF" )

      dbUseArea( .T., ( cLocalDriver() ), ( cRuta + "EMP" + cCodEmp + "\TCTA.DBF" ), ( cCheckArea( "CUENTA", @cArea ) ), if(.F. .OR. .F., !.F., NIL), .F.,, )

   end

   ( cArea )->( dbGoTo( nCuenta ) )

   cCtaEsp           := Rtrim( ( cArea )->Cuenta )

    ( cArea )->( dbCloseArea() )

   RECOVER

      if lMessage
         MsgStop( "Imposible acceder a fichero de empresas de Contaplus ®", "Abriendo fichero de cuentas especiales" )
      end

   end

   ErrorBlock( oBlock )

RETURN cCtaEsp



Function lOpenDiario()

Return ( lOpenDiario )



Function OpenDiario( cRuta, cCodEmp, lMessage )

   local oError
   local oBlock

   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;
   IIF( cCodEmp == nil, cCodEmp := cEmpCnt( "A" ), ) ;
   IIF( lMessage == nil, lMessage := .F., ) ;

   if lOpenDiario
      Return ( lOpenDiario )
   end

   if Empty( cRuta )
      if lMessage
         MsgStop( "Ruta de contaplus ® no valida" )
      end
      return .F.
   end

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      lOpenDiario    := .T.
      cRuta          := cPath( cRuta )

      cDiario        := OpnDiario( cRuta, cCodEmp, lMessage )
      if Empty( cDiario )
         lOpenDiario := .F.
      end

      cCuenta        := OpnBalance( cRuta, cCodEmp, lMessage )
      if Empty( cCuenta )
         lOpenDiario := .F.
      end

      cSubCuenta     := OpnSubCuenta( cRuta, cCodEmp, lMessage )
      if Empty( cSubCuenta )
         lOpenDiario := .F.
      end

      cEmpresa       := OpnEmpresa( cRuta, lMessage )
      if Empty( cEmpresa )
         lOpenDiario := .F.
      end

   RECOVER USING oError

      lOpenDiario    := .F.

      msgStop( "Imposible abrir todas las bases de datos de contaplus" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

Return ( lOpenDiario )



FUNCTION CloseDiario()

   if !Empty( cDiario )
      ( cDiario    )->( dbCloseArea() )
   end

   if !Empty( cCuenta )
      ( cCuenta    )->( dbCloseArea() )
   end

   if !Empty( cSubCuenta )
      ( cSubCuenta )->( dbCloseArea() )
   end

   if !Empty( cEmpresa )
      ( cEmpresa )->( dbCloseArea() )
   end

   cDiario           := nil
   cCuenta           := nil
   cSubCuenta        := nil
   cEmpresa          := nil

   lOpenDiario       := .F.

Return ( lOpenDiario )




Function RetLastAsi()

   local nRecno
   local nLastAsi    := 0

   if !Empty( cDiario ) .AND. ( cDiario )->( Used() )

      nRecno         := ( cDiario )->( Recno() )

      ( cDiario )->( dbGoBottom() )

      nLastAsi       := ( cDiario )->Asien + 1

      ( cDiario )->( dbGoTo( nRecno ) )

   end

Return ( nLastAsi )


























FUNCTION MkAsiento(     Asien, cCodDiv,    Fecha,    SubCta,    Contra, nImporteDebe,    Concepto, nImporteHaber,    Factura,    BaseImpo, IVA,    RecEquiv,    Documento,    Departa,    Clave, lRectificativa,    nCasado,    tCasado, lSimula, cTerNif, cTerNom )

   local aTemp
   local cSerie            := "A"
   local oError
   local oBlock
   local nImporte

   IIF( cCodDiv == nil, cCodDiv := cDivEmp(), ) ;
   IIF( lRectificativa == nil, lRectificativa := .F., ) ;
   IIF( lSimula == nil, lSimula := .T., ) ;
   IIF( nImporteDebe == nil, nImporteDebe := 0, ) ;
   IIF( nImporteHaber == nil, nImporteHaber := 0, ) ;

   if ValType( Factura ) == "C"
      cSerie               := SubStr( Factura, 1, 1 )
      Factura              := SubStr( Factura, 2, 9 )
   end

   if ValType( Factura ) == "N"
      Factura              := Alltrim( Str( Factura ) )
   end

   if Factura <> nil
      Factura              := Val( SubStr( Factura, -7 ) )
   end





   if lBancas() .AND. ( nImporteDebe == 0  ) .AND. ( nImporteHaber == 0 )
      return ( aTemp )
   end

   oBlock                  := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE





   if !uFieldEmpresa( "lAptNeg" ) .AND. ( nImporteDebe < 0 .OR. nImporteHaber < 0 )
      nImporte             := abs( nImporteDebe )
      nImporteDebe         := abs( nImporteHaber )
      nImporteHaber        := nImporte
   end





   aTemp                   := dbBlankRec( cDiario )

   aTemp[ ( cDiario )->( FieldPos( "ASIEN" ) ) ]         := If ( Asien    <> NIL, Asien,      RetLastAsi() )
   aTemp[ ( cDiario )->( FieldPos( "FECHA" ) ) ]         := If ( Fecha    <> NIL, Fecha,      aTemp[ ( cDiario )->( FieldPos( "FECHA" ) ) ] )

   if ( cDiario )->( FieldPos( "FECHA_OP" ) ) <> 0
      aTemp[ ( cDiario )->( FieldPos( "FECHA_OP" ) ) ]   := If ( Fecha    <> NIL, Fecha,      aTemp[ ( cDiario )->( FieldPos( "FECHA_OP" ) ) ] )
   end

   if ( cDiario )->( FieldPos( "FECHA_EX" ) ) <> 0
      aTemp[ ( cDiario )->( FieldPos( "FECHA_EX" ) ) ]   := If ( Fecha    <> NIL, Fecha,      aTemp[ ( cDiario )->( FieldPos( "FECHA_EX" ) ) ] )
   end

   aTemp[ ( cDiario )->( FieldPos( "SERIE" ) ) ]         := If ( cSerie   <> NIL, cSerie,     aTemp[ ( cDiario )->( FieldPos( "SERIE" ) ) ] )
   aTemp[ ( cDiario )->( FieldPos( "FACTURA" ) ) ]       := If ( Factura  <> NIL, Factura,    aTemp[ ( cDiario )->( FieldPos( "FACTURA" ) ) ] )


      aTemp[ ( cDiario )->( FieldPos( "BASEEURO" ) ) ]   := If ( BaseImpo <> NIL, BaseImpo,   aTemp[ ( cDiario )->( FieldPos( "BASEEURO" ) ) ] )





      aTemp[ ( cDiario )->( FieldPos( "EURODEBE" ) ) ]   := If ( nImporteDebe  <> NIL, nImporteDebe,    aTemp[ ( cDiario )->( FieldPos( "EURODEBE" ) ) ] )





      aTemp[ ( cDiario )->( FieldPos( "EUROHABER" ) ) ]  := If ( nImporteHaber <> NIL, nImporteHaber,   aTemp[ ( cDiario )->( FieldPos( "EUROHABER" ) ) ] )




   aTemp[ ( cDiario )->( FieldPos( "SUBCTA" ) ) ]        := If ( SubCta   <> NIL, SubCta,     aTemp[ ( cDiario )->( FieldPos( "SUBCTA" ) ) ] )
   aTemp[ ( cDiario )->( FieldPos( "CONTRA" ) ) ]        := If ( Contra   <> NIL, Contra,     aTemp[ ( cDiario )->( FieldPos( "CONTRA" ) ) ] )

   aTemp[ ( cDiario )->( FieldPos( "CONCEPTO" ) ) ]      := If ( Concepto <> NIL, Concepto,   aTemp[ ( cDiario )->( FieldPos( "CONCEPTO" ) ) ] )

   aTemp[ ( cDiario )->( FieldPos( "IVA" ) )       ]     := If ( IVA      <> NIL, IVA,        aTemp[ ( cDiario )->( FieldPos( "IVA" ) )        ] )
   aTemp[ ( cDiario )->( FieldPos( "RECEQUIV" ) )  ]     := If ( RecEquiv <> NIL, RecEquiv,   aTemp[ ( cDiario )->( FieldPos( "RECEQUIV" ) )   ] )
   aTemp[ ( cDiario )->( FieldPos( "DOCUMENTO" ) ) ]     := If ( Documento<> NIL, Documento,  aTemp[ ( cDiario )->( FieldPos( "DOCUMENTO" ) )  ] )
   aTemp[ ( cDiario )->( FieldPos( "DEPARTA" ) )   ]     := If ( Departa  <> NIL, Departa,    aTemp[ ( cDiario )->( FieldPos( "DEPARTA" ) )    ] )
   aTemp[ ( cDiario )->( FieldPos( "DEPARTA" ) )   ]     := If ( Departa  <> NIL, Departa,    aTemp[ ( cDiario )->( FieldPos( "DEPARTA" ) )    ] )
   aTemp[ ( cDiario )->( FieldPos( "CLAVE" ) )     ]     := If ( Clave    <> NIL, Clave,      aTemp[ ( cDiario )->( FieldPos( "CLAVE" ) )      ] )
   aTemp[ ( cDiario )->( FieldPos( "NCASADO" ) )   ]     := If ( nCasado  <> NIL, nCasado,    aTemp[ ( cDiario )->( FieldPos( "NCASADO" ) )    ] )
   aTemp[ ( cDiario )->( FieldPos( "TCASADO" ) )   ]     := If ( tCasado  <> NIL, tCasado,    aTemp[ ( cDiario )->( FieldPos( "TCASADO" ) )    ] )

   if ( cDiario )->( FieldPos( "TERIDNIF" ) ) <> 0
      aTemp[ ( cDiario )->( FieldPos( "TERIDNIF" ) ) ]   := 1
   end

   if ( cDiario )->( FieldPos( "TERNIF" ) ) <> 0
      aTemp[ ( cDiario )->( FieldPos( "TERNIF" ) ) ]     := If ( cTerNif  <> NIL, cTerNif,    aTemp[ ( cDiario )->( FieldPos( "TERNIF" ) ) ] )
   end

   if ( cDiario )->( FieldPos( "TERNOM" ) ) <> 0
      aTemp[ ( cDiario )->( FieldPos( "TERNOM" ) ) ]     := If ( cTerNom  <> NIL, cTerNom,    aTemp[ ( cDiario )->( FieldPos( "TERNOM" ) ) ] )
   end

   if lRectificativa

      aTemp[ ( cDiario )->( FieldPos( "RECTIFICA" ) ) ]  := .T.










   end





   if .T.
      aTemp[ ( cDiario )->( FieldPos( "MONEDAUSO" ) ) ] := "2"
   else
      aTemp[ ( cDiario )->( FieldPos( "MONEDAUSO" ) ) ] := "1"
   end

   if !lSimula
      WriteAsiento( aTemp, cCodDiv )
   end

   RECOVER USING oError

      msgStop( "Error al realizar apunte contable." + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

RETURN ( aTemp )



Function WriteAsiento( aTemp, cCodDiv, lMessage )

   local cMes
   local nFld
   local nVal
   local oBlock
   local oError

   IIF( lMessage == nil, lMessage := .F., ) ;

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if !Empty( cDiario )

      WinGather( aTemp, , cDiario, , 1, , .F. )

      cMes           := Rjust( Month( aTemp[ ( cDiario )->( FieldPos( "FECHA" ) ) ] ), "0", 2 )

      if ( cSubCuenta )->( dbSeek( aTemp[ ( cDiario )->( FieldPos( "SUBCTA" ) ) ] ) ) .AND. ( cSubCuenta )->( dbRLock() )

         ( cSubCuenta )->SUMADBEU               += aTemp[ ( cDiario )->( FieldPos( "EURODEBE" ) ) ]
         ( cSubCuenta )->SUMAHBEU               += aTemp[ ( cDiario )->( FieldPos( "EUROHABER" ) ) ]

         nFld        := ( cSubCuenta )->( FieldPos( "SDB" + cMes + "EU" ) )
         nVal        := ( cSubCuenta )->( FieldGet( nFld ) )
         ( cSubCuenta )->( FieldPut( nFld, nVal + aTemp[ ( cDiario )->( FieldPos( "EURODEBE" ) ) ] ) )

         nFld        := ( cSubCuenta )->( FieldPos( "SHB" + cMes + "EU" ) )
         nVal        := ( cSubCuenta )->( FieldGet( nFld ) )
         ( cSubCuenta )->( FieldPut( nFld, nVal + aTemp[ ( cDiario )->( FieldPos( "EUROHABER" ) ) ] ) )

         nFld        := ( cSubCuenta )->( FieldPos( "NDB" + cMes + "EU" ) )
         nVal        := ( cSubCuenta )->( FieldGet( nFld ) )
         ( cSubCuenta )->( FieldPut( nFld, nVal + aTemp[ ( cDiario )->( FieldPos( "EURODEBE" ) ) ] ) )

         nFld        := ( cSubCuenta )->( FieldPos( "NHB" + cMes + "EU" ) )
         nVal        := ( cSubCuenta )->( FieldGet( nFld ) )
         ( cSubCuenta )->( FieldPut( nFld, nVal + aTemp[ ( cDiario )->( FieldPos( "EUROHABER" ) ) ] ) )

         ( cSubCuenta )->( dbUnLock() )

      else

         if lMessage
            MsgStop( "Subcuenta no encontrada " + aTemp[ ( cDiario )->( FieldPos( "SUBCTA" ) ) ], "Imposible actualizar saldos" )
         end

      end

   end

   RECOVER USING oError

      msgStop( "Error al escribir apunte contable." + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

Return ( nil )



Function aWriteAsiento( aTemp, cCodDiv, lMessage )

   local a

   for each a in aTemp
      WriteAsiento( a, cCodDiv, lMessage )
   next

Return ( nil )







FUNCTION RetCtaVta( cCodArt, dbfArticulo )

   local cCtaVta  := ""

   if ( dbfArticulo )->( dbSeek( cCodArt ) )
      cCtaVta     := Rtrim( ( dbfArticulo )->cCtaVta )
   end

RETURN ( cCtaVta )







FUNCTION RetCtaCom( cCodArt, dbfArticulo )

   local cCtaCom  := ""

   if ( dbfArticulo )->( dbSeek( cCodArt ) )
      cCtaCom     := Rtrim( ( dbfArticulo )->cCtaCom )
   end

RETURN ( cCtaCom )



FUNCTION RetCtaTrn( cCodArt, dbfArticulo )

   local cCtaVta  := cCtaVta()

   IF ( dbfArticulo )->( dbSeek( cCodArt ) )
      cCtaVta     := Rtrim( ( dbfArticulo )->cCtaTrn )
   end

RETURN ( cCtaVta )







FUNCTION RetGrpVta( cCodArt, cRuta, cCodEmp, cAlias, nIva )

   local cCtaVent := Replicate( "0", nLenCuentaContaplus( cRuta, cCodEmp ) )

   if ( cAlias )->( dbSeek( cCodArt ) ) .AND. !Empty( ( cAlias )->GrpVent )
      cCtaVent    := Rtrim( ( cAlias )->GrpVent )
   else
      if nIva <> nil
         cCtaVent := retGrpAsc( nIva, , cRuta, cCodEmp )
      end
   end

RETURN ( cCtaVent )



FUNCTION cCtaConta( oGet, dbfCuentas, oGet2 )

    local lClose     := .F.
    local lValid    := .F.
    local xValor    := oGet:varGet()
   local cRuta    := cRutCnt()
   local cCodEmp  := cEmpCnt( "A" )

   if Empty( xValor )
      Return .T.
   elseif At( ".", xValor ) <> 0
      xValor      := PntReplace( oGet, "0", nLenCuentaContaplus() )
   else
      xValor      := RJustObj( oGet, "0", nLenCuentaContaplus() )
   end

   if dbfCuentas == NIL

      if OpenSubCuenta( cRuta, cCodEmp, @dbfCuentas )
         lClose   := .T.
      else
         return .F.
      end

   end

    IF !(dbfCuentas)->( DbSeek( xValor, .T. ) )

      oGet:cText( ( dbfCuentas )->Cod )

        IF oGet2 <> NIL
         oGet2:cText( ( dbfCuentas )->Titulo )
        end

        lValid    := .T.

    ELSE

        msgStop( "Subcuentas no encontradas" )

    end

    IF lClose
      ( dbfCuentas )->( dbCloseArea() )
    end

RETURN lValid







STATIC FUNCTION OpnEmpresa( cRuta, lMessage )

   local oBlock
   local lOpen       := .T.

   IIF( lMessage == nil, lMessage := .F., ) ;
   IIF( lMessage == nil, lMessage := .F., ) ;
   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;

   if Empty( cRuta )
      return .F.
   end

   cRuta             := cPath( cRuta )

   if !File( cRuta + "Emp\Empresa.Dbf" ) .OR. !File( cRuta + "Emp\Empresa.Cdx" )
      if lMessage
         MsgStop( "Fichero de empresa de Contaplus ® " +  cRuta + "Emp\Empresa.Dbf, no encontrado", "Abriendo fichero de empresas" )
      end
      Return .F.
   end

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )

   BEGIN SEQUENCE

      dbUseArea( .T., ( cLocalDriver() ), ( cRuta + "EMP\EMPRESA.DBF" ), ( cCheckArea( "EMPRESA", @cEmpresa ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !.F. ; ordListClear() ; end ; ordListAdd( ( cRuta + "EMP\EMPRESA.CDX" ) )

   RECOVER

      lOpen          := .F.

   end

   ErrorBlock( oBlock )

Return ( cEmpresa )



Function CloEmpresa()

   if !Empty( cEmpresa )
      ( cEmpresa )->( dbCloseArea() )
   end

   cEmpresa          := nil

Return ( cEmpresa )






STATIC FUNCTION OpnCta( cRuta, cCodEmp, cArea, lMessage )

   local oBlock
   local lOpen       := .T.

   IIF( lMessage == nil, lMessage := .F., ) ;
   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;

   if Empty( cRuta )
      return .F.
   end

   cRuta             := cPath( cRuta )

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )

   BEGIN SEQUENCE


   if File( cRuta + "EMP" + cCodEmp + "\BALAN.DBF" )  .AND. File( cRuta + "EMP" + cCodEmp + "\BALAN.CDX" )





      dbUseArea( .T., ( cLocalDriver() ), ( cRuta + "EMP" + cCodEmp + "\BALAN.DBF" ), ( cCheckArea( "CUENTA", @cArea ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !.F. ; ordListClear() ; end ; ordListAdd( ( cRuta + "EMP" + cCodEmp + "\BALAN.CDX" ) )
        ordSetFocus( "CTA" )

   else

      if lMessage
         msgStop( "Ficheros no encontrados en ruta " + cRuta + " empresa " + cCodEmp, "Abriendo subcuentas" )
      end

      lOpen          := .F.

   end

   if ( cArea )->( RddName() ) == nil .OR. NetErr()

      lOpen          := .F.

   end

   RECOVER

      if lMessage
         msgStop( "Imposible acceder a fichero Contaplus", "Abriendo subcuentas" )
      end
      lOpen          := .F.

   end

   ErrorBlock( oBlock )

Return ( lOpen )






FUNCTION OpenSubCuenta( cRuta, cCodEmp, cArea, lMessage )

   local oBlock
   local lOpen       := .T.

   IIF( lMessage == nil, lMessage := .F., ) ;
   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;

   if Empty( cRuta )
      return .F.
   end

   cRuta             := cPath( cRuta )

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE











      if File( cRuta + "EMP" + cCodEmp + "\SUBCTA.CDX" )





         dbUseArea( .T., ( cLocalDriver() ), ( cRuta + "EMP" + cCodEmp + "\SUBCTA.DBF" ), ( cCheckArea( "CUENTA", @cArea ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
         if !.T. ; ordListClear() ; end ; ordListAdd( ( cRuta + "EMP" + cCodEmp + "\SUBCTA.CDX" ) )

      else

         if lMessage
            msgStop( "Ficheros no encontrados", "Abriendo subcuentas" )
         end

         lOpen       := .F.

      end

      if ( cArea )->( RddName() ) == nil .OR. NetErr()
         if lMessage
            MsgStop( "Imposible acceder a fichero Contaplus", "Abriendo subcuentas" )
         end
         lOpen       := .F.
      end

   RECOVER

      if lMessage
         MsgStop( "Imposible acceder a fichero Contaplus", "Abriendo subcuentas" )
      end
      lOpen          := .F.

   end

   ErrorBlock( oBlock )

Return ( lOpen )



FUNCTION MsgTblCon( aTable, cCodDiv, dbfDiv, lConAsi, cTitle, bConta )

   local oDlg
    local oBrw
   local oBtnCon
   local cPorDiv           := cPorDiv( cCodDiv, dbfDiv )

   IIF( lConAsi == nil, lConAsi := .F., ) ;
   IIF( cTitle == nil, cTitle := "", ) ;

   if !IsArray( aTable ) .OR. len( aTable ) < 1
      return nil
   end

   oDlg = TDialog():New(,,,, "Simulador de asientos." + Space( 1 ) + cTitle, "CONTA",, .F.,,,,,, .F.,,,,,, .F., )

   oBrw                    := IXBrowse():New( oDlg )

   oBrw:bClrSel            := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
   oBrw:bClrSelFocus       := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

   oBrw:SetArray( aTable, , , .F. )

   oBrw:lFooter            := .T.
   oBrw:nMarqueeStyle      := 5
   oBrw:cName              := "Simulador de asientos"

   oBrw:CreateFromResource( 100 )

      with object ( oBrw:AddCol() )
         :cHeader          := "Asiento"
         :bEditValue       := {|| aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "Asien" ) ) ] }
         :nWidth           := 50
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Fecha"
         :bEditValue       := {|| aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "Fecha" ) ) ] }
         :nWidth           := 70
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Subcuenta"
         :bEditValue       := {|| aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "Subcta" ) ) ] }
         :nWidth           := 80
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Contapartida"
         :bEditValue       := {|| aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "Contra" ) ) ] }
         :nWidth           := 80
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Debe"
         :bEditValue       := {|| if( .T. , aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "EuroDebe" ) ) ], aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "PtaDebe" ) ) ] ) }
         :bFooter          := {|| nTotDebe( aTable, cCodDiv ) }
         :cEditPicture     := cPorDiv
         :nWidth           := 70
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
         :nFootStrAlign    := 1
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Concepto"
         :bEditValue       := {|| aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "Concepto" ) ) ] }
         :nWidth           := 170
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Haber"
         :bEditValue       := {|| if( .T., aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "EuroHaber" ) ) ], aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "PtaHaber" ) ) ] ) }
         :bFooter          := {|| nTotHaber( aTable, cCodDiv ) }
         :cEditPicture     := cPorDiv
         :nWidth           := 70
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
         :nFootStrAlign    := 1
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Serie"
         :bEditValue       := {|| aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "Serie" ) ) ] }
         :nWidth           := 20
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Factura"
         :bEditValue       := {|| aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "Factura" ) ) ] }
         :nWidth           := 80
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Base imponible"
         :bEditValue       := {|| if( .T. , aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "BaseEuro" ) ) ], aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "BaseImpo" ) ) ] ) }
         :cEditPicture     := cPorDiv
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oBrw:AddCol() )
         :cHeader          := cImp()
         :bEditValue       := {|| aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "IVA" ) ) ] }
         :cEditPicture     := cPorDiv
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "R.E."
         :bEditValue       := {|| aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "RecEquiv" ) ) ] }
         :cEditPicture     := cPorDiv
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Documento"
         :bEditValue       := {|| aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "Documento" ) ) ] }
         :nWidth           := 100
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Departamento"
         :bEditValue       := {|| aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "Departa" ) ) ] }
         :nWidth           := 40
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Clave"
         :bEditValue       := {|| aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "Clave" ) ) ] }
         :nWidth           := 60
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Estado"
         :bEditValue       := {|| aTable[ oBrw:nArrayAt, ( cDiario )->( FieldPos( "Estado" ) ) ] }
         :nWidth           := 40
      end

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }




      oBtnCon := TButton():ReDefine( 110, {||( if( !Empty( bConta ), Eval( bConta ), ), oDlg:end() )}, oDlg,,, .F.,,,, .F. )




      TButton():ReDefine( 120, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )





        TButton():ReDefine( 1, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

      oDlg:AddFastKey( 116, {|| if( !Empty( bConta ), Eval( bConta ), ), oDlg:end() } )

      oDlg:bStart          := {|| if( !lConAsi .OR. Empty( bConta ), oBtnCon:Hide(), ) }

    oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

RETURN ( oDlg:nResult == 1 )



function nTotDebe( aTable, cCodDiv, cPorDiv )

   local nTotal      := 0
   local oError
   local oBlock

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if !Empty( aTable )

   if .T.
      aEval( aTable, {|x| nTotal += if( valType( x[ ( cDiario )->( FieldPos( "EURODEBE" ) ) ] ) == "N", x[ ( cDiario )->( FieldPos( "EURODEBE" ) ) ], 0 ) } )
   else
      aEval( aTable, {|x| nTotal += if( valType( x[ ( cDiario )->( FieldPos( "PTADEBE" ) ) ] ) == "N", x[ ( cDiario )->( FieldPos( "PTADEBE" ) ) ], 0 ) } )
   end

   end

   RECOVER USING oError

   end

   ErrorBlock( oBlock )

return ( if( Empty( cPorDiv ), nTotal, Trans( nTotal, cPorDiv ) ) )



function nTotHaber( aTable, cCodDiv, cPorDiv )

   local nTotal   := 0
   local oError
   local oBlock

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if .T.
      aEval( aTable, {|x| nTotal += if( valType( x[ ( cDiario )->( FieldPos( "EUROHABER" ) ) ] ) == "N", x[ ( cDiario )->( FieldPos( "EUROHABER" ) ) ], 0 ) } )
   else
      aEval( aTable, {|x| nTotal += if( valType( x[ ( cDiario )->( FieldPos( "PTAHABER" ) ) ] ) == "N", x[ ( cDiario )->( FieldPos( "PTAHABER" ) ) ], 0 ) } )
   end

   RECOVER USING oError

   end

   ErrorBlock( oBlock )

return ( if( Empty( cPorDiv ), nTotal, Trans( nTotal, cPorDiv ) ) )



FUNCTION BrwProyecto( oCodPro, oGetPro, cRuta, cCodEmp )

    local oDlg
    local oBrw
   local oAdd
   local oEdt
    local oGet1
    local cGet1
    local oCbxOrd
    local cCbxOrd        := "Nombre"
    local cAreaAnt     := Alias()

   IIF( cCodEmp == nil, cCodEmp := cEmpCnt( "A" ), ) ;
   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;

   if Empty( cRuta )
      return .F.
   end

   cRuta             := cPath( cRuta )

   IF OpnProyecto( cRuta, cCodEmp )

      ( cProyecto )->( dbGoTop() )

      oDlg = TDialog():New(,,,, "Proyectos de contaplus ®", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F., )





        oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,,,,,,,, .F.,, {|nKey,nFlags,Self| AutoSeek( nKey, nFlags, Self, oBrw, cProyecto ) }, .F., .F.,,,,,, nil, "FIND",, )





        oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, { "Código", "Proyecto" }, oDlg,,,,,,, .F.,,,,,, )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias          := cProyecto
      oBrw:nMarqueeStyle   := 5
      oBrw:cName           := "Browse.Proyectos de contaplus"

         with object ( oBrw:AddCol() )
            :cHeader       := "Código"
            :cSortOrder    := "Proye"
            :bEditValue    := {|| ( cProyecto )->Proye }
            :cEditPicture  := "@R ####.######"
            :nWidth        := 80
            :bLClickHeader := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
         end

         with object ( oBrw:AddCol() )
            :cHeader       := "Proyecto"
            :cSortOrder    := "Descrip"
            :bEditValue    := {|| ( cProyecto )->Descrip }
            :nWidth        := 260
            :bLClickHeader := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
         end

      oBrw:CreateFromResource( 105 )

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }
      oBrw:bKeyDown        := {|nKey, nFalg| if( nKey == 13, oDlg:end( 1 ), ) }




      oAdd := TButton():ReDefine( 500, {||( nil )}, oDlg,,, .F.,,,, .F. )




      oEdt := TButton():ReDefine( 501, {||( nil )}, oDlg,,, .F.,,,, .F. )




        TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )





        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

      oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( oAdd:Hide(), oEdt:Hide() )}, oDlg:bRClicked,,, )

      IF oDlg:nResult == 1

         oCodPro:cText( ( cProyecto )->Proye )

         IF ValType( oGetPro ) == "O"
            oGetPro:cText( ( cProyecto )->Descrip )
            end

        end

      CloseProyecto()

    end

    IF cAreaAnt <> ""
        dbSelectArea( ( cAreaAnt ) )
    end

   oCodPro:setFocus()

RETURN ( nil )



FUNCTION ChkProyecto( cCodPro, oGetPro, cRuta, cCodEmp, lMessage )

   local cNombreProyecto   := ""

   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;
   IIF( cCodEmp == nil, cCodEmp := cEmpCnt(), ) ;
   IIF( lMessage == nil, lMessage := .F., ) ;

   if Empty( cRuta )
      return ( cNombreProyecto )
   end

   cRuta                   := cPath( cRuta )

   if Empty( cCodPro ) .OR. Empty( cRuta )
      return ( cNombreProyecto )
   end

   if OpnProyecto( cRuta, cCodEmp )

      if ( cProyecto )->( dbSeek( cCodPro ) )

         cNombreProyecto   := ( cProyecto )->Descrip

      else

         if lMessage
            msgStop( "Proyecto : " + cCodPro + Chr(13)+Chr(10) + "no encontrada", "Contaplus" )
         end

      end

      if !Empty( oGetPro )
         oGetPro:cText( cNombreProyecto )
      end

      CloseProyecto()

   end

Return ( cNombreProyecto )



FUNCTION OpnProyecto( cRuta, cCodEmp )

   local lRet        := .F.

   IIF( cCodEmp == nil, cCodEmp := cEmpCnt(), ) ;
   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;

   if Empty( cRuta )
      return .F.
   end

   cRuta             := cPath( cRuta )

   do case
   case File( cRuta + "EMP" + cCodEmp + "\PROYEC" + cCodEmp + ".CDX" )





      dbUseArea( .T., ( cLocalDriver() ), ( cRuta + "EMP" + cCodEmp + "\PROYEC" + cCodEmp + ".DBF" ), ( cCheckArea( "PROYEC", @cProyecto ) ), if(.F. .OR. .F., !.F., NIL), .F.,, )
      if !.F. ; ordListClear() ; end ; ordListAdd( ( cRuta + "EMP" + cCodEmp + "\PROYEC" + cCodEmp + ".CDX" ) )

      IF ( cProyecto )->( RddName() ) == nil .OR. NetErr()
         MsgStop( "Imposible acceder a fichero Contaplus", "Abriendo fichero de proyecto" )
         lRet  := .F.
      ELSE
         lRet  := .T.
      end

   case File( cRuta + "EMP" + cCodEmp + "\PROYEC.CDX" )





      dbUseArea( .T., ( cLocalDriver() ), ( cRuta + "EMP" + cCodEmp + "\PROYEC.DBF" ), ( cCheckArea( "PROYEC", @cProyecto ) ), if(.F. .OR. .F., !.F., NIL), .F.,, )
      if !.F. ; ordListClear() ; end ; ordListAdd( ( cRuta + "EMP" + cCodEmp + "\PROYEC.CDX" ) )

      IF ( cProyecto )->( RddName() ) == nil .OR. NetErr()
         MsgStop( "Imposible acceder a fichero Contaplus", "Abriendo fichero de proyecto" )
         lRet  := .F.
      ELSE
         lRet  := .T.
      end

   end

RETURN lRet



FUNCTION CloseProyecto()

   ( cProyecto  )->( dbCloseArea() )

RETURN NIL



function cCodEmpCnt( cSer )

   local cCodEmp  := ""

   IIF( cSer == nil, cSer := "A", ) ;

   cCodEmp        := cEmpCnt( cSer )

RETURN ( cCodEmp )



function dbfDiario() ; return ( cDiario )



function dbfCuenta() ; return ( cCuenta )



function dbfSubCta() ; return ( cSubCuenta )



function dbfProyecto() ; return ( cProyecto )



Function OpnDiario( cRuta, cCodEmp, lMessage )

   local oBlock
   local dbfDiario      := nil

   IIF( cCodEmp == nil, cCodEmp := cEmpCnt( "A" ), ) ;
   IIF( lMessage == nil, lMessage := .F., ) ;
   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;

   if Empty( cRuta )
      if lMessage
         MsgStop( "Ruta de Contaplus ® no valida" )
      end
      Return nil
   end

   cRuta                := cPath( cRuta )

   oBlock               := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      if File( cRuta + "EMP" + cCodEmp + "\DIARIO.CDX" )

         dbUseArea( .T., ( cLocalDriver() ), ( cRuta + "EMP" + cCodEmp + "\DIARIO.DBF" ), ( cCheckArea( "DIARIO", @dbfDiario ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
         if !.T. ; ordListClear() ; end ; ordListAdd( ( cRuta + "EMP" + cCodEmp + "\DIARIO.CDX" ) )
         ordSetFocus( "NUASI" )

         if ( dbfDiario )->( RddName() ) == nil .OR. ( dbfDiario )->( NetErr() )

            if lMessage
               msgStop( "Imposible acceder a fichero Contaplus ®.", "Abriendo diario" )
            end

            dbfDiario   := nil

         end

      else

         if lMessage
            msgStop( "Ficheros no encontrados en ruta " + cRuta + " empresa " + cCodEmp, "Abriendo diario" )
         end

      end

   RECOVER

      msgStop( "Imposible abrir las bases de datos del diario de Contaplus ®." )

   end

   ErrorBlock( oBlock )

Return ( dbfDiario )



Function OpnBalance( cRuta, cCodEmp, lMessage )

   local dbfBalance

   IIF( cCodEmp == nil, cCodEmp := cEmpCnt( "A" ), ) ;
   IIF( lMessage == nil, lMessage := .F., ) ;
   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;

   if Empty( cRuta )
      if lMessage
         MsgStop( "Ruta de Contaplus ® no valida" )
      end
      Return nil
   end

   cRuta             := cPath( cRuta )

   if File( cRuta + "EMP" + cCodEmp + "\DIARIO.CDX" )

      dbUseArea( .T., ( cLocalDriver() ), ( cRuta + "EMP" + cCodEmp + "\BALAN.DBF" ), ( cCheckArea( "CUENTA", @dbfBalance ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !.F. ; ordListClear() ; end ; ordListAdd( ( cRuta + "EMP" + cCodEmp + "\BALAN.CDX" ) )
        ordSetFocus( "CTA" )

   else

      if lMessage
         msgStop( "Ficheros no encontrados en ruta " + cRuta + " empresa " + cCodEmp, "Abriendo balances" )
      end

      Return nil

   end

   if ( dbfBalance )->( RddName() ) == nil .OR. NetErr()
      if lMessage
         msgStop( "Imposible acceder a fichero Contaplus", "Abriendo balances" )
      end
      Return nil
   end

Return ( dbfBalance )



Function OpnSubCuenta( cRuta, cCodEmp, lMessage )

   local dbfSubCta

   IIF( cCodEmp == nil, cCodEmp := cEmpCnt( "A" ), ) ;
   IIF( lMessage == nil, lMessage := .F., ) ;
   IIF( cRuta == nil, cRuta := cRutCnt(), ) ;

   if Empty( cRuta )
      if lMessage
         MsgStop( "Ruta de Contaplus ® no valida" )
      end
      Return nil
   end

   cRuta             := cPath( cRuta )









   if File( cRuta + "EMP" + cCodEmp + "\SUBCTA.CDX" )

      dbUseArea( .T., ( cLocalDriver() ), ( cRuta + "EMP" + cCodEmp + "\SUBCTA.DBF" ), ( cCheckArea( "SUBCUENTA", @dbfSubCta ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !.F. ; ordListClear() ; end ; ordListAdd( ( cRuta + "EMP" + cCodEmp + "\SUBCTA.CDX" ) )

   else

      if lMessage
         msgStop( "Ficheros no encontrados en ruta " + cRuta + " empresa " + cCodEmp, "Abriendo subcuentas" )
      end

      Return nil

   end

   if ( dbfSubCta )->( RddName() ) == nil .OR. NetErr()
      if lMessage
         msgStop( "Imposible acceder a fichero Contaplus", "Abriendo subcuentas" )
      end
      Return nil
   end

Return ( dbfSubCta )



Function CloSubCuenta()

   if !Empty( cSubCuenta )
      ( cSubCuenta )->( dbCloseArea() )
   end

   cSubCuenta  := nil

Return ( cSubCuenta )



Function ODiario()

Return ( nil )



Function CDiario()

Return ( nil )
