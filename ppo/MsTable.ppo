#line 112 "\xHarbour\Include\hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 20 ".\Prg\MsTable.prg"
function TMyTable( cCls )
return( MyGenClass( cCls, TVMyTable() ) )




_HB_CLASS TVMyTable ; UTILITY FUNCTION TVMyTable(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TVMyTable" , {TMSTable():classh} ) ) ; ;

    _HB_MEMBER { lGenDataField} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lGenDataField" }, .F., .F. ), )

    _HB_MEMBER Open(); IIF( .F., s_oClass:ModMethod( "Open", @TVMyTable_Open(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Open", @TVMyTable_Open(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TVMyTable ;




UTILITY STATIC function TVMyTable_Open() ; local Self AS CLASS TVMyTable := QSelf() AS CLASS TVMyTable

    local lRet := ::TMSTable:Open()

    if lRet .AND. ::lGenDataField
        MyGenDataField( Self )
        ::lGenDataField := .F.
    endif

return( lRet )







_HB_CLASS TMSTable ; UTILITY FUNCTION TMSTable(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TMSTable" , {TMSQuery():classh} ) ) ; ;

    _HB_MEMBER { cName} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cName" }, .F., .F. ), )
    _HB_MEMBER { cWhere} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cWhere" }, .F., .F. ), )
    _HB_MEMBER { cHaving} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cHaving" }, .F., .F. ), )
    _HB_MEMBER { cOrderBy} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cOrderBy" }, .F., .F. ), )
    _HB_MEMBER { lOpenTable} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lOpenTable" }, .F., .F. ), )
    _HB_MEMBER { aBuffer} ; IIF( !.F., s_oClass:AddMultiData(, {}, nScope + IIF( .F., 32, 0 ), { "aBuffer" }, .F., .F. ), )

    _HB_MEMBER { aKey} ; IIF( !.F., s_oClass:AddMultiData(, {}, nScope + IIF( .F., 32, 0 ), { "aKey" }, .F., .F. ), )
    _HB_MEMBER { nColAutoInc} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nColAutoInc" }, .F., .F. ), )

    _HB_MEMBER { nLimit} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nLimit" }, .F., .F. ), )

    _HB_MEMBER New( oDbCon, cName, cWhere, cHaving, cOrderBy, nLimit) AS CLASS TMSTable; IIF( .F., s_oClass:ModMethod( "New", @TMSTable_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TMSTable_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER Open(); IIF( .F., s_oClass:ModMethod( "Open", @TMSTable_Open(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Open", @TMSTable_Open(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

    _HB_MEMBER CreateTable( aStruct, cType, lTemporary, lNotExists); IIF( .F., s_oClass:ModMethod( "CreateTable", @TMSTable_CreateTable(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateTable", @TMSTable_CreateTable(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

    _HB_MEMBER Insert( lRefresh); IIF( .F., s_oClass:ModMethod( "Insert", @TMSTable_Insert(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Insert", @TMSTable_Insert(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER Update( lRefresh, nLimit); IIF( .F., s_oClass:ModMethod( "Update", @TMSTable_Update(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Update", @TMSTable_Update(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER Delete( lRefresh, nLimit); IIF( .F., s_oClass:ModMethod( "Delete", @TMSTable_Delete(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Delete", @TMSTable_Delete(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

    _HB_MEMBER CreateIndex( cIndex, xCol, lUnique); IIF( .F., s_oClass:ModMethod( "CreateIndex", @TMSTable_CreateIndex(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateIndex", @TMSTable_CreateIndex(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER DropIndex( cIndex); IIF( .F., s_oClass:ModMethod( "DropIndex", @TMSTable_DropIndex(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DropIndex", @TMSTable_DropIndex(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER CreatePrimaryKey( xCol); IIF( .F., s_oClass:ModMethod( "CreatePrimaryKey", @TMSTable_CreatePrimaryKey(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreatePrimaryKey", @TMSTable_CreatePrimaryKey(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER AlterEngine( cNewType); IIF( .F., s_oClass:ModMethod( "AlterEngine", @TMSTable_AlterEngine(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AlterEngine", @TMSTable_AlterEngine(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER Load(); IIF( .F., s_oClass:ModMethod( "Load", @TMSTable_Load(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Load", @TMSTable_Load(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER Blank(); IIF( .F., s_oClass:ModMethod( "Blank", @TMSTable_Blank(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Blank", @TMSTable_Blank(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER GetBuffer( n); IIF( .F., s_oClass:ModMethod( "GetBuffer", @TMSTable_GetBuffer(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetBuffer", @TMSTable_GetBuffer(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER SetBuffer( n, Val); IIF( .F., s_oClass:ModMethod( "SetBuffer", @TMSTable_SetBuffer(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetBuffer", @TMSTable_SetBuffer(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER FieldPut(n, Val); IIF( .F., s_oClass:ModMethod( "FieldPut", @TMSTable_SetBuffer(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ), s_oClass:AddMethod( "FieldPut", @TMSTable_SetBuffer(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ) );

    _HB_MEMBER GenSelect(); IIF( .F., s_oClass:ModMethod( "GenSelect", @TMSTable_GenSelect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GenSelect", @TMSTable_GenSelect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER GenWhere(); IIF( .F., s_oClass:ModMethod( "GenWhere", @TMSTable_GenWhere(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GenWhere", @TMSTable_GenWhere(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

    _HB_MEMBER SetWhere( cWhere, lRefresh); IIF( .F., s_oClass:ModMethod( "SetWhere", @TMSTable_SetWhere(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetWhere", @TMSTable_SetWhere(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER SetHaving( cHaving, lRefresh); IIF( .F., s_oClass:ModMethod( "SetHaving", @TMSTable_SetHaving(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetHaving", @TMSTable_SetHaving(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER SetOrderBy( cOrderBy, lDesc, lRefresh); IIF( .F., s_oClass:ModMethod( "SetOrderBy", @TMSTable_SetOrderBy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetOrderBy", @TMSTable_SetOrderBy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER SetLimit( nLimit, lRefresh); IIF( .F., s_oClass:ModMethod( "SetLimit", @TMSTable_SetLimit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetLimit", @TMSTable_SetLimit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER SetSelect( cWhere, cHaving, cOrderBy, nLimit, lRefresh); IIF( .F., s_oClass:ModMethod( "SetSelect", @TMSTable_SetSelect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetSelect", @TMSTable_SetSelect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));




    _HB_MEMBER Lock(); IIF( !.F., s_oClass:AddVirtual( "Lock" ), )
    _HB_MEMBER UnLock(); IIF( !.F., s_oClass:AddVirtual( "UnLock" ), )



    _HB_MEMBER ShowCreate(); IIF( .F., s_oClass:ModMethod( "ShowCreate", @TMSTable_ShowCreate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ShowCreate", @TMSTable_ShowCreate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
    _HB_MEMBER ImportData(); IIF( .F., s_oClass:ModMethod( "ImportData", @TMSTable_ImportData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ImportData", @TMSTable_ImportData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TMSTable ;




UTILITY STATIC function TMSTable_New( oDbCon, cName, cWhere, cHaving, cOrderBy, nLimit) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    ::TMSQuery:New( oDbCon )

    if ::lInit

        ::cName         := cName
        if ValType( cWhere ) == "C"
            ::cWhere    := cWhere
        endif
        if ValType( cHaving ) == "C"
            ::cHaving   := cHaving
        endif
        if ValType( cOrderBy ) == "N"
            cOrderBy    := LTrim( Str( cOrderBy ) )
        endif
        if ValType( cOrderBy ) == "C"
            ::cOrderBy  := cOrderBy
        endif
        if ValType( nLimit ) == "N"
            ::nLimit    := nLimit
        endif

        ::GenSelect()

    endif

    ::SetIName( "Table" )

return( Self )




UTILITY STATIC function TMSTable_Open() ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local lRet := ::TMSQuery:Open()


    if lRet .AND. !::lOpenTable
        ::lOpenTable := .T.
        ::aBuffer := Array( ::FieldCount() )
        ::nColAutoInc := E1FieldAutoInc( ::hMySQL )
        ::aKey := E1ListKey( ::hMySQL )
    endif

return( lRet )




UTILITY STATIC function TMSTable_CreateTable( aStruct, cType, lTemporary, lNotExists) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local n, nLen, cStmt, lAutoInc
    local lRet := .F.

    if ::lInit
        if ValType( aStruct ) == "A"

            if ValType( lTemporary ) == "L" .AND. lTemporary
                cStmt := "CREATE TEMPORARY TABLE "
            else
                cStmt := "CREATE TABLE "
            endif

            if ValType( lNotExists ) == "L" .AND. lNotExists
                cStmt += "IF NOT EXISTS "
            endif

            cStmt += ::cName + " ( "

            nLen := len( aStruct )

            for n := 1 to nLen

                if len( aStruct[ n ] ) == 5 .AND.  ValType( aStruct[ n, 5 ] ) == "L"
                    lAutoInc := aStruct[ n, 5 ]
                else
                    lAutoInc := .F.
                endif



                cStmt += aStruct[ n, 1 ] + " " +  _ColDefine( aStruct[ n, 2 ],  aStruct[ n, 3 ],  aStruct[ n, 4 ], lAutoInc ) + ", "
            next

            cStmt := ChgAtEnd( cStmt, " )", 2 )

            if ValType( cType ) == "C"
                cType := upper( cType )















                if  cType == "ARCHIVE" .OR.  cType == "CSV" .OR.  cType == "EXAMPLE" .OR.  cType == "FEDERATED" .OR.  cType == "HEAP" .OR.  cType == "ISAM" .OR.  cType == "INNODB" .OR.  cType == "MEMORY" .OR.  cType == "MERGE" .OR.  cType == "MYISAM" .OR.  cType == "NDBCLUSTER" .OR.  cType == "BDB" .OR.  cType == "GEMINI" .OR.  cType == "MRG_MYISAM" .OR.  cType == "BLACKHOLE"
                    cStmt += " TYPE = " + cType
                endif
            endif
            lRet := ::oCmd:ExecDirect( cStmt )
        else
            ::oError:Say( "La estructura debe ser un array...", .F. )
        endif
    endif

return( lRet )




UTILITY STATIC function TMSTable_CreateIndex( cIndex, xCol, lUnique) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local nLen, i
    local cStmt := "CREATE "

    if ValType( lUnique ) == "L" .AND. lUnique
        cStmt += "UNIQUE "
    endif

    cStmt += "INDEX " + cIndex + " ON " + ::cName + " ( "

    if ValType( xCol ) == "A"
        nLen := len( xCol )
        for i := 1 to nLen
            cStmt += xCol[ i ] + ", "
        next
        cStmt := ChgAtEnd( cStmt, " )", 2 )
    else
        cStmt += xCol + " )"
    endif

return( ::oCmd:ExecDirect( cStmt ) )




UTILITY STATIC function TMSTable_DropIndex( cIndex) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable
return( ::oCmd:ExecDirect( "DROP INDEX " + cIndex + " ON " + ::cName ) )




UTILITY STATIC function TMSTable_CreatePrimaryKey( xCol) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local nLen, i
    local cStmt := "ALTER TABLE " + ::cName + " ADD PRIMARY KEY ( "

    if ValType( xCol ) == "A"
        nLen := len( xCol )
        for i := 1 to nLen
            cStmt += xCol[ i ] + ", "
        next
        cStmt := ChgAtEnd( cStmt, " )", 2 )
    else
        cStmt += xCol + " )"
    endif

return( ::oCmd:ExecDirect( cStmt ) )



UTILITY STATIC function TMSTable_ShowCreate() ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local cRet
    local oQry := TMSQuery():New( ::oConnect )

    if oQry:Open( "SHOW CREATE TABLE "+ ::cName )
        cRet := oQry:FieldGet( 2 )
    else
        cRet := ""
    endif

    oQry:Free()

return( cRet )




UTILITY STATIC function TMSTable_GenSelect( lRefresh) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local lRet

    ::cStatement := "SELECT * FROM " + ::cName
    ::cStatement += if( empty( ::cWhere ), "", " WHERE " + ::cWhere )
    ::cStatement += if( empty( ::cHaving ), "", " HAVING " + ::cHaving )
    ::cStatement += if( empty( ::cOrderBy ), "", " ORDER BY " + ::cOrderBy )
    ::cStatement += if( empty( ::nLimit ), "", " LIMIT " + LTrim( str( ::nLimit ) ) )

    if ValType( lRefresh ) = "L" .AND. lRefresh
        lRet := ::Refresh()
    else
        lRet := .T.
    endif

return( lRet )




UTILITY STATIC function TMSTable_SetWhere( cWhere, lRefresh) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local lRet := ( ValType( cWhere ) == "C" )

    if lRet
        ::cWhere := cWhere
        lRet := ::GenSelect( lRefresh )
    endif

return( lRet )




UTILITY STATIC function TMSTable_SetHaving( cHaving, lRefresh) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local lRet := ( ValType( cHaving ) == "C" )

    if lRet
        ::cHaving := cHaving
        lRet := ::GenSelect( lRefresh )
    endif

return( lRet )




UTILITY STATIC function TMSTable_SetOrderBy( cOrderBy, lDesc, lRefresh) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local lRet
    local cType := ValType( cOrderBy )

    if cType == "N" .AND. ( cOrderBy > 0 .AND. cOrderBy <= ::FieldCount() )
        cOrderBy := LTrim( str( cOrderBy ) )
    else
        ::oError:Say( "No es un numero de columna valido", .T. )
    endif

    if ValType( cOrderBy ) == "C"
        if ValType( lDesc ) == "L" .AND. lDesc
            cOrderBy += " DESC"
        endif
        ::cOrderBy := cOrderBy
        lRet := ::GenSelect( lRefresh )
    else
        lRet := .F.
    endif

return( lRet )




UTILITY STATIC function TMSTable_SetLimit( nLimit, lRefresh) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local lRet := ( ValType( nLimit ) == "N" )

    if lRet
        ::nLimit := nLimit
        lRet := ::GenSelect( lRefresh )
    endif

return( lRet )




UTILITY STATIC function TMSTable_SetSelect( cWhere, cHaving, cOrderBy, nLimit, lRefresh) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    if ValType( cWhere ) == "C"; ::cWhere := cWhere; endif
    if ValType( cHaving ) == "C"; ::cHaving := cHaving; endif
    if ValType( cOrderBy ) == "N"
        cOrderBy := LTrim( str( cOrderBy ) )
    endif
    if ValType( cOrderBy ) == "C"; ::cOrderBy := cOrderBy; endif
    if ValType( nLimit ) == "N"; ::nLimit := nLimit; endif

return( ::GenSelect( lRefresh ) )





UTILITY STATIC function TMSTable_Insert( lRefresh) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local n, lRet
    local nLen := ::FieldCount()
    local aBuffer := ::ImportData()
    local cStmt := "INSERT INTO " + ::cName + " VALUES ( "

    for n := 1 to nLen





        cStmt += if( !( aBuffer[ n ] == nil ) .AND.  !E1IsAutoInc( ::hMySQL, n ),  if( !E1IsNumeric( ::hMySQL, n ),  ( '"' + aBuffer[ n ] + '", ' ),  ( aBuffer[ n ] + ", " ) ),  "NULL, " )
    next

    cStmt := ChgAtEnd( cStmt, " )", 2 )

    lRet := ::oCmd:ExecDirect( cStmt )

    if lRet .AND. ValType( lRefresh ) = "L" .AND. lRefresh
        ::Refresh()
    endif

return( lRet )





UTILITY STATIC function TMSTable_Delete( lRefresh, nLimit) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local lRet
    local cStmt := "DELETE FROM " + ::cName + ::GenWhere()


    cStmt += if( ValType( nLimit ) == "N" .AND. nLimit > 0,  " LIMIT " + LTrim( str( nLimit ) ), "" )

    lRet := ::oCmd:ExecDirect( cStmt )

    if lRet .AND. ValType( lRefresh ) = "L" .AND. lRefresh
        ::Refresh()
    endif

return( lRet )





UTILITY STATIC function TMSTable_Update( lRefresh, nLimit) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local n, lRet
    local nLen := ::FieldCount()
    local aBuffer := ::ImportData()
    local cStmt := "UPDATE " + ::cName + " SET "

    for n := 1 to nLen


        cStmt += ::ColName( n ) + " = " + if( !( aBuffer[ n ] == nil ),  ( + "'" + aBuffer[ n ] + "', " ),  ( " NULL, " ) )
    next

    cStmt := ChgAtEnd( cStmt, "  ", 2 )

    cStmt += ::GenWhere()

    cStmt += if( ValType( nLimit ) == "N" .AND. nLimit > 0,  " LIMIT " + LTrim( str( nLimit ) ), "" )

    lRet := ::oCmd:ExecDirect( cStmt )

    if lRet .AND. ValType( lRefresh ) = "L" .AND. lRefresh
        ::Refresh()
    endif

return( lRet )




UTILITY STATIC function TMSTable_Load() ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    E1Load( ::hMySQL, ::aBuffer )

return( Self )





UTILITY STATIC function TMSTable_ImportData() ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable
return( E1ImportData( ::hMySQL, ::aBuffer ) )




UTILITY STATIC function TMSTable_Blank() ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    E1SetBlank( ::hMySQL, ::aBuffer )

return( Self )




UTILITY STATIC function TMSTable_GetBuffer( n) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

   local uBuffer

   if Valtype( n ) == "C"
      n        := ::FieldPos( n )
   end

   if ( n > 0 .AND. n <= len( ::aBuffer ) )
      uBuffer  := ::aBuffer[ n ]
   end

return( uBuffer )




UTILITY STATIC function TMSTable_SetBuffer(n, Val) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable
return( ::aBuffer[ n ] := Val )




UTILITY STATIC function TMSTable_AlterEngine( cNewType) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

return( ValType( cNewType ) == "C" .AND.  ::oCmd:ExecDirect( "ALTER TABLE " + ::cName + " ENGINE = " + cNewType ) )









UTILITY STATIC function TMSTable_GenWhere() ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local cWhere := " WHERE "
    local nFld, n, i, cFldGet

    if ( n := ::nColAutoInc ) > 0
        cWhere += ::ColName( n ) + " = " + ::ColRead( n )
    elseif ( nFld := len( ::aKey ) ) > 0
        FOR i := 1 TO nFld
            n := ::aKey[ i ]
            cFldGet := ::ColRead( n )



            cWhere += if( ValType( cFldGet ) == "C", if( ::ColIsNumeric( n ),  ( ::ColName( n ) + " = "  + cFldGet +  " AND " ),  ( ::ColName( n ) + ' = "' + cFldGet + '" AND ' ) ),  ::ColName( n ) + " IS NULL AND " )
        NEXT
        cWhere := ChgAtEnd( cWhere, "", 4 )
    else
        nFld := ::FieldCount()
        FOR n := 1 TO nFld
            cFldGet := ::ColRead( n )



            cWhere += if( ValType( cFldGet ) == "C", if( ::ColIsNumeric( n ),  ( ::ColName( n ) + " = "  + cFldGet +  " AND " ),  ( ::ColName( n ) + ' = "' + cFldGet + '" AND ' ) ),  ::ColName( n ) + " IS NULL AND " )
        NEXT
        cWhere := ChgAtEnd( cWhere, "", 4 )
    endif

return( cWhere )






static function _ColDefine( cType, nLen, nDec, lAutoInc )

    local cRet

    SWITCH cType
        CASE "C"
            cRet := "char( " + LTrim( str( nLen ) ) + " )"
            EXIT
        CASE "N"
            if nDec > 0

                cRet := "decimal( " + LTrim( str( nLen ) ) + ", " +  LTrim( str( nDec ) ) + " )"
            else
                DO CASE
                CASE nLen <= 4
                    cRet := "smallint( " + LTrim( str( nLen ) ) + " )"
                CASE nLen <= 6
                    cRet := "mediumint( " + LTrim( str( nLen ) ) + " )"
                CASE nLen <= 9
                    cRet := "int( " + LTrim( str( nLen ) ) + " )"
                OTHERWISE
                    cRet := "bigint( " + LTrim( str( nLen ) ) + " )"
                ENDCASE
            endif
            if lAutoInc
                cRet += " not null auto_increment unique"
            endif
            EXIT
        CASE "D"
            cRet := "date"
            EXIT
        CASE "L"
            cRet := "tinyint( 1 ) unsigned zerofill"
            EXIT
        CASE "M"
            cRet := "text"
            EXIT
        DEFAULT
            cRet := "char( " + LTrim( str( nLen ) ) + " )"
    END

return( cRet )
