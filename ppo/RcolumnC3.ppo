#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 21 ".\Prg\RcolumnC3.prg"
_HB_CLASS TRColumn ; UTILITY FUNCTION TRColumn(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TRColumn" , { HBObject():Classh } ) ) ;

     _HB_MEMBER { oReport} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oReport" }, .F., .F. ), )
     _HB_MEMBER { aData, aTitle, aPicture} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aData" , "aTitle" , "aPicture" }, .F., .F. ), )
     _HB_MEMBER { bDataFont, bTitleFont, bTotalFont, bTotalExpr, bColor} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bDataFont" , "bTitleFont" , "bTotalFont" , "bTotalExpr" , "bColor" }, .F., .F. ), )
     _HB_MEMBER { cTotalPict} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cTotalPict" }, .F., .F. ), )

     _HB_MEMBER { nWidth, nDataHeight, nTitleHeight, nTotal, nCol, nSize, nPad, nPen, nOrder, nCalCol, nCurLine} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nWidth" , "nDataHeight" , "nTitleHeight" , "nTotal" , "nCol" , "nSize" , "nPad" , "nPen" , "nOrder" , "nCalCol" , "nCurLine" }, .F., .F. ), )

     _HB_MEMBER { lTotal, lShadow, lGrid, lTotalExpr, lUnderline, lDobleUnd, lTextUnd, lSeparator} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lTotal" , "lShadow" , "lGrid" , "lTotalExpr" , "lUnderline" , "lDobleUnd" , "lTextUnd" , "lSeparator" }, .F., .F. ), )
     _HB_MEMBER { Cargo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "Cargo" }, .F., .F. ), )
     _HB_MEMBER { bStartTotal} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bStartTotal" }, .F., .F. ), )



     _HB_MEMBER New( aTitle, nCol, aData, nSize, aPicture, bFont, lTotal, bTotalExpr, cFmt, lShadow, lGrid, oReport) AS CLASS TRColumn; IIF( .F., s_oClass:ModMethod( "New", @TRColumn_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TRColumn_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

     _HB_MEMBER Stabilize(); IIF( .F., s_oClass:ModMethod( "Stabilize", @TRColumn_Stabilize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Stabilize", @TRColumn_Stabilize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

     _HB_MEMBER SayTitle( nRow, nCol, nLine); IIF( .F., s_oClass:ModMethod( "SayTitle", @TRColumn_SayTitle(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SayTitle", @TRColumn_SayTitle(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
     _HB_MEMBER SayData( nRow, nCol, nLine); IIF( .F., s_oClass:ModMethod( "SayData", @TRColumn_SayData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SayData", @TRColumn_SayData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
     _HB_MEMBER SayTotal( nRow, nCol); IIF( .F., s_oClass:ModMethod( "SayTotal", @TRColumn_SayTotal(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SayTotal", @TRColumn_SayTotal(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
     _HB_MEMBER Separator( nDataLine, nRow); IIF( .F., s_oClass:ModMethod( "Separator", @TRColumn_Separator(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Separator", @TRColumn_Separator(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
     _HB_MEMBER Underline( lTextLength, lDouble, nDataLine, nRow); IIF( .F., s_oClass:ModMethod( "Underline", @TRColumn_Underline(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Underline", @TRColumn_Underline(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
     _HB_MEMBER TitleHeight( nLine); IIF( .F., s_oClass:ModMethod( "TitleHeight", @TRColumn_TitleHeight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "TitleHeight", @TRColumn_TitleHeight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TRColumn ;















UTILITY STATIC function TRColumn_New( aTitle     , nCol       , aData      , nSize      , aPicture   , bFont      , lTotal     , bTotalExpr , cFmt       , lShadow    , lGrid      , nPen       , oReport) ; local Self AS CLASS TRColumn := QSelf() AS CLASS TRColumn












     IIF( aTitle == nil, aTitle := {{|| ""} }, ) ; IIF( aData == nil, aData := {{|| ""} }, ); IIF( nSize == nil, nSize := 0, ); IIF( aPicture == nil, aPicture := {""}, ); IIF( nCol == nil, nCol := 0, ); IIF( bFont == nil, bFont := {|| 1 }, ); IIF( nPen == nil, nPen := 1, ); IIF( lTotal == nil, lTotal := .F., ); IIF( lShadow == nil, lShadow := .F., ); IIF( lGrid == nil, lGrid := .F., ); IIF( cFmt == nil, cFmt := iif(Valtype(Eval(aData[1]))=="N", "RIGHT", "LEFT"), );

     ::aTitle     = aTitle
     ::aData      = aData
     ::nSize      = nSize
     ::aPicture   = aPicture
     ::bDataFont  = bFont
     ::bTitleFont = {|| 1 }
     ::bTotalFont = bFont
     ::lTotal     = lTotal
     ::lShadow    = lShadow
     ::lGrid      = lGrid
     ::lUnderline = .F.
     ::lDobleUnd  = .F.
     ::lSeparator = .T.
     ::lTextUnd   = .F.
     ::nPen       = nPen
     ::nTotal     = 0
     ::oReport    = oReport
     ::bTotalExpr = bTotalExpr
     ::nCol       = nCol
     ::cTotalPict = iif(len(aPicture)>0, aPicture[1], "")
     ::nWidth     = 0
     ::nCalCol    = 0
     ::nOrder     = 0

     ::lTotalExpr = !(bTotalExpr == NIL)

     IF cFmt == "LEFT"
          ::nPad = 1
     ELSEIF cFmt == "RIGHT"
          ::nPad = 2
     ELSEIF cFmt == "CENTER" .OR. cFmt == "CENTERED"
          ::nPad = 3
     ELSE
          ::nPad = 1
     ENDIF

     while len(::aPicture) < len(::aData)
          Aadd(::aPicture,::cTotalPict)
     ENDDO

RETURN Self



UTILITY STATIC function TRColumn_Stabilize( nOrder) ; local Self AS CLASS TRColumn := QSelf() AS CLASS TRColumn

     LOCAL nFor, nWidth, nLen

     ::nDataHeight  := ::oReport:oDevice:GetTextHeight(::oReport:cCharPattern, ::oReport:aFont[eval(::bDataFont)])
     ::nTitleHeight := ::oReport:oDevice:GetTextHeight(::oReport:cCharPattern, ::oReport:aFont[eval(::bTitleFont)])

     IF !empty(::nSize)
          ::nWidth := ::oReport:oDevice:GetTextWidth(Replicate(::oReport:cCharPattern,::nSize), ::oReport:aFont[eval(::bDataFont)])
          RETU NIL
     ENDIF


     FOR nFor := 1 TO len(::aData)

          nLen      := len(cValtoChar(Transform(eval(::aData[nFor]), ::aPicture[nFor])))

          nWidth    := ::oReport:oDevice:GetTextWidth(Replicate(::oReport:cCharPattern,nLen), ::oReport:aFont[eval(::bDataFont)])
          ::nWidth  := Max(::nWidth,nWidth)
     NEXT

     FOR nFor := 1 TO len(::aTitle)
          nLen      := len(eval(::aTitle[nFor]))

          nWidth    := ::oReport:oDevice:GetTextWidth(Replicate(::oReport:cCharPattern,nLen), ::oReport:aFont[eval(::bTitleFont)])
          ::nWidth  := Max(::nWidth,nWidth)
     NEXT

     ::nOrder := nOrder

RETURN NIL



UTILITY STATIC function TRColumn_SayTitle( nRow, nCol, nLine) ; local Self AS CLASS TRColumn := QSelf() AS CLASS TRColumn

     LOCAL oFont
     LOCAL cTitle
     LOCAL nFont



     IIF( nRow == nil, nRow := 0, ) ; IIF( nCol == nil, nCol := ::nCol, ); IIF( nLine == nil, nLine := 1, );

     IF nLine > len(::aTitle)
          RETU NIL
     ENDIF

     cTitle := eval(::aTitle[nLine])
     nFont  := eval(::bTitleFont)
     oFont  := ::oReport:aFont[nFont]

     ::nCurLine := nLine


     ::oReport:oDevice:Say(nRow, nCol, cTitle, oFont, ::nWidth, ::oReport:aClrText[nFont],,::nPad-1)

RETURN NIL




UTILITY STATIC function TRColumn_SayData( nRow, nCol, nLine) ; local Self AS CLASS TRColumn := QSelf() AS CLASS TRColumn

     LOCAL oFont
     LOCAL cText
     LOCAL nWidth, nFont



     IIF( nRow == nil, nRow := 0, ) ; IIF( nCol == nil, nCol := ::nCol, ); IIF( nLine == nil, nLine := 1, );

     IF nLine > len(::aData)
          RETU NIL
     ENDIF

     ::nCurLine := nLine

     nFont  := eval(::bDataFont)
     oFont  := ::oReport:aFont[nFont]
     cText  := Transform(eval(::aData[nLine]),::aPicture[nLine])
     nWidth := ::oReport:oDevice:GetTextWidth(cText, oFont)


     ::oReport:oDevice:Say(nRow, nCol, cText, oFont, ::nWidth, ::oReport:aClrText[nFont],,::nPad-1)

      IF ::lUnderline



          ::Underline(::lTextUnd        , ::lDobleUnd       , nLine             , nRow+::nDataHeight)
      ENDIF

RETURN NIL



UTILITY STATIC function TRColumn_SayTotal( nRow, nCol) ; local Self AS CLASS TRColumn := QSelf() AS CLASS TRColumn

     LOCAL oFont
     LOCAL cText
     LOCAL nFont


     IIF( nRow == nil, nRow := 0, ) ; IIF( nCol == nil, nCol := ::nCol, );

     IF !::lTotal
          RETU NIL
     ENDIF





     IF ::bStartTotal <> nil
          Eval( ::bStartTotal, Self )
     ENDIF





     nFont := Eval(::bTotalFont)
     oFont := ::oReport:aFont[nFont]
     cText := Transform(::nTotal,::cTotalPict)

     ::oReport:oDevice:Say(nRow, nCol, cText, oFont, ::nWidth, ::oReport:aClrText[nFont],,::nPad-1)

RETURN NIL



UTILITY STATIC function TRColumn_TitleHeight( nLine) ; local Self AS CLASS TRColumn := QSelf() AS CLASS TRColumn

     LOCAL oFontT, oFontD
     LOCAL cText, cChar
     LOCAL nFor, nWidth, nLen, nFontT, nFontD, nLenData

     IF !empty(::nWidth)
          RETU NIL
     ENDIF

     nFontT := eval(::bTitleFont)
     nFontD := eval(::bDataFont)
     oFontT := ::oReport:aFont[nFontT]
     oFontD := ::oReport:aFont[nFontD]
     cChar := ::oReport:cCharPattern

     ::nDataHeight  := len(::aData) * ::oReport:oDevice:GetTextHeight(cChar, oFontD)
     ::nTitleHeight := len(::aTitle) * ::oReport:oDevice:GetTextHeight(cChar, oFontT)

     nLenData := len(::aData)

     FOR nFor := 1 TO nLenData
          cText    := Transform(eval(::aData[nLine]),::aPicture[nLine])
          nLen     := len(cText)
          nWidth   := ::oReport:oDevice:GetTextWidth(Replicate(cChar,nLen), oFontD)
          ::nWidth := Max(::nWidth,nWidth)
     NEXT

RETURN NIL



UTILITY STATIC function TRColumn_Underline( lTextUnd, lDobleUnd, nLine, nRow) ; local Self AS CLASS TRColumn := QSelf() AS CLASS TRColumn

     LOCAL nLeft, nRight, nWidth




     IIF( lTextUnd == nil, lTextUnd := ::lTextUnd, ) ; IIF( lDobleUnd == nil, lDobleUnd := ::lDobleUnd, ); IIF( nLine == nil, nLine := 1, ); IIF( nRow == nil, nRow := ::oReport:nRow, );

     DO CASE
     CASE !lTextUnd .AND. ::lGrid
          nLeft  := ::nCalCol  + Int(::oReport:nSeparator/2)
          nRight := nLeft + ::nWidth + Int(::oReport:nSeparator/2)
     CASE lTextUnd


          nWidth := ::oReport:oDevice:GetTextWidth(alltrim( Transform(eval(::aData[nLine]),::aPicture[nLine])), ::oReport:aFont[eval(::bDataFont)])
          DO CASE
               CASE ::nPad == 2
                    nLeft := ::nCalCol+::nWidth-nWidth
               CASE ::nPad == 3
                    nLeft := ::nCalCol+Int(::nWidth/2)-Int(nWidth/2)
               OTHERWISE
                    nLeft := ::nCalCol
          ENDCASE
          nRight := nLeft + nWidth
     OTHERWISE
          nLeft  := ::nCalCol
          nRight := nLeft + ::nWidth
     ENDCASE


     IF lDobleUnd
          nWidth := ::oReport:aPen[::nPen]:nWidth




          ::oReport:oDevice:Line(nRow-nWidth, nLeft, nRow-nWidth, nRight, ::oReport:aPen[::nPen])





          ::oReport:oDevice:Line(nRow+nWidth, nLeft, nRow+nWidth, nRight, ::oReport:aPen[::nPen])
     ELSE




          ::oReport:oDevice:Line(nRow, nLeft, nRow, nRight, ::oReport:aPen[::nPen])
     ENDIF

RETURN NIL



UTILITY STATIC function TRColumn_Separator( nRow, lForced) ; local Self AS CLASS TRColumn := QSelf() AS CLASS TRColumn

   LOCAL nLeft, nRight, nSep


   IIF( nRow == nil, nRow := ::oReport:nRow, ) ; IIF( lForced == nil, lForced := .F., );

   IF !::lSeparator .AND. !lForced
      RETURN NIL
   ENDIF

   nSep   := iif( ::lGrid, Int(::oReport:nSeparator/2), 0)
   nLeft  := ::nCalCol  - nSep
   nRight := nLeft + ::nWidth + (nSep*2)





   ::oReport:oDevice:Line(nRow, nLeft, nRow, nRight, ::oReport:aPen[::nPen])

RETURN NIL
