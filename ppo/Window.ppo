#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 138 ".\Prg\Window.prg"
extern set

static aWindows    := {}
static oWndDefault



static oToolTip, oTmr, hPrvWnd, lToolTip := .F., hWndParent := 0, hToolTip := 0

static uDropInfo

static lTTBalloon := .F.
static lSkins := .F.



function nWindows()  ; return Len( aWindows )
function GetAllWin() ; return aWindows



function SetBalloon( lOnOff )

   local lPrevious := lTTBalloon

   if ValType( lOnOff ) == "L"
      lTTBalloon = lOnOff
   endif

return lPrevious



function SetSkins( lOnOff )

   local lPrevious := lSkins

   if ValType( lOnOff ) == "L"
      lSkins = lOnOff
   endif

return lPrevious




_HB_CLASS TWindow ; UTILITY FUNCTION TWindow(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TWindow" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { hWnd, nOldProc} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "hWnd" , "nOldProc" }, .F., .F. ), )

   _HB_MEMBER { bInit, bMoved, bLClicked, bLButtonUp, bKeyDown, bPainted} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bInit" , "bMoved" , "bLClicked" , "bLButtonUp" , "bKeyDown" , "bPainted" }, .F., .F. ), )
   _HB_MEMBER { bMButtonDown, bMButtonUp, bRClicked, bRButtonUp, bMouseWheel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bMButtonDown" , "bMButtonUp" , "bRClicked" , "bRButtonUp" , "bMouseWheel" }, .F., .F. ), )
   _HB_MEMBER { bResized, bLDblClick, bWhen, bValid, bKeyChar, bMMoved} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bResized" , "bLDblClick" , "bWhen" , "bValid" , "bKeyChar" , "bMMoved" }, .F., .F. ), )
   _HB_MEMBER { bGotFocus, bLostFocus, bDropFiles, bDdeInit, bDdeExecute} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bGotFocus" , "bLostFocus" , "bDropFiles" , "bDdeInit" , "bDdeExecute" }, .F., .F. ), )
   _HB_MEMBER { bCommNotify, bMenuSelect, bZip, bUnZip, bDropOver} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bCommNotify" , "bMenuSelect" , "bZip" , "bUnZip" , "bDropOver" }, .F., .F. ), )


   _HB_MEMBER { bCopy, bCut, bFind, bPaste, bPrint} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bCopy" , "bCut" , "bFind" , "bPaste" , "bPrint" }, .F., .F. ), )
   _HB_MEMBER { bUnDo, bReDo, bDelete, bSelectAll, bFindNext, bReplace, bProperties} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bUnDo" , "bReDo" , "bDelete" , "bSelectAll" , "bFindNext" , "bReplace" , "bProperties" }, .F., .F. ), )

   _HB_MEMBER { cCaption, cPS, cVarName, nPaintCount, cMsg, cToolTip} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cCaption" , "cPS" , "cVarName" , "nPaintCount" , "cMsg" , "cToolTip" }, .F., .F. ), )
   _HB_MEMBER { Cargo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "Cargo" }, .F., .F. ), )
   _HB_MEMBER { hDC, nId} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "hDC" , "nId" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lActive} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .T., nScope + IIF( .F., 32, 0 ), { "lActive" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lCancel, lFocused, lVisible, lDesign, lVbx, lValidating} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL",, nScope + IIF( .F., 32, 0 ), { "lCancel" , "lFocused" , "lVisible" , "lDesign" , "lVbx" , "lValidating" }, .F., .F. ), )
   _HB_MEMBER { lBalloon} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lBalloon" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nTop, nLeft, nBottom, nRight} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 0, nScope + IIF( .F., 32, 0 ), { "nTop" , "nLeft" , "nBottom" , "nRight" }, .F., .F. ), )
   _HB_MEMBER { nStyle, nExStyle, nChrHeight, nChrWidth, nLastKey} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nStyle" , "nExStyle" , "nChrHeight" , "nChrWidth" , "nLastKey" }, .F., .F. ), )
   _HB_MEMBER { nClrPane, nClrText, bClrGrad} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrPane" , "nClrText" , "bClrGrad" }, .F., .F. ), )
   _HB_MEMBER { nResult, nHelpId, hCtlFocus} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nResult" , "nHelpId" , "hCtlFocus" }, .F., .F. ), )
   _HB_MEMBER { aControls, aMinMaxInfo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aControls" , "aMinMaxInfo" }, .F., .F. ), )
   _HB_MEMBER { oBar, oBrush, oCursor, oFont, oIcon, oMenu} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBar" , "oBrush" , "oCursor" , "oFont" , "oIcon" , "oMenu" }, .F., .F. ), )
   _HB_MEMBER { oSysMenu, oPopup, oMsgBar, oWnd, oVScroll, oHScroll} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oSysMenu" , "oPopup" , "oMsgBar" , "oWnd" , "oVScroll" , "oHScroll" }, .F., .F. ), )
   _HB_MEMBER { oDragCursor} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oDragCursor" }, .F., .F. ), )
   _HB_MEMBER { oCtlFocus} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oCtlFocus" }, .F., .F. ), )
   _HB_MEMBER { oTop, oLeft, oBottom, oRight, oClient} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oTop" , "oLeft" , "oBottom" , "oRight" , "oClient" }, .F., .F. ), )

   _HB_MEMBER { bSocket, bTaskBar, bEraseBkGnd} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bSocket" , "bTaskBar" , "bEraseBkGnd" }, .F., .F. ), )

   _HB_MEMBER { OnClick, OnMouseMove, OnKeyDown, OnMove, OnPaint, OnResize} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "OnClick" , "OnMouseMove" , "OnKeyDown" , "OnMove" , "OnPaint" , "OnResize" }, .F., .F. ), )
   _HB_MEMBER { nPosition} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nPosition" }, .F., .F. ), )

   _HB_MEMBER {AS LOGICAL lRegistered} ; IIF( !.F., s_oClass:AddMultiClsData("LOGICAL",, nScope + IIF( .F., 32, 0 ) + 64, { "lRegistered" }, .F. ), )

   _HB_MEMBER { oMItemSelect} ; IIF( !.F., s_oClass:AddMultiClsData(,, nScope + IIF( .F., 32, 0 ) + 64, { "oMItemSelect" }, .F. ), )
   _HB_MEMBER {AS NUMERIC nToolTip} ; IIF( !.F., s_oClass:AddMultiClsData("NUMERIC", 900, nScope + IIF( .F., 32, 0 ) + 64, { "nToolTip" }, .F. ), )




   _HB_MEMBER { aProperties} ; IIF( !.F., s_oClass:AddMultiClsData(, { "cTitle", "cVarName", "nClrText", "nClrPane", "bClrGrad", "nTop", "nLeft", "nWidth", "nHeight", "Cargo", "oMenu", "oFont" }, nScope + IIF( .F., 32, 0 ) + 64, { "aProperties" }, .F. ), )











   _HB_MEMBER { aEvents} ; IIF( !.F., s_oClass:AddMultiClsData(, { { "OnClick", "nRow", "nCol", "nKeyFlags" }, { "OnMouseMove", "nRow", "nCol", "nKeyFlags" }, { "OnKeyDown", "nKey", "nFlags" }, { "OnMove" }, { "OnPaint" }, { "OnResize" } }, nScope + IIF( .F., 32, 0 ) + 64, { "aEvents" }, .F. ), )

   _HB_MEMBER { hAlphaColor, hAlphaLevel} ; IIF( !.F., s_oClass:AddMultiData(,, 4 + IIF( .F., 32, 0 ), { "hAlphaColor" , "hAlphaLevel" }, .F., .F. ), )





   _HB_MEMBER New( nTop, nLeft, nBottom, nRight, cTitle, nStyle, oMenu, oBrush, oIcon, oParent, lVScroll, lHScroll, nClrFore, nClrBack, oCursor, cBorder, lSysMenu, lCaption, lMin, lMax, lPixel) AS CLASS TWindow; IIF( .F., s_oClass:ModMethod( "New", @TWindow_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TWindow_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));





   _HB_MEMBER Activate( cShow, bLClicked, bRClicked, bMoved, bResized, bPainted, bKeyDown, bInit, bUp, bDown, bPgUp, bPgDn, bLeft, bRight, bPgLeft, bPgRight, bValid, bDropFiles, bLButtonUp); IIF( .F., s_oClass:ModMethod( "Activate", @TWindow_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Activate", @TWindow_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   _HB_MEMBER AddControl(oControl); IIF( .F., s_oClass:ModInline( "AddControl", {|Self,oControl | Self, If( ::aControls == nil, ::aControls := {},), AAdd( ::aControls, oControl ), ::lValidating := .F. }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "AddControl", {|Self,oControl | Self, If( ::aControls == nil, ::aControls := {},), AAdd( ::aControls, oControl ), ::lValidating := .F. }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER AsyncSelect( nSocket, nLParam); IIF( .F., s_oClass:ModMethod( "AsyncSelect", @TWindow_AsyncSelect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AsyncSelect", @TWindow_AsyncSelect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER BeginPaint(); IIF( .F., s_oClass:ModMethod( "BeginPaint", @TWindow__BeginPaint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ), s_oClass:AddMethod( "BeginPaint", @TWindow__BeginPaint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ) );

   _HB_MEMBER Box( nTop, nLeft, nBottom, nRight); IIF( .F., s_oClass:ModMethod( "Box", @TWindow_Box(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Box", @TWindow_Box(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Capture(); IIF( .F., s_oClass:ModInline( "Capture", {|Self | Self, SetCapture( ::hWnd ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Capture", {|Self | Self, SetCapture( ::hWnd ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER Center(oWnd); IIF( .F., s_oClass:ModInline( "Center", {|Self,oWnd | Self, WndCenter( ::hWnd, If( oWnd <> nil, oWnd:hWnd, 0 ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Center", {|Self,oWnd | Self, WndCenter( ::hWnd, If( oWnd <> nil, oWnd:hWnd, 0 ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER CheckToolTip(); IIF( .F., s_oClass:ModMethod( "CheckToolTip", @TWindow_CheckToolTip(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CheckToolTip", @TWindow_CheckToolTip(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



         _HB_MEMBER ChildLevel(oClass); IIF( .F., s_oClass:ModInline( "ChildLevel", {|Self,oClass | Self, ChildLevel( Self, oClass ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ChildLevel", {|Self,oClass | Self, ChildLevel( Self, oClass ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )




   _HB_MEMBER Close( ); IIF( !.F., s_oClass:AddVirtual( "Close" ), )

   _HB_MEMBER Command( nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "Command", @TWindow_Command(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Command", @TWindow_Command(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CommNotify( nDevice, nStatus); IIF( .F., s_oClass:ModMethod( "CommNotify", @TWindow_CommNotify(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CommNotify", @TWindow_CommNotify(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Circle( nRow, nCol, nWidth); IIF( .F., s_oClass:ModMethod( "Circle", @TWindow_Circle(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Circle", @TWindow_Circle(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CoorsUpdate(); IIF( .F., s_oClass:ModMethod( "CoorsUpdate", @TWindow_CoorsUpdate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CoorsUpdate", @TWindow_CoorsUpdate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER Copy(); IIF( .F., s_oClass:ModInline( "Copy", {|Self | Self, If( ::bCopy <> nil, Eval( ::bCopy, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Copy", {|Self | Self, If( ::bCopy <> nil, Eval( ::bCopy, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Create( cClsName); IIF( .F., s_oClass:ModMethod( "Create", @TWindow_Create(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Create", @TWindow_Create(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));




   _HB_MEMBER CtlColor(hWndChild, hDCChild); IIF( .F., s_oClass:ModInline( "CtlColor", {|Self,hWndChild, hDCChild | Self, If( GetWindowLong( hWndChild, (-12) ) == 65535 .OR.  GetParent( hWndChild ) <> ::hWnd,,  SendMessage( hWndChild, 1024+1030, hDCChild ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "CtlColor", {|Self,hWndChild, hDCChild | Self, If( GetWindowLong( hWndChild, (-12) ) == 65535 .OR.  GetParent( hWndChild ) <> ::hWnd,,  SendMessage( hWndChild, 1024+1030, hDCChild ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER cTitle(cNewTitle); _HB_MEMBER _cTitle(cNewTitle); IIF( .F., s_oClass:ModMethod( "cTitle", @TWindow_cTitle(), 1 + 32, .F. ), s_oClass:AddMethod( "cTitle", @TWindow_cTitle(), 1 + 32, .F. ) ) ; IIF( .F., s_oClass:ModMethod( "_cTitle", @TWindow_cTitle() ), s_oClass:AddMethod( "_cTitle", @TWindow_cTitle() ) ) ;

   _HB_MEMBER Cut(); IIF( .F., s_oClass:ModInline( "Cut", {|Self | Self, If( ::bCut <> nil, Eval( ::bCut ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Cut", {|Self | Self, If( ::bCut <> nil, Eval( ::bCut ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER DdeInitiate( hWndClient, nAppName, nTopicName); IIF( .F., s_oClass:ModMethod( "DdeInitiate", @TWindow_DdeInitiate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DdeInitiate", @TWindow_DdeInitiate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DdeAck(hWndSender, nLParam); IIF( .F., s_oClass:ModInline( "DdeAck", {|Self,hWndSender, nLParam | Self, DdeAck( hWndSender, nLParam ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "DdeAck", {|Self,hWndSender, nLParam | Self, DdeAck( hWndSender, nLParam ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )




   _HB_MEMBER DdeExecute(hWndSender, nCommand); IIF( .F., s_oClass:ModInline( "DdeExecute", {|Self,hWndSender, nCommand | Self, If( ::bDdeExecute <> nil, Eval( ::bDdeExecute, hWndSender, DdeGetCommand( nCommand ) ),), PostMessage( hWndSender, (992+4), ::hWnd, nMakeLong( 1, nCommand ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "DdeExecute", {|Self,hWndSender, nCommand | Self, If( ::bDdeExecute <> nil, Eval( ::bDdeExecute, hWndSender, DdeGetCommand( nCommand ) ),), PostMessage( hWndSender, (992+4), ::hWnd, nMakeLong( 1, nCommand ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER DdeTerminate(hWndSender); IIF( .F., s_oClass:ModInline( "DdeTerminate", {|Self,hWndSender | Self, DdeTerminate( hWndSender ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "DdeTerminate", {|Self,hWndSender | Self, DdeTerminate( hWndSender ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Delete(); IIF( .F., s_oClass:ModInline( "Delete", {|Self | Self, If( ::bDelete <> nil, Eval( ::bDelete, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Delete", {|Self | Self, If( ::bDelete <> nil, Eval( ::bDelete, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER DestroyToolTip(); IIF( .F., s_oClass:ModMethod( "DestroyToolTip", @TWindow_DestroyToolTip(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DestroyToolTip", @TWindow_DestroyToolTip(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER Disable(); IIF( .F., s_oClass:ModInline( "Disable", {|Self | Self, ::lActive := .F., If( ::hWnd <> 0, EnableWindow( ::hWnd, .F. ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Disable", {|Self | Self, ::lActive := .F., If( ::hWnd <> 0, EnableWindow( ::hWnd, .F. ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER DispBegin( lCreateDC); IIF( .F., s_oClass:ModMethod( "DispBegin", @TWindow_DispBegin(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DispBegin", @TWindow_DispBegin(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DispEnd( aRestore); IIF( .F., s_oClass:ModMethod( "DispEnd", @TWindow_DispEnd(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DispEnd", @TWindow_DispEnd(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DrawItem( nIdCtl, pItemStruct); IIF( .F., s_oClass:ModMethod( "DrawItem", @TWindow_DrawItem(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DrawItem", @TWindow_DrawItem(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DropFiles( hDrop); IIF( .F., s_oClass:ModMethod( "DropFiles", @TWindow_DropFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DropFiles", @TWindow_DropFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DropOver( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "DropOver", @TWindow_DropOver(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DropOver", @TWindow_DropOver(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER Enable(); IIF( .F., s_oClass:ModInline( "Enable", {|Self | Self, ::lActive := .T., If( ::hWnd <> 0, EnableWindow( ::hWnd, .T. ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Enable", {|Self | Self, ::lActive := .T., If( ::hWnd <> 0, EnableWindow( ::hWnd, .T. ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER End( ); IIF( .F., s_oClass:ModInline( "End", { | Self, lEnd | If( lEnd := ::lValid(), ::PostMsg( 16 ),), lEnd }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "End", { | Self, lEnd | If( lEnd := ::lValid(), ::PostMsg( 16 ),), lEnd }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER EndPaint(); IIF( .F., s_oClass:ModInline( "EndPaint", {|Self | Self, ::nPaintCount--, EndPaint( ::hWnd, ::cPS ), ::cPS := nil, ::hDC := nil, 0 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "EndPaint", {|Self | Self, ::nPaintCount--, EndPaint( ::hWnd, ::cPS ), ::cPS := nil, ::hDC := nil, 0 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER EraseBkGnd(hDC); IIF( .F., s_oClass:ModInline( "EraseBkGnd", {|Self,hDC | Self, 1 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "EraseBkGnd", {|Self,hDC | Self, 1 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Event(nEvent); IIF( .F., s_oClass:ModInline( "Event", {|Self,nEvent | Self, ::aEvents[ nEvent ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Event", {|Self,nEvent | Self, ::aEvents[ nEvent ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER EveCount(); IIF( .F., s_oClass:ModInline( "EveCount", {|Self | Self, Len( ::aEvents ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "EveCount", {|Self | Self, Len( ::aEvents ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Find(); IIF( .F., s_oClass:ModInline( "Find", {|Self | Self, If( ::bFind <> nil, Eval( ::bFind, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Find", {|Self | Self, If( ::bFind <> nil, Eval( ::bFind, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER FindNext(); IIF( .F., s_oClass:ModInline( "FindNext", {|Self | Self, If( ::bFindNext <> nil, Eval( ::bFindNext, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "FindNext", {|Self | Self, If( ::bFindNext <> nil, Eval( ::bFindNext, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER FirstActiveCtrl(); IIF( .F., s_oClass:ModMethod( "FirstActiveCtrl", @TWindow_FirstActiveCtrl(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FirstActiveCtrl", @TWindow_FirstActiveCtrl(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER FloodFill(nRow, nCol, nRGBColor); IIF( .F., s_oClass:ModInline( "FloodFill", {|Self,nRow, nCol, nRGBColor | Self, FloodFill( ::hDC, nRow, nCol, nRGBColor ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "FloodFill", {|Self,nRow, nCol, nRGBColor | Self, FloodFill( ::hDC, nRow, nCol, nRGBColor ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER GenDbf(); IIF( .F., s_oClass:ModMethod( "GenDbf", @TWindow_GenDbf(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GenDbf", @TWindow_GenDbf(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER cGenPrg(); IIF( .F., s_oClass:ModMethod( "cGenPrg", @TWindow_cGenPrg(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "cGenPrg", @TWindow_cGenPrg(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   _HB_MEMBER nGetChrHeight(); IIF( .F., s_oClass:ModInline( "nGetChrHeight", {|Self | Self, ::nChrHeight := nWndChrHeight( ::hWnd, If( ::oFont <> nil, ::oFont:hFont,) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "nGetChrHeight", {|Self | Self, ::nChrHeight := nWndChrHeight( ::hWnd, If( ::oFont <> nil, ::oFont:hFont,) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER GetCliRect(); IIF( .F., s_oClass:ModMethod( "GetCliRect", @TWindow_GetCliRect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetCliRect", @TWindow_GetCliRect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GetFont(); IIF( .F., s_oClass:ModMethod( "GetFont", @TWindow_GetFont(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetFont", @TWindow_GetFont(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GetRect(); IIF( .F., s_oClass:ModMethod( "GetRect", @TWindow_GetRect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetRect", @TWindow_GetRect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   _HB_MEMBER GetDC(); IIF( .F., s_oClass:ModInline( "GetDC", {|Self | Self, If( ::hDC == nil, ::hDC := GetDC( ::hWnd ),), If( ::nPaintCount == nil, ::nPaintCount := 1, ::nPaintCount++ ), ::hDC }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetDC", {|Self | Self, If( ::hDC == nil, ::hDC := GetDC( ::hWnd ),), If( ::nPaintCount == nil, ::nPaintCount := 1, ::nPaintCount++ ), ::hDC }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER GetDlgCode( nLastKey ); IIF( !.F., s_oClass:AddVirtual( "GetDlgCode" ), )



   _HB_MEMBER GetMinMaxInfo(pMinMaxInfo); IIF( .F., s_oClass:ModInline( "GetMinMaxInfo", {|Self,pMinMaxInfo | Self, If( ::aMinMaxInfo <> nil, SetMinMax( pMinMaxInfo, ::aMinMaxInfo ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetMinMaxInfo", {|Self,pMinMaxInfo | Self, If( ::aMinMaxInfo <> nil, SetMinMax( pMinMaxInfo, ::aMinMaxInfo ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )





   _HB_MEMBER GetWidth( cText, oFont ); IIF( .F., s_oClass:ModInline( "GetWidth", { | Self, cText, oFont, nSize |  oFont := If( oFont == nil, ::oFont, oFont ), nSize := GetTextWidth( ::GetDC(), cText, If( oFont <> nil, oFont:hFont,) ), ::ReleaseDC(), nSize }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetWidth", { | Self, cText, oFont, nSize |  oFont := If( oFont == nil, ::oFont, oFont ), nSize := GetTextWidth( ::GetDC(), cText, If( oFont <> nil, oFont:hFont,) ), ::ReleaseDC(), nSize }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER GetText(); IIF( .F., s_oClass:ModInline( "GetText", {|Self | Self, GetWindowText( ::hWnd ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetText", {|Self | Self, GetWindowText( ::hWnd ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER GoNextCtrl( hCtrl); IIF( .F., s_oClass:ModMethod( "GoNextCtrl", @TWindow_GoNextCtrl(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoNextCtrl", @TWindow_GoNextCtrl(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GoPrevCtrl( hCtrl); IIF( .F., s_oClass:ModMethod( "GoPrevCtrl", @TWindow_GoPrevCtrl(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoPrevCtrl", @TWindow_GoPrevCtrl(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GotFocus(); IIF( .F., s_oClass:ModMethod( "GotFocus", @TWindow_GotFocus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GotFocus", @TWindow_GotFocus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GoTop(); IIF( .F., s_oClass:ModInline( "GoTop", {|Self | Self, BringWindowToTop( ::hWnd ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GoTop", {|Self | Self, BringWindowToTop( ::hWnd ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
















      _HB_MEMBER HandleEvent( nMsg, nWParam, nLParam ); IIF( .F., s_oClass:ModMethod( "HandleEvent", @WndHandleEvent(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HandleEvent", @WndHandleEvent(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER HardCopy( nScale, lFromUser); IIF( .F., s_oClass:ModMethod( "HardCopy", @TWindow_HardCopy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HardCopy", @TWindow_HardCopy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nHeight(nNewHeight); _HB_MEMBER _nHeight(nNewHeight); IIF( .F., s_oClass:ModMethod( "nHeight", @TWindow_nHeight(), 1 + 32, .F. ), s_oClass:AddMethod( "nHeight", @TWindow_nHeight(), 1 + 32, .F. ) ) ; IIF( .F., s_oClass:ModMethod( "_nHeight", @TWindow_nHeight() ), s_oClass:AddMethod( "_nHeight", @TWindow_nHeight() ) ) ;



   _HB_MEMBER Help(); IIF( .F., s_oClass:ModInline( "Help", {|Self | Self, ::HelpTopic() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Help", {|Self | Self, ::HelpTopic() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER HelpF1(); IIF( .F., s_oClass:ModInline( "HelpF1", {|Self | Self, If( ::oMItemSelect <> nil, ::oMItemSelect:HelpTopic(), ::HelpTopic() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "HelpF1", {|Self | Self, If( ::oMItemSelect <> nil, ::oMItemSelect:HelpTopic(), ::HelpTopic() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER HelpTopic(); IIF( .F., s_oClass:ModMethod( "HelpTopic", @TWindow___HelpTopic(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ), s_oClass:AddMethod( "HelpTopic", @TWindow___HelpTopic(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ) );

   _HB_MEMBER Hide(); IIF( .F., s_oClass:ModInline( "Hide", {|Self | Self, ShowWindow( ::hWnd, 0 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Hide", {|Self | Self, ShowWindow( ::hWnd, 0 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER HScroll( nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "HScroll", @TWindow_HScroll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HScroll", @TWindow_HScroll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Iconize(); IIF( .F., s_oClass:ModInline( "Iconize", {|Self | Self, CloseWindow( ::hWnd ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Iconize", {|Self | Self, CloseWindow( ::hWnd ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER IsIconic(); IIF( .F., s_oClass:ModInline( "IsIconic", {|Self | Self, IsIconic( ::hWnd ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "IsIconic", {|Self | Self, IsIconic( ::hWnd ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER InitMenuPopup( hPopup, nIndex, lSystem); IIF( .F., s_oClass:ModMethod( "InitMenuPopup", @TWindow_InitMenuPopup(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "InitMenuPopup", @TWindow_InitMenuPopup(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Inspect( cData ); IIF( !.F., s_oClass:AddVirtual( "Inspect" ), )

   _HB_MEMBER KeyDown( nKey, nFlags); IIF( .F., s_oClass:ModMethod( "KeyDown", @TWindow_KeyDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "KeyDown", @TWindow_KeyDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER KeyChar( nKey, nFlags); IIF( .F., s_oClass:ModMethod( "KeyChar", @TWindow_KeyChar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "KeyChar", @TWindow_KeyChar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER KillFocus(hWndFocus); IIF( .F., s_oClass:ModInline( "KillFocus", {|Self,hWndFocus | Self, ::LostFocus( hWndFocus ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "KillFocus", {|Self,hWndFocus | Self, ::LostFocus( hWndFocus ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER LastActiveCtrl(); IIF( .F., s_oClass:ModMethod( "LastActiveCtrl", @TWindow_LastActiveCtrl(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LastActiveCtrl", @TWindow_LastActiveCtrl(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER LButtonDown( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "LButtonDown", @TWindow_LButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LButtonDown", @TWindow_LButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER LButtonUp( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "LButtonUp", @TWindow_LButtonUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LButtonUp", @TWindow_LButtonUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER LDblClick( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "LDblClick", @TWindow_LDblClick(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LDblClick", @TWindow_LDblClick(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Line( nTop, nLeft, nBottom, nRight); IIF( .F., s_oClass:ModMethod( "Line", @TWindow_Line(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Line", @TWindow_Line(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Link( lSubClass); IIF( .F., s_oClass:ModMethod( "Link", @TWindow_Link(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Link", @TWindow_Link(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Load( cInfo); IIF( .F., s_oClass:ModMethod( "Load", @TWindow_Load(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Load", @TWindow_Load(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER LoadFile( cFileName); IIF( .F., s_oClass:ModMethod( "LoadFile", @TWindow_LoadFile(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LoadFile", @TWindow_LoadFile(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER LostFocus( hWndGetFocus); IIF( .F., s_oClass:ModMethod( "LostFocus", @TWindow_LostFocus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LostFocus", @TWindow_LostFocus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER MenuChar( nAscii, nType, nHMenu); IIF( .F., s_oClass:ModMethod( "MenuChar", @TWindow_MenuChar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MenuChar", @TWindow_MenuChar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER MenuSelect( nIdItem, nFlags, nHMenu); IIF( .F., s_oClass:ModMethod( "MenuSelect", @TWindow_MenuSelect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MenuSelect", @TWindow_MenuSelect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER Moved(nRow, nCol); IIF( .F., s_oClass:ModInline( "Moved", {|Self,nRow, nCol | Self, If( ::bMoved <> nil, Eval( ::bMoved, nRow, nCol ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Moved", {|Self,nRow, nCol | Self, If( ::bMoved <> nil, Eval( ::bMoved, nRow, nCol ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )




   _HB_MEMBER NcActivate(lOnOff); IIF( .F., s_oClass:ModInline( "NcActivate", {|Self,lOnOff | Self, If( ! lOnOff .AND.  ::bLostFocus <> nil .AND.  GetFocus() <> ::hWnd, Eval( ::bLostFocus, Self, GetFocus() ),), nil }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "NcActivate", {|Self,lOnOff | Self, If( ! lOnOff .AND.  ::bLostFocus <> nil .AND.  GetFocus() <> ::hWnd, Eval( ::bLostFocus, Self, GetFocus() ),), nil }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER NcMouseMove( nHitTestCode, nRow, nCol); IIF( .F., s_oClass:ModMethod( "NcMouseMove", @TWindow_NcMouseMove(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "NcMouseMove", @TWindow_NcMouseMove(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER lWhen(); IIF( .F., s_oClass:ModInline( "lWhen", {|Self | Self, If( ::bWhen <> nil, Eval( ::bWhen ), .T. ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lWhen", {|Self | Self, If( ::bWhen <> nil, Eval( ::bWhen ), .T. ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Maximize(); IIF( .F., s_oClass:ModInline( "Maximize", {|Self | Self, ShowWindow( ::hWnd, 3 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Maximize", {|Self | Self, ShowWindow( ::hWnd, 3 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER MButtonDown( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "MButtonDown", @TWindow_MButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MButtonDown", @TWindow_MButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER MButtonUp( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "MButtonUp", @TWindow_MButtonUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MButtonUp", @TWindow_MButtonUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER MeasureItem( nIdCtl, pMitStruct); IIF( .F., s_oClass:ModMethod( "MeasureItem", @TWindow_MeasureItem(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MeasureItem", @TWindow_MeasureItem(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Minimize(); IIF( .F., s_oClass:ModInline( "Minimize", {|Self | Self, ShowWindow( ::hWnd, 6 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Minimize", {|Self | Self, ShowWindow( ::hWnd, 6 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER MouseMove( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "MouseMove", @TWindow_MouseMove(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MouseMove", @TWindow_MouseMove(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER MouseWheel(nKey, nDelta, nXPos, nYPos); IIF( .F., s_oClass:ModInline( "MouseWheel", {|Self,nKey, nDelta, nXPos, nYPos | Self, If( ::bMouseWheel <> nil, Eval( ::bMouseWheel, nKey, nDelta, nXPos, nYPos ), nil ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "MouseWheel", {|Self,nKey, nDelta, nXPos, nYPos | Self, If( ::bMouseWheel <> nil, Eval( ::bMouseWheel, nKey, nDelta, nXPos, nYPos ), nil ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Move( nTop, nLeft, nWidth, nHeight, lRepaint); IIF( .F., s_oClass:ModMethod( "Move", @TWindow_Move(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Move", @TWindow_Move(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Normal(); IIF( .F., s_oClass:ModInline( "Normal", {|Self | Self, ShowWindow( ::hWnd, 1 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Normal", {|Self | Self, ShowWindow( ::hWnd, 1 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Notify( nIdCtrl, nPtrNMHDR); IIF( .F., s_oClass:ModMethod( "Notify", @TWindow_Notify(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Notify", @TWindow_Notify(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER NcPaint( ); IIF( !.F., s_oClass:AddVirtual( "NcPaint" ), )


   _HB_MEMBER nWidth(nNewWidth); _HB_MEMBER _nWidth(nNewWidth); IIF( .F., s_oClass:ModMethod( "nWidth", @TWindow_nWidth(), 1 + 32, .F. ), s_oClass:AddMethod( "nWidth", @TWindow_nWidth(), 1 + 32, .F. ) ) ; IIF( .F., s_oClass:ModMethod( "_nWidth", @TWindow_nWidth() ), s_oClass:AddMethod( "_nWidth", @TWindow_nWidth() ) ) ;

   _HB_MEMBER Paint(); IIF( .F., s_oClass:ModMethod( "Paint", @TWindow_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Paint", @TWindow_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER PaletteChanged(hWndPalChg); IIF( .F., s_oClass:ModInline( "PaletteChanged", {|Self,hWndPalChg | Self, PalChgEvent( hWndPalChg ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "PaletteChanged", {|Self,hWndPalChg | Self, PalChgEvent( hWndPalChg ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Paste(); IIF( .F., s_oClass:ModInline( "Paste", {|Self | Self, If( ::bPaste <> nil, Eval( ::bPaste, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Paste", {|Self | Self, If( ::bPaste <> nil, Eval( ::bPaste, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER PostMsg(nMsg, nWParam, nLParam); IIF( .F., s_oClass:ModInline( "PostMsg", {|Self,nMsg, nWParam, nLParam | Self, PostMessage( ::hWnd, nMsg, nWParam, nLParam ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "PostMsg", {|Self,nMsg, nWParam, nLParam | Self, PostMessage( ::hWnd, nMsg, nWParam, nLParam ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Print( oTarget, nRow, nCol, nScale); IIF( .F., s_oClass:ModMethod( "Print", @TWindow_Print(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Print", @TWindow_Print(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Property(n); IIF( .F., s_oClass:ModInline( "Property", {|Self,n | Self, ::aProperties[ n ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Property", {|Self,n | Self, ::aProperties[ n ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER Properties(); IIF( .F., s_oClass:ModInline( "Properties", {|Self | Self, If( ::bProperties <> nil, Eval( ::bProperties, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Properties", {|Self | Self, If( ::bProperties <> nil, Eval( ::bProperties, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER PropCount(); IIF( .F., s_oClass:ModInline( "PropCount", {|Self | Self, Len( ::aProperties ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "PropCount", {|Self | Self, Len( ::aProperties ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER QueryDragIcon(); IIF( .F., s_oClass:ModInline( "QueryDragIcon", {|Self | Self, If( ::oIcon <> nil, ::oIcon:hIcon, ExtractIcon( "user.exe" ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "QueryDragIcon", {|Self | Self, If( ::oIcon <> nil, ::oIcon:hIcon, ExtractIcon( "user.exe" ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER QueryEndSession(); IIF( .F., s_oClass:ModInline( "QueryEndSession", {|Self | Self, If( ::End(), 1, 0 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "QueryEndSession", {|Self | Self, If( ::End(), 1, 0 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER QueryNewPalette(); IIF( .F., s_oClass:ModInline( "QueryNewPalette", {|Self | Self, If( IsIconic( ::hWnd ), 0, QryNewPalEvent() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "QueryNewPalette", {|Self | Self, If( IsIconic( ::hWnd ), 0, QryNewPalEvent() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER RButtonDown( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "RButtonDown", @TWindow_RButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RButtonDown", @TWindow_RButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER RButtonUp( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "RButtonUp", @TWindow_RButtonUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RButtonUp", @TWindow_RButtonUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Restore(); IIF( .F., s_oClass:ModInline( "Restore", {|Self | Self, ShowWindow( ::hWnd, 9 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Restore", {|Self | Self, ShowWindow( ::hWnd, 9 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Destroy(); IIF( .F., s_oClass:ModMethod( "Destroy", @TWindow_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Destroy", @TWindow_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ReDo(); IIF( .F., s_oClass:ModInline( "ReDo", {|Self | Self, If( ::bReDo <> nil, Eval( ::bReDo, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ReDo", {|Self | Self, If( ::bReDo <> nil, Eval( ::bReDo, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER ReleaseDC(); IIF( .F., s_oClass:ModInline( "ReleaseDC", {|Self | Self, If( --::nPaintCount == 0, If( ReleaseDC( ::hWnd, ::hDC ), ::hDC := nil,),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ReleaseDC", {|Self | Self, If( --::nPaintCount == 0, If( ReleaseDC( ::hWnd, ::hDC ), ::hDC := nil,),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )



   _HB_MEMBER Refresh(lErase); IIF( .F., s_oClass:ModInline( "Refresh", {|Self,lErase | Self, InvalidateRect( ::hWnd, If( lErase <> nil, lErase, .T. ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Refresh", {|Self,lErase | Self, InvalidateRect( ::hWnd, If( lErase <> nil, lErase, .T. ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Register( nClsStyle); IIF( .F., s_oClass:ModMethod( "Register", @TWindow_Register(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Register", @TWindow_Register(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ReSize( nSizeType, nWidth, nHeight); IIF( .F., s_oClass:ModMethod( "ReSize", @TWindow_ReSize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReSize", @TWindow_ReSize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ReadFile(cFileName); IIF( .F., s_oClass:ModInline( "ReadFile", {|Self,cFileName | Self, uLoadObject( cFileName ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ReadFile", {|Self,cFileName | Self, uLoadObject( cFileName ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Replace(); IIF( .F., s_oClass:ModInline( "Replace", {|Self | Self, If( ::bReplace <> nil, Eval( ::bReplace, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Replace", {|Self | Self, If( ::bReplace <> nil, Eval( ::bReplace, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Save(); IIF( .F., s_oClass:ModMethod( "Save", @TWindow_Save(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Save", @TWindow_Save(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SaveFile( cFileName); IIF( .F., s_oClass:ModMethod( "SaveFile", @TWindow_SaveFile(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SaveFile", @TWindow_SaveFile(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SaveToBmp( cBmpFile); IIF( .F., s_oClass:ModMethod( "SaveToBmp", @TWindow_SaveToBmp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SaveToBmp", @TWindow_SaveToBmp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SaveToText( nIndent); IIF( .F., s_oClass:ModMethod( "SaveToText", @TWindow_SaveToText(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SaveToText", @TWindow_SaveToText(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER Say( nRow, nCol, cText, nClrFore, nClrBack, oFont, lPixel, lTransparent, nAlign); IIF( .F., s_oClass:ModMethod( "Say", @TWindow_Say(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Say", @TWindow_Say(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SayBitmap( nRow, nCol, coBitmap, nWidth, nHeight); IIF( .F., s_oClass:ModMethod( "SayBitmap", @TWindow_SayBitmap(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SayBitmap", @TWindow_SayBitmap(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SayRect( nRow, nCol, cText, nClrFore, nClrBack, nWidth); IIF( .F., s_oClass:ModMethod( "SayRect", @TWindow_SayRect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SayRect", @TWindow_SayRect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));





   _HB_MEMBER SelColor(lFore); IIF( .F., s_oClass:ModInline( "SelColor", {|Self,lFore | Self, lFore := If( lFore == nil, lFore := .F., lFore ), ::SetColor( If( lFore, ChooseColor( ::nClrText ), ::nClrText ), If( lFore, ::nClrPane, ChooseColor( ::nClrPane ) ) ), ::Refresh() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SelColor", {|Self,lFore | Self, lFore := If( lFore == nil, lFore := .F., lFore ), ::SetColor( If( lFore, ChooseColor( ::nClrText ), ::nClrText ), If( lFore, ::nClrPane, ChooseColor( ::nClrPane ) ) ), ::Refresh() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SelectAll(); IIF( .F., s_oClass:ModInline( "SelectAll", {|Self | Self, If( ::bSelectAll <> nil, Eval( ::bSelectAll, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SelectAll", {|Self | Self, If( ::bSelectAll <> nil, Eval( ::bSelectAll, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER SendMsg(nMsg, nWParam, nLParam); IIF( .F., s_oClass:ModInline( "SendMsg", {|Self,nMsg, nWParam, nLParam | Self, SendMessage( ::hWnd, nMsg, nWParam, nLParam ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SendMsg", {|Self,nMsg, nWParam, nLParam | Self, SendMessage( ::hWnd, nMsg, nWParam, nLParam ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetBounds( nLeft, nTop, nRight, nBottom); IIF( .F., s_oClass:ModMethod( "SetBounds", @TWindow_SetBounds(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetBounds", @TWindow_SetBounds(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));




   _HB_MEMBER SetBrush(oBrush); IIF( .F., s_oClass:ModInline( "SetBrush", {|Self,oBrush | Self, If( ::oBrush <> nil, ::oBrush:End(),), ::oBrush := oBrush, If( oBrush:nCount == nil, oBrush:nCount := 1, oBrush:nCount++), ::Refresh() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetBrush", {|Self,oBrush | Self, If( ::oBrush <> nil, ::oBrush:End(),), ::oBrush := oBrush, If( oBrush:nCount == nil, oBrush:nCount := 1, oBrush:nCount++), ::Refresh() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetColor( nClrFore, nClrBack, oBrush); IIF( .F., s_oClass:ModMethod( "SetColor", @TWindow_SetColor(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetColor", @TWindow_SetColor(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetCoors( oRect); IIF( .F., s_oClass:ModMethod( "SetCoors", @TWindow_SetCoors(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetCoors", @TWindow_SetCoors(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetFocus(); IIF( .F., s_oClass:ModMethod( "SetFocus", @TWindow___SetFocus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ), s_oClass:AddMethod( "SetFocus", @TWindow___SetFocus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ) );






   _HB_MEMBER SelFont( ); IIF( .F., s_oClass:ModInline( "SelFont", { | Self, nClr | nClr := ::nClrText, ::SetFont( If( ::oFont == nil, TFont():New( ,,,.T. ), ::oFont:Choose( @nClr ) ) ), ::oFont:nCount--, ::nClrText := nClr, ::Refresh() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SelFont", { | Self, nClr | nClr := ::nClrText, ::SetFont( If( ::oFont == nil, TFont():New( ,,,.T. ), ::oFont:Choose( @nClr ) ) ), ::oFont:nCount--, ::nClrText := nClr, ::Refresh() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetFont( oFont); IIF( .F., s_oClass:ModMethod( "SetFont", @TWindow_SetFont(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetFont", @TWindow_SetFont(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));




   _HB_MEMBER SetIcon(oIcon); IIF( .F., s_oClass:ModInline( "SetIcon", {|Self,oIcon | Self, If( ::oIcon <> nil, ::oIcon:End(), nil ), ::oIcon := oIcon, If( ::oIcon <> nil, ::SendMsg( 128, 0, oIcon:hIcon ), nil ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetIcon", {|Self,oIcon | Self, If( ::oIcon <> nil, ::oIcon:End(), nil ), ::oIcon := oIcon, If( ::oIcon <> nil, ::SendMsg( 128, 0, oIcon:hIcon ), nil ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )



   _HB_MEMBER SetMenu(oMenu); IIF( .F., s_oClass:ModInline( "SetMenu", {|Self,oMenu | Self, ::oMenu := oMenu, oMenu:oWnd := Self, SetMenu( ::hWnd, oMenu:hMenu ), If( oMenu:oAccTable <> nil, oMenu:oAccTable:Activate(), nil ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetMenu", {|Self,oMenu | Self, ::oMenu := oMenu, oMenu:oWnd := Self, SetMenu( ::hWnd, oMenu:hMenu ), If( oMenu:oAccTable <> nil, oMenu:oAccTable:Activate(), nil ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetMsg( cText, lDefault); IIF( .F., s_oClass:ModMethod( "SetMsg", @TWindow_SetMsg(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetMsg", @TWindow_SetMsg(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   _HB_MEMBER SetPixel(nX, nY, nColor); IIF( .F., s_oClass:ModInline( "SetPixel", {|Self,nX, nY, nColor | Self, SetPixel( ::GetDC(), nX, nY, nColor ), ::ReleaseDC() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetPixel", {|Self,nX, nY, nColor | Self, SetPixel( ::GetDC(), nX, nY, nColor ), ::ReleaseDC() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )



   _HB_MEMBER SetSize(nWidth, nHeight, lRepaint); IIF( .F., s_oClass:ModInline( "SetSize", {|Self,nWidth, nHeight, lRepaint | Self, WndSetSize( ::hWnd, nWidth, nHeight, lRepaint ), ::CoorsUpdate() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetSize", {|Self,nWidth, nHeight, lRepaint | Self, WndSetSize( ::hWnd, nWidth, nHeight, lRepaint ), ::CoorsUpdate() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )



   _HB_MEMBER SetText(cText); IIF( .F., s_oClass:ModInline( "SetText", {|Self,cText | Self, ::cCaption := cText, SetWindowText( ::hWnd, cText ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetText", {|Self,cText | Self, ::cCaption := cText, SetWindowText( ::hWnd, cText ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Shadow(); IIF( .F., s_oClass:ModMethod( "Shadow", @TWindow_Shadow(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Shadow", @TWindow_Shadow(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Show(); IIF( .F., s_oClass:ModInline( "Show", {|Self | Self, ShowWindow( ::hWnd, 8 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Show", {|Self | Self, ShowWindow( ::hWnd, 8 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER ShowToolTip( nRow, nCol, cToolTip); IIF( .F., s_oClass:ModMethod( "ShowToolTip", @TWindow_ShowToolTip(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ShowToolTip", @TWindow_ShowToolTip(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SysCommand( nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "SysCommand", @TWindow_SysCommand(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SysCommand", @TWindow_SysCommand(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER TaskBar(nWParam, nLParam); IIF( .F., s_oClass:ModInline( "TaskBar", {|Self,nWParam, nLParam | Self, If( ::bTaskBar <> nil, Eval( ::bTaskBar, nWParam, nLParam ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "TaskBar", {|Self,nWParam, nLParam | Self, If( ::bTaskBar <> nil, Eval( ::bTaskBar, nWParam, nLParam ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Timer(nTimerId); IIF( .F., s_oClass:ModInline( "Timer", {|Self,nTimerId | Self, TimerEvent( nTimerId ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Timer", {|Self,nTimerId | Self, TimerEvent( nTimerId ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER ToolWindow(); IIF( .F., s_oClass:ModMethod( "ToolWindow", @TWindow_ToolWindow(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ToolWindow", @TWindow_ToolWindow(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER UnDo(); IIF( .F., s_oClass:ModInline( "UnDo", {|Self | Self, If( ::bUnDo <> nil, Eval( ::bUnDo, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "UnDo", {|Self | Self, If( ::bUnDo <> nil, Eval( ::bUnDo, Self ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER UnLink(); IIF( .F., s_oClass:ModMethod( "UnLink", @TWindow_UnLink(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "UnLink", @TWindow_UnLink(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER UnZip(nPercent); IIF( .F., s_oClass:ModInline( "UnZip", {|Self,nPercent | Self, If( ::bUnZip <> nil, Eval( ::bUnZip, nPercent ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "UnZip", {|Self,nPercent | Self, If( ::bUnZip <> nil, Eval( ::bUnZip, nPercent ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )



   _HB_MEMBER ClientEdge(); IIF( .F., s_oClass:ModInline( "ClientEdge", {|Self | Self, SetWindowLong( ::hWnd, -20, nOr( GetWindowLong( ::hWnd, -20 ), 512 ) ), ::Refresh() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ClientEdge", {|Self | Self, SetWindowLong( ::hWnd, -20, nOr( GetWindowLong( ::hWnd, -20 ), 512 ) ), ::Refresh() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER Zip(nZipInfo); IIF( .F., s_oClass:ModInline( "Zip", {|Self,nZipInfo | Self, If( ::bZip <> nil, Eval( ::bZip, nZipInfo ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Zip", {|Self,nZipInfo | Self, If( ::bZip <> nil, Eval( ::bZip, nZipInfo ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )



   _HB_MEMBER Update(); IIF( .F., s_oClass:ModInline( "Update", {|Self | Self, AEval( ::aControls, { | o | If( ( Upper( o:ClassName() ) $ "TFOLDER;TFOLDEREX" ), o:Update(), If( o:lUpdate, o:Refresh(),)) } ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Update", {|Self | Self, AEval( ::aControls, { | o | If( ( Upper( o:ClassName() ) $ "TFOLDER;TFOLDEREX" ), o:Update(), If( o:lUpdate, o:Refresh(),)) } ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER lValid(); IIF( .F., s_oClass:ModInline( "lValid", {|Self | Self, If( ::bValid <> nil, Eval( ::bValid, Self ), .T. ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lValid", {|Self | Self, If( ::bValid <> nil, Eval( ::bValid, Self ), .T. ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER VScroll( nCode, nPos); IIF( .F., s_oClass:ModMethod( "VScroll", @TWindow_VScroll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "VScroll", @TWindow_VScroll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   _HB_MEMBER nVertRes( ); IIF( .F., s_oClass:ModInline( "nVertRes", { | Self, nRes | nRes := GetDeviceCaps( ::GetDC(), 10  ), ::ReleaseDC(), nRes }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "nVertRes", { | Self, nRes | nRes := GetDeviceCaps( ::GetDC(), 10  ), ::ReleaseDC(), nRes }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )




   _HB_MEMBER nHorzRes( ); IIF( .F., s_oClass:ModInline( "nHorzRes", { | Self, nRes | nRes := GetDeviceCaps( ::GetDC(), 8  ), ::ReleaseDC(), nRes }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "nHorzRes", { | Self, nRes | nRes := GetDeviceCaps( ::GetDC(), 8  ), ::ReleaseDC(), nRes }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER AEvalWhen(); IIF( .F., s_oClass:ModMethod( "AEvalWhen", @TWindow_AEvalWhen(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AEvalWhen", @TWindow_AEvalWhen(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER VbxFireEvent(pEventInfo); IIF( .F., s_oClass:ModInline( "VbxFireEvent", {|Self,pEventInfo | Self, VBXEvent( pEventInfo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "VbxFireEvent", {|Self,pEventInfo | Self, VBXEvent( pEventInfo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetAlphaLevel(); IIF( .F., s_oClass:ModMethod( "SetAlphaLevel", @TWindow_SetAlphaLevel(), 4 + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetAlphaLevel", @TWindow_SetAlphaLevel(), 4 + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nSeeThroClr(); IIF( .F., s_oClass:ModInline( "nSeeThroClr", {|Self | Self, ::hAlphaColor }, 1, .F. ), s_oClass:AddInline( "nSeeThroClr", {|Self | Self, ::hAlphaColor }, 1, .F. ) )
   _HB_MEMBER nOpacity(); IIF( .F., s_oClass:ModInline( "nOpacity", {|Self | Self, ::hAlphaLevel }, 1, .F. ), s_oClass:AddInline( "nOpacity", {|Self | Self, ::hAlphaLevel }, 1, .F. ) )
   _HB_MEMBER _nSeeThroClr(nNew); IIF( .F., s_oClass:ModInline( "_nSeeThroClr", {|Self,nNew | Self, ( ::hAlphaColor := nNew, ::SetAlphaLevel(), ::hAlphaColor ) }, 1 ), s_oClass:AddInline( "_nSeeThroClr", {|Self,nNew | Self, ( ::hAlphaColor := nNew, ::SetAlphaLevel(), ::hAlphaColor ) }, 1 ) )
   _HB_MEMBER _nOpacity(nNew); IIF( .F., s_oClass:ModInline( "_nOpacity", {|Self,nNew | Self, ( ::hAlphaLevel := nNew, ::SetAlphaLevel(), ::hAlphaLevel ) }, 1 ), s_oClass:AddInline( "_nOpacity", {|Self,nNew | Self, ( ::hAlphaLevel := nNew, ::SetAlphaLevel(), ::hAlphaLevel ) }, 1 ) )

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TWindow ;



UTILITY STATIC function TWindow_Register( nClsStyle) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local hUser

   IIF( ::lRegistered == nil, ::lRegistered := .F., ) ;

   if ::lRegistered
      return nil
   endif




      hUser = GetInstance()




   IIF( nClsStyle == nil, nClsStyle := nOR( 1, 2 ), ) ; IIF( ::nClrPane == nil, ::nClrPane := GetSysColor( 5 ), ); IIF( ::oBrush == nil, ::oBrush := TBrush():New( , ::nClrPane ), );

   nClsStyle = nOr( nClsStyle, 16384, 8 )

   if GetClassInfo( hUser, ::ClassName() ) == nil






         ::lRegistered = RegisterClass( ::ClassName(), nClsStyle,,, hUser, 0, ::oBrush:hBrush,,, If( ::oIcon <> nil, ::oIcon:hIcon, 0 ) )

   else
      ::lRegistered = .T.
   endif

return nil



UTILITY STATIC function TWindow_Create( cClsName) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow




   IIF( cClsName == nil, cClsName := ::ClassName(), ) ; IIF( ::cCaption == nil, ::cCaption := "", ); IIF( ::nStyle == nil, ::nStyle := (0 + 12582912 + 524288 + 262144 + 131072 + 65536), ); IIF( ::nTop == nil, ::nTop := 0, ); IIF( ::nLeft == nil, ::nLeft := 0, ); IIF( ::nBottom == nil, ::nBottom := 10, ); IIF( ::nRight == nil, ::nRight := 10, ); IIF( ::nId == nil, ::nId := 0, );

   if ::oWnd <> nil
      ::nStyle = nOR( ::nStyle, 1073741824 )
   endif

   if ::nBottom <> 32768




      ::hWnd = CreateWindow( cClsName, ::cCaption, ::nStyle,  ::nLeft, ::nTop, ::nRight - ::nLeft + 1,  ::nBottom - ::nTop + 1,  If( ::oWnd <> nil, ::oWnd:hWnd, 0 ),  ::nId )
   else



      ::hWnd = CreateWindow( cClsName, ::cCaption, ::nStyle,  ::nLeft, ::nTop, ::nRight, ::nBottom,  If( ::oWnd <> nil, ::oWnd:hWnd, 0 ),  ::nId )
   endif

   if ::hWnd == 0
      WndCreateError( Self )
   else
      ::Link()
   endif

return nil



function WndCreateError( Self )



   local cInfo := Chr( 13 ) + Chr( 10 ) +  "Class: " + ::ClassName() + Chr(13)+Chr(10) +  "Caption: " + cValToChar( ::cCaption )


      cInfo += Chr(13)+Chr(10) + "System Error: " + GetErrMsg()


   Eval( ErrorBlock(), _FwGenError( 6, cInfo ) )

return nil






UTILITY STATIC function TWindow_New( nTop, nLeft, nBottom, nRight, cTitle, nStyle, oMenu, oBrush, oIcon, oWnd, lVScroll, lHScroll, nClrFore, nClrBack, oCursor, cBorder, lSysMenu, lCaption, lMin, lMax, lPixel) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow







   IIF( nTop == nil, nTop := 2, ) ; IIF( nLeft == nil, nLeft := 2, ); IIF( nBottom == nil, nBottom := 20, ); IIF( nRight == nil, nRight := 70, ); IIF( lVScroll == nil, lVScroll := .F., ); IIF( lHScroll == nil, lHScroll := .F., ); IIF( nClrFore == nil, nClrFore := GetSysColor( 8 ), ); IIF( nClrBack == nil, nClrBack := GetSysColor( 5 ), ); IIF( nStyle == nil, nStyle := 0, ); IIF( cBorder == nil, cBorder := "SINGLE", ); IIF( lSysMenu == nil, lSysMenu := .T., ); IIF( lCaption == nil, lCaption := .T., ); IIF( lMin == nil, lMin := .T., ); IIF( lMax == nil, lMax := .T., ); IIF( lPixel == nil, lPixel := .F., );

   if nStyle == 0








      nStyle = nOr( 33554432, If( cBorder == "NONE",   2147483648, 0 ), If( cBorder == "SINGLE", 262144, 0 ), If( lCaption, 12582912, 0 ), If( lSysMenu .AND. lCaption, 524288, 0 ), If( lMin .AND. lCaption, 131072, 0 ), If( lMax .AND. lCaption, 65536, 0 ), If( lVScroll, 2097152, 0 ), If( lHScroll, 1048576, 0 ) )
   endif

   ::nTop      = nTop * If( lPixel, 1, 16 )
   ::nLeft     = nLeft * If( lPixel, 1, 8 )
   ::nBottom   = nBottom * If( lPixel, 1, 16 )
   ::nRight    = nRight * If( lPixel, 1, 8 )
   ::nStyle    = nStyle
   ::cCaption  = cTitle
   ::oCursor   = oCursor
   ::oMenu     = oMenu
   ::oWnd      = oWnd
   ::oIcon     = oIcon
   ::lVisible  = .T.
   ::aControls = {}
   ::nLastKey  = 0
   ::lValidating = .F.










   if ValType( oIcon ) == "C"
      if File( oIcon )
         oIcon := TIcon():New( ,,, oIcon, )
      else
         oIcon := TIcon():New( ,, oIcon,, )
      endif
      ::oIcon = oIcon
   endif

   ::Register()
   ::Create()

   ::SetColor( nClrFore, nClrBack, oBrush )







   if oMenu <> nil
      SetMenu( ::hWnd, oMenu:hMenu )
      oMenu:oWnd = Self
      if oMenu:oAccTable <> nil
         oMenu:oAccTable:Activate()
      endif
   endif

   if lVScroll
      ::oVScroll := TScrollBar():WinNew(,,, (!.F.) .OR. .T., Self,,,,,,,,, .F.,, )
   endif
   if lHScroll
      ::oHScroll := TScrollBar():WinNew(,,, (!.T.), Self,,,,,,,,, .F.,, )
   endif

   ::GetFont()

   SetWndDefault( Self )

return Self






UTILITY STATIC function TWindow_Activate( cShow, bLClicked, bRClicked, bMoved, bResized, bPainted, bKeyDown, bInit, bUp, bDown, bPgUp, bPgDown, bLeft, bRight, bPgLeft, bPgRight, bValid, bDropFiles, bLButtonUp) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local oVScroll, oHScroll

   IIF( cShow == nil, cShow := "NORMAL", ) ;

   ::nResult     = nil
   ::lValidating = .F.

   if bValid <> nil
      ::bValid = bValid
   endif

   if bDropFiles <> nil
      ::bDropFiles = bDropFiles
      DragAcceptFiles( ::hWnd, .T. )
   endif

   if bPainted <> nil
      if Upper( ::ClassName() ) == "TMDIFRAME"



            ::oWndClient:bPainted = bPainted

      else
         ::bPainted  = bPainted
      endif
   endif

   if bLClicked <> nil
      if Upper( ::ClassName() ) == "TMDIFRAME"



            ::oWndClient:bLClicked = bLClicked

      else
         ::bLClicked = bLClicked
      endif
   endif

   if bRClicked <> nil
      if Upper( ::ClassName() ) == "TMDIFRAME"



            ::oWndClient:bRClicked = bRClicked

      else
         ::bRClicked = bRClicked
      endif
   endif



   if Upper( ::ClassName() ) == "TMDIFRAME"

      oVScroll = ::oWndClient:oVScroll
      oHScroll = ::oWndClient:oHScroll

   else
      oVScroll = ::oVScroll
      oHScroll = ::oHScroll
   endif

   if oVScroll <> nil
      if bUp <> nil
         oVScroll:bGoUp = bUp
      else
         if Upper( ::ClassName() ) == "TMDIFRAME"
            oVScroll:bGoUp = { || ScrollWindow( ::oWndClient:hWnd, 0, 20, 0, GetClientRect( ::oWndClient:hWnd ) ) }
         endif
      endif
      if bDown <> nil
         oVScroll:bGoDown = bDown
      else
         if Upper( ::ClassName() ) == "TMDIFRAME"
            oVScroll:bGoDown = { || ScrollWindow( ::oWndClient:hWnd, 0, -20, 0, GetClientRect( ::oWndClient:hWnd ) ) }
         endif
      endif
      if bPgUp <> nil
         oVScroll:bPageUp = bPgUp
      endif
      if bPgDown <> nil
         oVScroll:bPageDown = bPgDown
      endif
   endif

   if oHScroll <> nil
      if bLeft <> nil
         oHScroll:bGoUp = bLeft
      else
         if Upper( ::ClassName() ) == "TMDIFRAME"
            oHScroll:bGoUp = { || ScrollWindow( ::oWndClient:hWnd, 20, 0, 0, GetClientRect( ::oWndClient:hWnd ) ), ReleaseCapture() }
         endif
      endif
      if bRight <> nil
         oHScroll:bGoDown = bRight
      else
         if Upper( ::ClassName() ) == "TMDIFRAME"
            oHScroll:bGoDown = { || ScrollWindow( ::oWndClient:hWnd, -20, 0, 0, GetClientRect( ::oWndClient:hWnd ) ), ReleaseCapture() }
         endif
      endif
      if bPgLeft <> nil
         oHScroll:bPageUp = bPgLeft
      endif
      if bPgRight <> nil
         oHScroll:bPageDown = bPgRight
      endif
   endif

   ::AEvalWhen()

   ShowWindow( ::hWnd, AScan( { "HIDDEN", "NORMAL", "ICONIZED", "MAXIMIZED" }, cShow ) - 1 )
   UpdateWindow( ::hWnd )

   ::lVisible = .T.

   if ! lWRunning()
      SetWndApp( ::hWnd )
   endif

   if ::bInit <> nil
      Eval( ::bInit, Self )
   endif

   ::Resize()

   if ::oWnd == nil
      if ! lWRunning()
         WinRun( Self:hWnd )
      endif
   endif

   if Self <> nil
      ::lVisible = .F.
   endif

return nil



UTILITY STATIC function TWindow_AsyncSelect( nSocket, nLParam) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if ::bSocket <> nil
      Eval( ::bSocket, nSocket, nLParam )
   endif

return nil



UTILITY STATIC function TWindow_Circle( nRow, nCol, nWidth) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   ::GetDC()
   Ellipse( ::hDC, nCol, nRow, nCol + nWidth - 1, nRow + nWidth - 1 )
   ::ReleaseDC()

return nil



UTILITY STATIC function TWindow_Command( nWParam, nLParam) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local nNotifyCode, nID, hWndCtl






      nNotifyCode = nHiWord( nWParam )
      nID         = nLoWord( nWParam )
      hWndCtl     = nLParam


   do case
      case ::oPopup <> nil
           ::oPopup:Command( nID )

      case hWndCtl == 0 .AND. ::oMenu <> nil
           ::oMenu:Command( nID )

      case GetClassName( hWndCtl ) == "ToolbarWindow32"
           oWndFromHwnd( hWndCtl ):Command( nWParam, nLParam )

      case hWndCtl <> 0
           do case
              case nNotifyCode == 0
                   SendMessage( hWndCtl, 1024+1024, 0, 0 )

              case nNotifyCode == 8
                   SendMessage( hWndCtl, 1024+1042, 0, 0 )

              case nNotifyCode == 1
                   SendMessage( hWndCtl, 1024+1029, 0, 0 )










           endcase
   endcase

return nil



UTILITY STATIC function TWindow_CoorsUpdate() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local aRect := GetCoors( ::hWnd )

   ::nTop    = aRect[ 1 ]
   ::nLeft   = aRect[ 2 ]
   ::nBottom = aRect[ 3 ]
   ::nRight  = aRect[ 4 ]

return nil



UTILITY STATIC function TWindow_cTitle(cNewTitle) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if cNewTitle <> nil
      ::SetText( cNewTitle )
      ::cCaption = cNewTitle
   endif

return GetWindowText( ::hWnd )



UTILITY STATIC function TWindow_DdeInitiate( hWndClient, nAppName, nTopicName) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local xRet

   If ::bDdeInit == nil
      return nil
   endif



   xRet := Eval( ::bDdeInit, hWndClient, GlobalGetAtomName( nAppName ), GlobalGetAtomName( nTopicName ) )

   if xRet == Nil .OR. Valtype(xRet) <> "L" .OR. xRet

      SendMessage( hWndClient, (992+4), ::hWnd, nMakeLong( nAppName, nTopicName ) )
   endif

return nil



UTILITY STATIC function TWindow_DispBegin() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local aInfo

   aInfo = FWDispBegin( ::hWnd, ::hDC )
   ::hDC = aInfo[ 3 ]

return aInfo



UTILITY STATIC function TWindow_DispEnd( aRestore) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   FWDispEnd( aRestore )
   ::hDC = aRestore[ 2 ]

return nil



UTILITY STATIC function TWindow_DrawItem( nIdCtl, pItemStruct) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local oItem
   local oPopup := If( ::oPopup <> nil, ::oPopup, If( ::oSysMenu <> nil, ::oSysMenu, nil ) )

   if nIdCtl == 0
      if oPopup <> nil .OR. ::oMenu <> nil
         if oPopup <> nil .AND. oPopup:GetPopup( GetDrawMenu( pItemStruct ) ) <> nil
            oItem = oPopup:GetMenuItem( GetDrawItem( pItemStruct ) )
            if oItem == nil
               if ::oPopup <> nil
                  ::oPopup = nil
               endif
            endif
         endif
         if oItem == nil .AND. ::oMenu <> nil
            oItem = ::oMenu:GetMenuItem( GetDrawItem( pItemStruct ) )
         endif
         if oItem <> nil
            if ! oItem:oMenu:l2007



               return MenuDrawItem( pItemStruct, If( ! Empty( oItem:cPrompt ), oItem:cPrompt, "" ), If( ::oMenu <> nil, ::oMenu:hMenu, 0 ), oItem:hBitmap, ::hWnd )
            else



               return MenuDraw2007( pItemStruct, If( ! Empty( oItem:cPrompt ), oItem:cPrompt, "" ), If( ::oMenu <> nil, ::oMenu:hMenu, 0 ), oItem:hBitmap, ::hWnd )
            endif
         else
            if IsMenuItem( pItemStruct )


               MenuDraw2007( pItemStruct, If( IsSeparator( pItemStruct ), "", MISText( pItemStruct ) ), 0,, ::hWnd )
            endif
         endif
      endif
   else
      return SendMessage( GetDlgItem( ::hWnd, nIdCtl ), 1024+1032, nIdCtl, pItemStruct )
   endif

return nil



UTILITY STATIC function TWindow_DropFiles( hDrop) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local aCoors := { 0, 0 }

   if ! Empty( ::bDropFiles )
      DragQueryPoint( hDrop, aCoors )
      Eval( ::bDropFiles, aCoors[ 2 ], aCoors[ 1 ], DragQueryFiles( hDrop ) )
   endif

   DragFinish( hDrop )

return nil



UTILITY STATIC function TWindow_GenDbf( cDbfName) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   IIF( cDbfName == nil, cDbfName := RTrim( SubStr( ::GetText(), 1, 8 ) ) + ".dbf", ) ;

   ::CoorsUpdate()

   if File( cDbfName )


      if ! ApoloMsgNoYes( cDbfName + Chr(13)+Chr(10) +  "This file already exists" + Chr(13)+Chr(10) +  "Do you want to overwrite it ?" )
         return nil
      endif
   else















      DbCreate( cDbfName, { { "CONTROL", "C", 15, 0}, { "CAPTION", "C", 40, 0}, { "ID", "N", 4, 0}, { "TOP", "N", 4, 0}, { "LEFT", "N", 4, 0}, { "WIDTH", "N", 4, 0}, { "HEIGHT", "N", 4, 0}, { "STYLE", "N", 15, 0}, { "CLRFORE", "N", 8, 0}, { "CLRBACK", "N", 8, 0}, { "FNTNAME", "C", 15, 0}, { "FNTWIDTH", "N", 4, 0}, { "FNTHEIGHT", "N", 4, 0}, { "FNTBOLD", "L", 1, 0}, { "FNTITALIC", "L", 1, 0} } )
   endif

return nil



UTILITY STATIC function TWindow_cGenPrg( cFileName) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local cPrg := ""

   ::CoorsUpdate()

   cPrg += '#include "FiveWin.ch"' + Chr(13)+Chr(10) + Chr(13)+Chr(10)
   cPrg += "static oWnd" + Chr(13)+Chr(10) + Chr(13)+Chr(10)
   cPrg += "//" + Replicate( "-", 76 ) + "//" + Chr(13)+Chr(10) + Chr(13)+Chr(10)
   cPrg += "function Main()" + Chr(13)+Chr(10) + Chr(13)+Chr(10)

   if ::oBar <> nil
      cPrg += "   local oBar" + Chr(13)+Chr(10)
   endif

   if ::oBrush <> nil
      cPrg += "   local oBrush" + Chr(13)+Chr(10)
   endif

   if ::oBrush <> nil
      cPrg += ::oBrush:cGenPRG()
   endif





   cPrg += Chr(13)+Chr(10) +  '   DEFINE WINDOW oWnd TITLE "' + ::cTitle + '" ;' + Chr(13)+Chr(10) +  "      FROM " +  Str( ::nTop / 16 , 3 ) + ", " + Str( ::nLeft / 8, 3 ) + " TO " +  Str( ::nBottom / 16, 3 ) + ", " + Str( ::nRight / 8, 3 )

   if ::oMenu <> nil
      cPrg += " ;" + Chr(13)+Chr(10) + "      MENU BuildMenu()"
   endif

   if ::oBrush <> nil
      cPrg += " ;" + Chr(13)+Chr(10) + "      BRUSH oBrush" + Chr(13)+Chr(10)
   endif

   if ::oBar <> nil
      cPrg += ::oBar:cGenPRG()
   endif

   if ::oMsgBar <> nil

      cPrg += Chr(13)+Chr(10) + Chr(13)+Chr(10) + '   SET MESSAGE OF oWnd TO "' +  ::oMsgBar:cMsgDef + '"'
   endif

   if ! Empty( ::aControls )
      AEval( ::aControls, { | oCtrl | cPrg += oCtrl:cGenPRG() } )
   endif

   cPrg += Chr(13)+Chr(10) + "   ACTIVATE WINDOW oWnd" + Chr(13)+Chr(10) + Chr(13)+Chr(10)
   cPrg += "return nil" + Chr(13)+Chr(10) + Chr(13)+Chr(10)
   cPrg += "//" + Replicate( "-", 76 ) + "//" + Chr(13)+Chr(10)

   if ! Empty( cFileName )
      MemoWrit( cFileName, cPrg )
   endif

return cPrg




























UTILITY STATIC function TWindow_GetCliRect() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local aRect := GetClientRect( ::hWnd )

return TRect():New( aRect[ 1 ], aRect[ 2 ], aRect[ 3 ], aRect[ 4 ] )



UTILITY STATIC function TWindow_GetRect() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local aRect := GetWndRect( ::hWnd )

return TRect():New( aRect[ 1 ], aRect[ 2 ], aRect[ 3 ], aRect[ 4 ] )



UTILITY STATIC function TWindow_MeasureItem( nIdCtl, pMitStruct) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local nAt, oItem




   if nIdCtl == 0
      if ::oPopup <> nil
         oItem = ::oPopup:GetMenuItem( GetMeaItem( pMitStruct ) )
      endif
      if oItem == nil .AND. ::oSysMenu <> nil
         oItem = ::oSysMenu:GetMenuItem( GetMeaItem( pMitStruct ) )
      endif
      if oItem == nil
         ::oPopup = nil
         oItem = ::oMenu:GetMenuItem( GetMeaItem( pMitStruct ) )
      endif
      if oItem <> nil




         MenuMeasureItem( pMitStruct, 0.9 * GetTextWidth( 0, If( ! Empty( oItem:cPrompt ), StrTran( oItem:cPrompt, "&", "" ), "" ) ) +  If( oItem:oMenu:hMenu <> If( ::oMenu <> nil, ::oMenu:hMenu, 0 ), 30, 0 ), Empty( oItem:cPrompt ) )
      else
         if IsMenuItem( pMitStruct )
            MenuMeasureItem( pMitStruct,, IsMISeparator( pMitStruct ) )
         endif
      endif
      return .F.
   endif

   if ( nAt := AScan( ::aControls, { | oCtrl | oCtrl:nId == nIdCtl } ) ) <> 0
      return ::aControls[ nAt ]:FillMeasure( pMitStruct )
   endif

return nil



UTILITY STATIC function TWindow_MenuChar( nAscii, nType, nHMenu) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local oMenu, n, nAt

   if ::oPopup <> nil
      oMenu = ::oPopup
   else
      if ::oMenu <> nil
         oMenu = ::oMenu
      endif
   endif

   if oMenu <> nil
      if oMenu:hMenu == nHMenu .OR. ( oMenu := oMenu:GetSubMenu( nHMenu ) ) <> nil
         for n = 1 to Len( oMenu:aItems )
            if ! Empty( oMenu:aItems[ n ]:cPrompt )


               if ( nAt := At( "&", oMenu:aItems[ n ]:cPrompt ) ) <> 0 .AND.  Upper( SubStr( oMenu:aItems[ n ]:cPrompt, nAt + 1, 1 ) ) ==  Upper( Chr( nAscii ) )
                  return nMakeLong( n - 1, 2 )
               endif
            endif
         next
         return 0
      endif
   endif

return nil



UTILITY STATIC function TWindow_MenuSelect( nIdItem, nFlags, nHMenu) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if oToolTip <> nil
      oToolTip:End()
      SysRefresh()
      oToolTip = nil
   endif

   if nFlags == -1 .AND. nHMenu == 0
      ::oMItemSelect = nil
   else
      if ::oMenu <> nil .OR. ::oPopup <> nil
         if ::oPopup <> nil
            ::oMItemSelect = ::oPopup:GetMenuItem( nIdItem )
         else
            ::oMItemSelect = ::oMenu:GetMenuItem( nIdItem )
         endif
         ::SetMsg( If( ::oMItemSelect <> nil, ::oMItemSelect:cMsg,) )
      endif
   endif

   if ::bMenuSelect <> nil
      Eval( ::bMenuSelect, ::oMItemSelect, nFlags, nHMenu )
   endif

return nil



UTILITY STATIC function TWindow_nHeight(nNewHeight) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if PCount() > 0
      return WndHeight( ::hWnd, nNewHeight )
   else
      if ! Empty( ::hWnd )
         return WndHeight( ::hWnd )
      else
         return ::nBottom - ::nTop + 1
      endif
   endif

return nil



UTILITY STATIC function TWindow_Notify( nIdCtrl, nPtrNMHDR) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local nCode     := GetNMHDRCode( nPtrNMHDR )
   local nHWndFrom := GetNMHDRHWndFrom( nPtrNMHDR )
   local oCtrl     := oWndFromHwnd( nHWndFrom )

   if oCtrl <> nil
      do case
         case nCode == 103 .OR. nCode == -402
              oCtrl:SelChanged()

         otherwise
              if oCtrl:hWnd <> ::hWnd
                 return oCtrl:Notify( nIdCtrl, nPtrNMHDR )
              endif
      endcase
   endif

return nil



UTILITY STATIC function TWindow_nWidth(nNewWidth) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if PCount() > 0
      return WndWidth( ::hWnd, nNewWidth )
   else
      if ! Empty( ::hWnd )
         return WndWidth( ::hWnd )
      else
         return ::nRight - ::nLeft + 1
      endif
   endif

return nil



UTILITY STATIC function TWindow_Print( oTarget, nRow, nCol, nScale) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local lNew := .F.

   IIF( nRow == nil, nRow := 0, ) ; IIF( nCol == nil, nCol := 0, ); IIF( nScale == nil, nScale := 4, );

   if ::bPrint <> nil
      Eval( ::bPrint, Self )
      return nil
   endif

   if oTarget == nil
      lNew = .T.
      oTarget := PrintBegin( ::GetText(), .F., .F.,, .F., .F. )
         PageBegin()
         SysRefresh()
   endif

   WndPrint( ::hWnd, oTarget:hDC, nRow, nCol, nScale )

   if lNew
         PageEnd()
      PrintEnd()
   endif

return nil



UTILITY STATIC function TWindow_Save() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local n
   local cType, cInfo := "", cMethod
   local oWnd  := &( ::ClassName() + "()" )
   local uData, nProps := 0

   oWnd = oWnd:New()

   for n = 1 to Len( ::aProperties )

       if ! ( uData := OSend( Self, ::aProperties[ n ] ) ) ==  OSend( oWnd, ::aProperties[ n ] )

          cInfo += ( I2Bin( Len( ::aProperties[ n ] ) ) +  ::aProperties[ n ] )
          nProps++
          cType = ValType( uData )
          do case
             case cType == "A"
                  cInfo += ASave( uData )

             case cType == "O"
                  cInfo += uData:Save()

             otherwise

                  cInfo += ( cType + I2Bin( Len( uData := cValToChar( uData ) ) ) +  uData )
          endcase
       endif
   next

   if ::aEvents <> nil
      for n = 1 to Len( ::aEvents )
         if ( cMethod := OSend( Self, ::aEvents[ n ][ 1 ] ) ) <> nil

            cInfo += ( I2Bin( Len( ::aEvents[ n ][ 1 ] ) ) +  ::aEvents[ n ][ 1 ] )
            nProps++
            cInfo += ( "C" + I2Bin( Len( cMethod ) ) + cMethod )
         endif
      next
   endif

   oWnd:End()



return "O" + I2Bin( 2 + Len( ::ClassName() ) + 2 + Len( cInfo ) ) +  I2Bin( Len( ::ClassName() ) ) +  ::ClassName() + I2Bin( nProps ) + cInfo



function AToText( aArray, cArrayName, nIndent )

   local cText := "", cType
   local n

   for n = 1 to Len( aArray )
      cType = ValType( aArray[ n ] )
      do case
         case cType == "C"
              cText += Space( nIndent ) + "::" + cArrayName + "[ " + LTrim( Str( n ) ) + " ] = "
              cText += '"' + aArray[ n ] + '"' + Chr(13)+Chr(10)

         case cType == "L"
              cText += Space( nIndent ) + "::" + cArrayName + "[ " + LTrim( Str( n ) ) + " ] = "
              cText += If( aArray[ n ], ".T.", ".F." ) + Chr(13)+Chr(10)

         case cType == "N"
              cText += Space( nIndent ) + "::" + cArrayName + "[ " + LTrim( Str( n ) ) + " ] = "
              cText += LTrim( Str( aArray[ n ] ) ) + Chr(13)+Chr(10)

         case cType == "A"
              cText += AToText( aArray[ n ], "::" + cArrayName + "[ " + LTrim( Str( n ) ) + " ]", nIndent + 3 ) + Chr(13)+Chr(10)

         case cType == "O"
              cText += aArray[ n ]:SaveToText( nIndent, cArrayName + "[ " + Alltrim( Str( n ) ) + " ]" ) + Chr(13)+Chr(10) + Chr(13)+Chr(10)

         case cType == "U"
              cText += Space( nIndent ) + "::" + cArrayName + "[ " + LTrim( Str( n ) ) + " ] = "
              cText += "nil" + Chr(13)+Chr(10)
      endcase
   next

return cText



UTILITY STATIC function TWindow_SaveToBmp( cBmpFile) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local hBmp := WndBitmap( ::hWnd )
   local hDib := DibFromBitmap( hBmp )

   DibWrite( cBmpFile, hDib )
   GloBalFree( hDib )
   DeleteObject( hBmp )

return ( File( cBmpFile ) )



UTILITY STATIC function TWindow_SaveToText( nIndent) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local n, m, cType, cInfo
   local cMethod, uData, nProps := 0
   local oWnd  := &( ::ClassName() + "()" )
   local cParams1, cParams2

   IIF( nIndent == nil, nIndent := 0, ) ;

   IIF( ::cVarName == nil, ::cVarName := "noname", ) ;






   cInfo := Space( nIndent ) + "OBJECT " + If( nIndent > 0, "::", "" ) +  ::cVarName + " AS " +  If( nIndent > 0, Upper( Left( ::ClassName(), 2 ) ) +  Lower( SubStr( ::ClassName(), 3 ) ), If( ::IsDerivedFrom( "TFORM" ), ::cClassName, ::ClassName() ) ) +  Chr(13)+Chr(10) + Chr(13)+Chr(10)








   oWnd = oWnd:New()

   for n = 1 to Len( ::aProperties )




          if ! ( uData := OSend( Self, ::aProperties[ n ] ) ) ==  OSend( oWnd, ::aProperties[ n ] )
             nProps++
             cType = ValType( uData )
             do case
                case cType == "C"
                     cInfo += Space( nIndent ) + "   ::" + ::aProperties[ n ] + " = "
                     cInfo += '"' + uData + '"' + Chr(13)+Chr(10)

                case cType == "A"

                     cInfo += Space( nIndent + 3 ) + "::" + ::aProperties[ n ] +  " = Array( " + AllTrim( Str( Len( uData ) ) ) + " )" + Chr(13)+Chr(10) + Chr(13)+Chr(10)
                     cInfo += AToText( uData, ::aProperties[ n ], nIndent + 3 )
                     if Right( cInfo, 13 ) <> "ENDOBJECT" + Chr(13)+Chr(10) + Chr(13)+Chr(10)
                        cInfo += Chr(13)+Chr(10)
                     endif

                case cType == "O"
                     cInfo += Chr(13)+Chr(10) + uData:SaveToText( nIndent + 3 )

                otherwise
                     cInfo += Space( nIndent ) + "   ::" + ::aProperties[ n ] + " = "
                     cInfo += cValToChar( uData ) + Chr(13)+Chr(10)
             endcase
          endif

   next

   if ::aEvents <> nil
      for n = 1 to Len( ::aEvents )
         if ( cMethod := OSend( Self, ::aEvents[ n ][ 1 ] ) ) <> nil
            cInfo += Space( nIndent ) + "   ::" + ::aEvents[ n ][ 1 ] + " = "
            nProps++
            cParams1 = "{ |"
            cParams2 = "("
            for m = 2 to Len( ::aEvents[ n ] )
               cParams1 += If( m > 2, ", ", " " ) + ::aEvents[ n ][ m ]
               cParams2 += If( m > 2, ", ", " " ) + ::aEvents[ n ][ m ]
            next
            cParams1 += " | "
            cParams2 += " )"
            if ::oWnd <> nil
               cInfo += cParams1 + "::oWnd:" + cMethod + cParams2 + " }" + Chr(13)+Chr(10)
            else
               cInfo += cParams1 + " ::" + cMethod + cParams2 + " }" + Chr(13)+Chr(10)
            endif
         endif
      next
   endif

   cInfo += Chr(13)+Chr(10) + Space( nIndent ) + "ENDOBJECT"

   oWnd:End()

return cInfo



function ASave( aArray )

   local n, cType, uData
   local cInfo := ""

   for n = 1 to Len( aArray )
      cType = ValType( aArray[ n ] )
      do case
         case cType == "A"
              cInfo += ASave( aArray[ n ] )

         case cType == "O"
              cInfo += aArray[ n ]:Save()

         otherwise

              cInfo += ( cType + I2Bin( Len( uData := cValToChar( aArray[ n ] ) ) ) +  uData )
      endcase
   next

return "A" + I2Bin( 2 + Len( cInfo ) ) + I2Bin( Len( aArray ) ) + cInfo



function ARead( cInfo )

   local nPos := 4, nLen, n
   local aArray, cType, cBuffer

   nLen   = Bin2I( SubStr( cInfo, nPos, 2 ) )
   nPos  += 2
   aArray = Array( nLen )

   for n = 1 to Len( aArray )
      cType = SubStr( cInfo, nPos++, 1 )
      nLen  = Bin2I( SubStr( cInfo, nPos, 2 ) )
      nPos += 2
      cBuffer = SubStr( cInfo, nPos, nLen )
      nPos += nLen
      do case
         case cType == "A"
              aArray[ n ] = ARead( "A" + I2Bin( nLen ) + cBuffer )

         case cType == "O"
              aArray[ n ] = ORead( cBuffer )

         case cType == "C"
              aArray[ n ] = cBuffer

         case cType == "D"
              aArray[ n ] = CToD( cBuffer )

         case cType == "L"
              aArray[ n ] = ( cBuffer == ".T." )

         case cType == "N"
              aArray[ n ] = Val( cBuffer )
      endcase
   next

return aArray



function ORead( cInfo )

   local nLen, cClassName, oObj
   local nPos := 1

   nLen       = Bin2I( SubStr( cInfo, nPos, 2 ) )
   nPos      += 2
   cClassName = SubStr( cInfo, nPos, nLen )
   nPos      += nLen
   oObj       = &( cClassName + "()" )

   oObj:New()
   oObj:Load( SubStr( cInfo, nPos ) )

return oObj



UTILITY STATIC function TWindow_SaveFile( cFileName) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   IIF( cFileName == nil, cFileName := SubStr( ::cVarName, 2 ) + ".ffm", ) ;

return MemoWrit( cFileName, ::Save() )




UTILITY STATIC function TWindow_Say( nRow, nCol, cText, nClrFore, nClrBack, oFont, lPixel, lTransparent, nAlign) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow





   IIF( nClrFore == nil, nClrFore := ::nClrText, ) ; IIF( nClrBack == nil, nClrBack := ::nClrPane, ); IIF( oFont == nil, oFont := ::oFont, ); IIF( lPixel == nil, lPixel := .F., ); IIF( lTransparent == nil, lTransparent := .F., );

   if ValType( nClrFore ) == "C"
      nClrBack = nClrFore
      nClrFore = nGetForeRGB( nClrFore )
      nClrBack = nGetBackRGB( nClrBack )
   endif

   ::GetDC()

   IIF( nAlign == nil, nAlign := GetTextAlign( ::hDC ), ) ;


   WSay( ::hWnd, ::hDC, nRow, nCol, cValToChar( cText ), nClrFore, nClrBack, If( oFont <> nil, oFont:hFont, 0 ), lPixel, lTransparent, nAlign )
   ::ReleaseDC()

return nil



UTILITY STATIC function TWindow_SayBitmap( nRow, nCol, coBitmap, nWidth, nHeight) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local cType := ValType( coBitmap )

   if cType == "C"
      coBitmap := TBitmap():Define(, coBitmap, )
   endif


   PalBmpDraw( ::GetDC(), nRow, nCol, coBitmap:hBitmap, coBitmap:hPalette, nWidth, nHeight,,, ::nClrPane )
   ::ReleaseDC()

   if cType == "C"
      coBitmap:End()
   endif

return nil



UTILITY STATIC function TWindow_SayRect( nRow, nCol, cText, nClrFore, nClrBack, nWidth) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   IIF( nClrFore == nil, nClrFore := 0, ) ; IIF( nClrBack == nil, nClrBack := 16777215, );

   ::GetDC()
   WSayRect( ::hWnd, ::hDC, nRow, nCol, cText, nClrFore, nClrBack, nWidth )
   ::ReleaseDC()

return nil



UTILITY STATIC function TWindow_LButtonDown( nRow, nCol, nKeyFlags) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if ::bLClicked <> nil
      return Eval( ::bLClicked, nRow, nCol, nKeyFlags, Self )
   endif

return nil



UTILITY STATIC function TWindow_LButtonUp( nRow, nCol, nKeyFlags) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow


   if ::OnClick <> nil
      return Eval( ::OnClick, nRow, nCol, nKeyFlags )
   endif

   if ::bLButtonUp <> nil
      return Eval( ::bLButtonUp, nRow, nCol, nKeyFlags, Self )
   endif

return nil



UTILITY STATIC function TWindow_LDblClick( nRow, nCol, nKeyFlags) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if ::bLDblClick <> nil
      return Eval( ::bLDblClick, nRow, nCol, nKeyFlags, Self )
   endif

return nil



UTILITY STATIC function TWindow_Line( nTop, nLeft, nBottom, nRight) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   ::GetDC()
   MoveTo( ::hDC, nLeft, nTop )
   LineTo( ::hDC, nRight, nBottom )
   ::ReleaseDC()

return nil



UTILITY STATIC function TWindow_RButtonDown( nRow, nCol, nKeyFlags) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if ::bRClicked <> nil
      Eval( ::bRClicked, nRow, nCol, nKeyFlags, Self )
   endif

return nil



UTILITY STATIC function TWindow_RButtonUp( nRow, nCol, nKeyFlags) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if ::bRButtonUp <> nil
      Eval( ::bRButtonUp, nRow, nCol, nKeyFlags, Self )
   endif

return nil



UTILITY STATIC function TWindow_MButtonDown( nRow, nCol, nKeyFlags) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if ::bMButtonDown <> nil
      Eval( ::bMButtonDown, nRow, nCol, nKeyFlags, Self )
   endif

return nil



UTILITY STATIC function TWindow_MButtonUp( nRow, nCol, nKeyFlags) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if ::bMButtonUp <> nil
      Eval( ::bMButtonUp, nRow, nCol, nKeyFlags, Self )
   endif

return nil



UTILITY STATIC function TWindow_SetMsg( cText, lDefault) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local oMsgBar := ::oMsgBar

   IIF( lDefault == nil, lDefault := .F., ) ;

   if ::oBottom <> nil .AND. Upper( ::oBottom:ClassName() ) $ "TMSGBAR,TSTATUSBAR"
      oMsgBar = ::oBottom
   endif

   if oMsgBar <> nil
      if lDefault
         oMsgBar:cMsgDef := cText
      else
         oMsgBar:SetMsg( cText )
      endif
   else
      if ::oWnd <> nil
         ::oWnd:SetMsg( cText )
      endif
   endif

return nil



UTILITY STATIC function TWindow_Box( nTop, nLeft, nBottom, nRight) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   ::GetDC()
   WndBox( ::hDC, nTop, nLeft, nBottom, nRight )
   ::ReleaseDC()

return nil



UTILITY STATIC function TWindow_Link( lSubClass) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local nAt := AScan( aWindows, 0 )

   IIF( lSubClass == nil, lSubClass := .T., ) ;

   if ::hWnd <> 0
      if nAt <> 0
         aWindows[ nAt ] = Self





      else
         AAdd( aWindows, Self )
         nAt = Len( aWindows )





      endif







      if lSubClass



            ::nOldProc = XChangeProc( ::hWnd, nAt )

      endif
   endif

return nil



UTILITY STATIC function TWindow_Destroy() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if Empty( ::hWnd ) .AND. Empty( ::nResult )
      return nil
   endif

   if ::oBrush <> nil
      ::oBrush:End()
   endif
   if ::oCursor <> nil
      ::oCursor:End()
   endif
   if ::oDragCursor <> nil
      ::oDragCursor:End()
   endif
   if ::oIcon <> nil
      ::oIcon:End()
   endif
   if ::oFont <> nil
      ::oFont:End()
   endif
   if ::oMenu <> nil
      ::oMenu:Destroy()
   endif
   if ::oSysMenu <> nil
      ::oSysMenu:End()
   endif
   if ::oVScroll <> nil
      ::oVScroll:Destroy()
   endif
   if ::oHScroll <> nil
      ::oHScroll:Destroy()
   endif

   if ! Empty( ::hWnd )
      ::UnLink()
   endif

   if ::hWnd <> 0 .AND. GetWndApp() == ::hWnd
      PostQuitMessage( 0 )
   endif

   if ::IsKindOf( "TDIALOG" ) .AND. ! ::lModal
      DeRegDialog( ::hWnd )
   endif

   if oWndDefault == Self
      oWndDefault = nil
   endif

   ::hWnd = 0

return nil



STATIC function VbxTerm( ) ; local _hDLL := If( ValType( "BIVBX10.DLL" ) == "N", "BIVBX10.DLL", LoadLibrary( "BIVBX10.DLL" ) ) ; local uResult ; local cFarProc ; if Abs( _hDLL ) > 32 ; cFarProc = GetProcAdd( _hDLL, If( .T., "VbxTerm", ), .T., 0 ) ; uResult = FWCallDLL( cFarProc ) ; IIF( ValType( "BIVBX10.DLL" ) == "N",, FreeLibrary( _hDLL ) ) ; else ; MsgAlert( "Error code: " + LTrim( Str( _hDLL ) ) + " loading " + If( ValType( "BIVBX10.DLL" ) == "C", "BIVBX10.DLL", Str( "BIVBX10.DLL" ) ) ) ; end ; return uResult



UTILITY STATIC function TWindow_ReSize( nSizeType, nWidth, nHeight) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   ::CoorsUpdate()


   if ::oTop <> nil
      ::oTop:AdjTop()
   endif
   if ::oBottom <> nil
      ::oBottom:AdjBottom()
   endif

   if ::oMsgBar <> nil .AND. ! ::oMsgBar == ::oBottom
      ::oMsgBar:Adjust()
   endif
   if ::oBar <> nil .AND. ! ::oBar == ::oTop
      ::oBar:Adjust()
   endif

   if ::oLeft <> nil
      ::oLeft:AdjLeft()
   endif
   if ::oRight <> nil
      ::oRight:AdjRight()
   endif

   if ::oClient <> nil
      ::oClient:AdjClient()
   endif

   if ::OnResize <> nil
      Eval( ::OnResize, Self )
   endif

   if ::bResized <> nil
      Eval( ::bResized, nSizeType, nWidth, nHeight )
   endif

return nil



UTILITY STATIC function TWindow_SetBounds( nLeft, nTop, nRight, nBottom) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow


   SetWindowPos( ::hWnd, 0, nTop, nLeft, nRight - nLeft + 1, nBottom - nTop + 1, 4 )

return nil



UTILITY STATIC function TWindow_SetCoors( oRect) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow



   SetWindowPos( ::hWnd, 0, oRect:nTop, oRect:nLeft, oRect:nRight - oRect:nLeft + 1, oRect:nBottom - oRect:nTop + 1, 4 )

   ::nTop    = oRect:nTop
   ::nLeft   = oRect:nLeft
   ::nBottom = oRect:nBottom
   ::nRight  = oRect:nRight

return nil



UTILITY STATIC function TWindow_UnLink() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local nOldProc





      local nAt := AScan( aWindows, { | o | ValType( o ) == "O" .AND. o:hWnd == ::hWnd } )


   if ::nOldProc <> nil .AND. ::hWnd <> 0
      nOldProc = RestProc( ::hWnd, ::nOldProc )

         ::nOldProc = nil

   endif

   if nAt > 0 .AND. nAt <= Len( aWindows )
      aWindows[ nAt ] = 0
   endif





      XFreeProc( nOldProc )


return nil



UTILITY STATIC function TWindow_VScroll( nWParam, nLParam) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow






      local nScrHandle  := nLParam
      local nScrollCode := nLoWord( nWParam )
      local nPos        := nHiWord( nWParam )


   if nScrHandle == 0
      if ::oVScroll <> nil
         do case
            case nScrollCode == 0
                 ::oVScroll:GoUp()

            case nScrollCode == 1
                 ::oVScroll:GoDown()

            case nScrollCode == 2
                 ::oVScroll:PageUp()

            case nScrollCode == 3
                 ::oVScroll:PageDown()

            case nScrollCode == 4
                 ::oVScroll:ThumbPos( nPos )

            case nScrollCode == 5
                 ::oVScroll:ThumbTrack( nPos )

            case nScrollCode == 8
                 return 0
         endcase
      endif
   else
      do case
         case nScrollCode == 0
              SendMessage( nScrHandle, 1024+1025 )

         case nScrollCode == 1
              SendMessage( nScrHandle, 1024+1026 )

         case nScrollCode == 2
              SendMessage( nScrHandle, 1024+1027 )

         case nScrollCode == 3
              SendMessage( nScrHandle, 1024+1028 )

         case nScrollCode == 4
              SendMessage( nScrHandle, 1024+1034, nPos )

         case nScrollCode == 5
              SendMessage( nScrHandle, 1024+1038, nPos )
      endcase
   endif

return 0



UTILITY STATIC function TWindow_ToolWindow() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow


   SetWindowLong( ::hWnd, -20, nOr( GetWindowLong( ::hWnd, -20 ), 128 ) )

   SetWindowPos( ::hWnd, 0, ::nTop, ::nLeft, ::nRight - ::nLeft + 1, ::nBottom - ::nTop + 1, 55 )



return nil



UTILITY STATIC function TWindow_HScroll( nWParam, nLParam) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow






      local nScrHandle  := nLParam
      local nScrollCode := nLoWord( nWParam )
      local nPos        := nHiWord( nWParam )


   if nScrHandle == 0 .AND. ::oHScroll <> nil
      do case
         case nScrollCode == 0
              ::oHScroll:GoUp()

         case nScrollCode == 1
              ::oHScroll:GoDown()

         case nScrollCode == 2
              ::oHScroll:PageUp()

         case nScrollCode == 3
              ::oHScroll:PageDown()

         case nScrollCode == 4
              ::oHScroll:ThumbPos( nPos )

         case nScrollCode == 5
              ::oHScroll:ThumbTrack( nPos )

         case nScrollCode == 8
              return 0
      endcase
   else
      do case
         case nScrollCode == 0
              SendMessage( nScrHandle, 1024+1025 )

         case nScrollCode == 1
              SendMessage( nScrHandle, 1024+1026 )

         case nScrollCode == 2
              SendMessage( nScrHandle, 1024+1027 )

         case nScrollCode == 3
              SendMessage( nScrHandle, 1024+1028 )

         case nScrollCode == 4
              SendMessage( nScrHandle, 1024+1034, nPos )

         case nScrollCode == 5
              SendMessage( nScrHandle, 1024+1038, nPos )
      endcase
   endif

return 0



UTILITY STATIC function TWindow_SysCommand( nWParam, nLParam) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local bKeyAction, i
   local lRibbon := .F.
   local o, oRibbon

   if ::oBar <> nil


      AEval( ::oBar:aControls, { | oCtl | If( oCtl:ClassName() == "TBTNBMP", oCtl:LostFocus(), ) } )
   endif

   if ::ClassName() = "TMDIFRAME"
      for i = 1 to Len( ::oWndClient:aWnd )
         if ::oWndClient:aWnd[ i ]:oBar <> nil


            AEval( ::oWndClient:aWnd[ i ]:oBar:aControls, { | oCtl | If( oCtl:ClassName() == "TBTNBMP", oCtl:LostFocus(), ) } )
         endif
      next
   endif

   if ::ClassName() = "TDIALOG"


      AEval( ::aControls, { | oCtl | If( oCtl:ClassName() == "TBTNBMP", oCtl:LostFocus(), ) } )
   endif

   if nWParam == 0xF100
      if ::aControls <> NIL
         for each o in ::aControls
            if o:ClassName() == "TRIBBONBAR"
               if o:oPanelAcc == NIL
                  if o:lUseAcc
                     o:KeybMode()
                     lRibbon := .T.
                  endif
               else
                  o:RunAction( 0 )
               endif
               oRibbon := o
               exit
            endif
         next
         if oRibbon <> NIL .AND. oRibbon:lUseAcc
            return 0
         endif
      endif

      if ( bKeyAction := SetKey( 121 ) ) <> nil .AND. ! lRibbon
         Eval( bKeyAction, ProcName( 4 ), ProcLine( 4 ), Self )
         return 0
      endif
   endif

   if ::oSysMenu <> nil .AND. nWParam < 61440
      ::oSysMenu:Command( nWParam )
   else
      do case
         case nWParam == 61536 .OR. nWParam == 61539
              return ::End()
      endcase
   endif

return nil



UTILITY STATIC function TWindow_Paint() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local aInfo, uVal := 0

   if IsIconic( ::hWnd )
      if ::IsKindOf( "TMDICHILD" )
         ::SendMsg( 20, ::hDC, 0 )
      else
         ::SendMsg( 39, ::hDC, 0 )
      endif

      DrawIcon( ::hDC, 0, 0, If( ::oIcon <> nil, ::oIcon:hIcon, ExtractIcon( "user.exe" ) ) )
   else
      aInfo = ::DispBegin()
      if ValType( ::bEraseBkGnd ) == "B"
         Eval( ::bEraseBkGnd, ::hDC )
      else
         FillRect( ::hDC, GetClientRect( ::hWnd ), ::oBrush:hBrush )
      endif
      if ValType( ::bPainted ) == "B"
         uVal = Eval( ::bPainted, ::hDC, ::cPS, Self )
      endif
      ::DispEnd( aInfo )
  endif

return uVal



UTILITY STATIC function TWindow_HardCopy( nScale, lUser) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local oPrn

   IIF( lUser == nil, lUser := .T., ) ;

   if lUser
      oPrn := PrintBegin( ::cTitle, .T., .F.,, .F., .F. )
   else
      oPrn := PrintBegin( ::cTitle, .F., .F.,, .F., .F. )
   endif

      PageBegin()
         ::Refresh()
         SysRefresh()
         ::Print( oPrn, 0, 0, nScale )
      PageEnd()
   PrintEnd()

return nil



UTILITY STATIC function TWindow_Move( nTop, nLeft, nWidth, nHeight, lRepaint) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow





   IIF( nTop == nil, nTop := ::nTop, ) ; IIF( nLeft == nil, nLeft := ::nLeft, ); IIF( nWidth == nil, nWidth := ::nWidth, ); IIF( nHeight == nil, nHeight := ::nHeight, ); IIF( lRepaint == nil, lRepaint := .T., );

   MoveWindow( ::hWnd, nTop, nLeft, nWidth, nHeight, lRepaint )

   ::CoorsUpdate()

return nil



UTILITY STATIC function TWindow_SetColor( nClrFore, nClrBack, oBrush) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow




   if ValType( nClrFore ) == "C"
      nClrBack = nClrFore
      nClrFore = nGetForeRGB( nClrFore )
      nClrBack = nGetBackRGB( nClrBack )
   endif

   ::nClrText = nClrFore
   ::nClrPane = nClrBack

   if ::oBrush <> nil
      ::oBrush:End()
   endif
   if oBrush <> nil
      ::oBrush = oBrush
      oBrush:nCount++
   else

      ::oBrush := TBrush():New(,nClrBack,)
   endif

return nil



UTILITY STATIC function TWindow_KeyChar( nKey, nFlags) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local bKeyAction := SetKey( nKey )

   if bKeyAction <> nil .AND. lAnd( nFlags, 16777216 )
      return Eval( bKeyAction, ProcName( 4 ), ProcLine( 4 ), Self )
   endif

   if ::bKeyChar <> nil
      return Eval( ::bKeyChar, nKey, nFlags )
   endif

   if nKey == 27 .AND. ::oWnd <> nil
      ::oWnd:KeyChar( nKey, nFlags )
   endif

return nil



UTILITY STATIC function TWindow_InitMenuPopup( hPopup, nIndex, lSystem) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local oPopup

   if ! lSystem
      if ! Empty( ::oPopup )
         ::oPopup:Initiate()
         if ( oPopup := ::oPopup:GetPopup( hPopup ) ) <> nil
            oPopup:Initiate()
         endif
         return nil
      endif
      if ! Empty( ::oMenu )
         ::oMenu:Initiate()
         if ( oPopup := ::oMenu:GetPopup( hPopup ) ) <> nil
            oPopup:Initiate()
         endif
      endif
   else
      if ! Empty( ::oSysMenu )
         ::oSysMenu:Initiate()
      endif
   endif

return nil



UTILITY STATIC function TWindow_KeyDown( nKey, nFlags) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local bKeyAction := SetKey( nKey )


   if nKey == 9 .AND. ::oWnd <> nil .AND. GetKeyState( 16 )
      ::oWnd:GoPrevCtrl( ::hWnd )
      return 0
   endif

   if nKey == 9 .AND. ::oWnd <> nil
      ::oWnd:GoNextCtrl( ::hWnd )
      return 0
   endif


   if nKey == 115 .AND. GetKeyState( 17 ) .AND.  ::oWnd <> nil .AND. ::oWnd:IsKindOf( "TMDICHILD" )
      ::oWnd:KeyDown( nKey, nFlags )
      return 0
   endif


   if nKey == 117 .AND. GetKeyState( 17 ) .AND.  ::oWnd <> nil .AND. ::oWnd:IsKindOf( "TMDICHILD" )
      ::oWnd:KeyDown( nKey, nFlags )
      return 0
   endif

  if bKeyAction <> nil
     Eval( bKeyAction, ProcName( 4 ), ProcLine( 4 ), Self )
     return 0
   endif

   if nKey == 112

      return 0
   endif

   if ::OnKeyDown <> nil
      Eval( ::OnKeyDown, Self, nKey, nFlags )
   endif

   if Upper( ::ClassName() ) <> "TGET" .AND. ::bKeyDown <> nil
      return Eval( ::bKeyDown, nKey, nFlags )
   endif

   if ::oWnd <> nil .AND. IsChild( ::oWnd:hWnd, ::hWnd )
      ::oWnd:KeyDown( nKey, nFlags )
   endif

return nil




function SetWndDefault( oWnd ) ; oWndDefault := oWnd ; return nil
function _SetWndDefaul( oWnd ) ; oWndDefault := oWnd ; return nil

function GetWndDefault() ; return oWndDefault



UTILITY STATIC function TWindow_GotFocus() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   ::lFocused = .T.

   if ::bGotFocus <> nil
      Eval( ::bGotFocus, Self )
   endif

   if ! Empty( ::hCtlFocus )



         if Upper( GetClassName( ::hCtlFocus ) ) $ "SYSTABCONTROL32,TPAGES,TFOLDEREX"


         AEval( ::aControls, {| Ctrl | If( Ctrl:hWnd <> ::hCtlFocus, ,  If( ! Empty( Ctrl:aDialogs ), SetFocus( Ctrl:aDialogs[ Ctrl:nOption ]:hCtlFocus ), ) ) } )
      else
         SetFocus( ::hCtlFocus )
      endif
   else
      if ::aControls <> nil .AND. Len( ::aControls ) > 0
         if ::aControls[ 1 ] <> nil
            ::hCtlFocus = NextDlgTab( ::hWnd )
            SetFocus( ::hCtlFocus )
         endif
      endif
   endif

return 0



UTILITY STATIC function TWindow_GoNextCtrl( hCtrl) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local hCtlNext, nAt

   if Upper( ::ClassName() ) <> "TDIALOG"
      nAt = AScan( ::aControls, { | o | o:hWnd == hCtrl } )
      if nAt <> 0
         if nAt < Len( ::aControls )
            hCtlNext = ::aControls[ nAt + 1 ]:hWnd
         else
            hCtlNext = ::aControls[ 1 ]:hWnd
         endif

         if lAnd( GetWindowLong( hCtlNext, -16 ), 65536 )
            SetFocus( hCtlNext )
         endif
         return nil
      endif
   endif

   hCtlNext := NextDlgTab( ::hWnd, hCtrl )
   ::hCtlFocus = hCtlNext

   if ! Empty( ::aControls ) .AND. hCtrl == ::LastActiveCtrl():hWnd

      if ! Empty( ::oWnd ) .AND.  ( ( Upper( ::oWnd:ClassName() ) $ "TFOLDER;TPAGES;TFOLDEREX" ) )
         hCtlNext = NextDlgTab( ::oWnd:oWnd:hWnd, ::oWnd:hWnd )
         ::hCtlFocus = hCtrl
      endif
   endif

   if hCtlNext == hCtrl .AND. Upper( GetClassName( hCtrl ) ) == "EDIT"
      hCtlNext = NextDlgTab( GetParent( ::hWnd ), hCtrl )
   endif

   if hCtlNext <> hCtrl
      SetFocus( hCtlNext )
   endif

return nil



UTILITY STATIC function TWindow_GoPrevCtrl( hCtrl) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local hCtlPrev := NextDlgTab( ::hWnd, hCtrl, .T. )
   local n, cFoldName, nAt

   if Upper( ::ClassName() ) <> "TDIALOG"
      nAt = AScan( ::aControls, { | o | o:hWnd == hCtrl } )
      if nAt <> 0
         if nAt > 1
            hCtlPrev = ::aControls[ nAt - 1 ]:hWnd
         else
            hCtlPrev = ATail( ::aControls ):hWnd
         endif
         if lAnd( GetWindowLong( ::hWnd, -16 ), 65536 )
            SetFocus( hCtlPrev )
         endif
         return nil
      endif
   endif




      cFoldName = "SYSTABCONTROL32"


   ::hCtlFocus = hCtlPrev

   if ! Empty( ::aControls ) .AND. hCtrl == ::FirstActiveCtrl():hWnd

      if ! Empty( ::oWnd ) .AND.  ( ( Upper( ::oWnd:ClassName() ) $ "TFOLDER;TPAGES;TFOLDEREX" ) )
         hCtlPrev = NextDlgTab( ::oWnd:oWnd:hWnd, ::oWnd:hWnd, .T. )
         ::hCtlFocus = hCtrl
      endif
   endif

   If hCtlPrev <> hCtrl

      If Upper( GetClassName( hCtlPrev ) ) == cFoldName .OR.  Upper( GetClassName( hCtlPrev ) ) == "TPAGES"
         n = AScan( ::aControls, { | o | o:hWnd == hCtlPrev } )
         if n > 0
            ::aControls[ n ]:aDialogs[ ::aControls[ n ]:nOption ]:LastActiveCtrl():SetFocus()
         endif
      else
         SetFocus( hCtlPrev )
      endif
   endif

return nil



UTILITY STATIC function TWindow_GetFont() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local hFont, aInfo, oFont

   if ::oFont == nil .AND. ::oWnd <> nil .AND. ::oWnd:oFont <> nil
      ::oFont = ::oWnd:oFont
      ::SendMsg( 48, ::oFont:hFont )
      IIF( ::oFont:nCount == nil, ::oFont:nCount := 0, ) ;
      ::oFont:nCount++
      return ::oFont
   endif

   if ::oFont == nil
      if ( hFont := ::SendMsg( 49 ) ) <> 0
         aInfo = GetFontInfo( hFont )

            oFont = TFont()



         oFont:hFont     = hFont
         oFont:nCount    = 1
         oFont:nHeight   = aInfo[ 1 ]
         oFont:nWeight   = aInfo[ 2 ]
         oFont:lBold     = aInfo[ 3 ]
         oFont:cFaceName = aInfo[ 4 ]
         oFont:lDestroy  = .F.
         ::oFont = oFont
         ::nChrHeight    = aInfo[ 1 ]
         ::nChrWidth     = GetTextWidth( , "B" )
      else
         ::oFont := TFont():New( GetSysFont(), 0, -12,,,,,,,,,,,,,, )
         if ::oFont:lNew
            ::oFont:nCount--
         endif
      endif
   endif

return ::oFont



UTILITY STATIC function TWindow_AEvalWhen() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local n
   local aControls := ::aControls

   if aControls <> nil .AND. ! Empty( aControls )
      for n = 1 to Len( aControls )
          if aControls[ n ] <> nil .AND. aControls[ n ]:bWhen <> nil
             if Eval( aControls[ n ]:bWhen )
                ::aControls[ n ]:Enable()
             else
                ::aControls[ n ]:Disable()
             endif
         endif
      next
   endif

return nil



UTILITY STATIC function TWindow_SetFont( oFont) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if ::oFont <> nil .AND. oFont <> nil
      if ::oFont:hFont <> oFont:hFont
         ::oFont:End()
      endif
   endif

   if oFont <> nil
      ::oFont = oFont
      IIF( oFont:nCount == nil, oFont:nCount := 0, ) ;
      oFont:nCount++
      ::SendMsg( 48, oFont:hFont )
   endif

return nil



UTILITY STATIC function TWindow___SetFocus() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if ::lWhen()
      SetFocus( ::hWnd )
   endif

return nil



UTILITY STATIC function TWindow_Load( cInfo) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local nPos := 1, nProps, n, nLen
   local cData, cType, cBuffer

   nProps = Bin2I( SubStr( cInfo, nPos, 2 ) )
   nPos += 2

   for n = 1 to nProps
      nLen  = Bin2I( SubStr( cInfo, nPos, 2 ) )
      nPos += 2
      cData = SubStr( cInfo, nPos, nLen )
      nPos += nLen
      cType = SubStr( cInfo, nPos++, 1 )
      nLen  = Bin2I( SubStr( cInfo, nPos, 2 ) )
      nPos += 2
      cBuffer = SubStr( cInfo, nPos, nLen )
      nPos += nLen

      do case
         case cType == "A"
              OSend( Self, "_" + cData, ARead( cBuffer ) )

         case cType == "O"
              if cData == "oMenu"
                 ::SetMenu( ORead( cBuffer ) )
              else
                 OSend( Self, "_" + cData, ORead( cBuffer ) )
              endif

         case cType == "C"
              if SubStr( cData, 1, 2 ) == "On"
                 if ::oWnd == nil
                    OSend( Self, "_" + cData, { | u1, u2, u3, u4 | OSend( Self, cBuffer, u1, u2, u3, u4 ) } )
                 else
                    OSend( Self, "_" + cData, { | u1, u2, u3, u4 | OSend( Self:oWnd, cBuffer, u1, u2, u3, u4 ) } )
                 endif
              else
                 OSend( Self, "_" + cData, cBuffer )
              endif
              if cData == "cVarName" .AND. ! GetWndDefault() == Self
                 OSend( GetWndDefault(), "_" + ::cVarName, Self )
              endif

         case cType == "L"
              OSend( Self, "_" + cData, cBuffer == ".T." )

         case cType == "N"
              OSend( Self, "_" + cData, Val( cBuffer ) )
      endcase
   next

   if Upper( ::ClassName() ) $ "TLISTBOX;TCOMBOBOX;TTREEVIEW"
      ::SetItems( ::aItems )
   endif

return nil



UTILITY STATIC function TWindow_LoadFile( cFileName) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local cInfo, nPos := 4

   IIF( cFileName == nil, cFileName := "", ) ;

   if ! File( cFileName )
      MsgStop( "File not found: " + cFileName )
      return nil
   endif

   cInfo  = MemoRead( cFileName )
   nPos  += ( 2 + Bin2I( SubStr( cInfo, nPos, 2 ) ) )

   ::Load( SubStr( cInfo, nPos ) )

return nil



UTILITY STATIC function TWindow_LostFocus( hWndGetFocus) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   ::lFocused = .F.

   if oToolTip <> nil
      oToolTip:End()
      oToolTip = nil
   endif

   if ! Empty( ::bLostFocus )
      return Eval( ::bLostFocus, Self, hWndGetFocus )
   endif

return nil



UTILITY STATIC function TWindow_MouseMove( nRow, nCol, nKeyFlags) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if ::oCursor <> nil
      WSetCursor( ::oCursor:hCursor )
   else
      CursorArrow()
   endif

   ::SetMsg( ::cMsg )

   ::CheckToolTip()

   if ::OnMouseMove <> nil
      if ValType( ::OnMouseMove ) == "B"
         Eval( ::OnMouseMove, Self, nRow, nCol, nKeyFlags )
      endif
      if ValType( ::OnMouseMove ) == "C"
         OSend( Self, ::OnMouseMove, Self, nRow, nCol, nKeyFlags )
      endif
   endif

   if ::bMMoved <> nil
      return Eval( ::bMMoved, nRow, nCol, nKeyFlags )
   endif

return 0



UTILITY STATIC function TWindow_CheckToolTip() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow





   if ::cToolTip == nil .AND. ::hWnd <> hWndParent
      if ::hWnd <> hToolTip
         lToolTip = .F.
      endif
   endif

   if ::cToolTip == nil
      if hPrvWnd <> ::hWnd
         hPrvWnd  = ::hWnd
      endif
      if oToolTip <> nil
         oToolTip:End()
         oToolTip = NIL
      endif
      if oTmr <> NIL
         oTmr:End()
         oTmr = NIL
      endif
   else
      if hPrvWnd <> ::hWnd
         hWndParent = GetParent( ::hWnd )
         hPrvWnd    = ::hWnd
         if oToolTip <> nil
            oToolTip:End()
            oToolTip = NIL
         endif
         if oTmr <> NIL
            oTmr:End()
            oTmr = NIL
         endif














            ::ShowToolTip()


      endif
   endif

return nil



UTILITY STATIC function TWindow_ShowToolTip( nRow, nCol, cToolTip) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow



































































































return nil



UTILITY STATIC function TWindow_Shadow() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   SetClassLong( ::hWnd, (-26), nOr( GetClassLong( ::hWnd, (-26) ), 0x00020000 ) )

return nil



UTILITY STATIC function TWindow_DestroyToolTip() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

  if oToolTip <> nil
     oToolTip:End()
     oToolTip = nil
  endif

  hPrvWnd = 0
  hWndParent = 0

return nil



UTILITY STATIC function TWindow_NcMouseMove( nHitTestCode, nRow, nCol) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   hWndParent = 0
   hPrvWnd  = 0
   lToolTip = .F.
   if oToolTip <> NIL
      oToolTip:End()
      oToolTip = NIL
   endif
   if oTmr <> NIL
      oTmr:End()
      oTmr = NIL
   endif

return nil



UTILITY STATIC function TWindow_CommNotify( nDevice, nStatus) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if ::bCommNotify <> nil
      return Eval( ::bCommNotify, nDevice, nStatus )
   endif

return nil



UTILITY STATIC function TWindow___HelpTopic() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   static lShow := .F.

   if ! lShow
      lShow = .T.
      if Empty( ::nHelpId )

         if ::oWnd <> nil .AND.  ! Upper( ::oWnd:ClassName() ) $ "TFOLDER,TPAGES,TDIALOG,TWINDOW,TMDIFRAME,TMDICHILD,TFOLDEREX"
            ::oWnd:HelpTopic()
         else
            if Empty( GetHelpTopic() )
                HelpIndex()
            else
                HelpTopic()
            endif
         endif
      else
        HelpTopic( ::nHelpId )
      endif
      lShow = .F.
   endif

return nil



UTILITY STATIC function TWindow_DropOver( nRow, nCol, nKeyFlags) ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   if ::bDropOver <> nil
      Eval( ::bDropOver, GetDropInfo(), nRow, nCol, nKeyFlags )
   endif

return nil



UTILITY STATIC function TWindow__BeginPaint() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local cPS

   if ::nPaintCount == nil
      ::nPaintCount = 1
   else
      ::nPaintCount++
   endif

   ::hDC = BeginPaint( ::hWnd, @cPS )
   ::cPS = cPS

return nil




function SetDropInfo( uInfo )

   uDropInfo = uInfo

return nil



function GetDropInfo()

   local uInfo := uDropInfo

   uDropInfo = nil

return uInfo



function WndMain()

   local nAt := AScan( aWindows, { | o | ! Empty( o ) .AND. o:hWnd == GetWndApp() } )

return If( nAt <> 0, aWindows[ nAt ], nil )







































































































































































      function _FWH( hWnd, nMsg, nWParam, nLParam, nAt )



   local oWnd

   static aRet := { 0, 0 }

   if nAt <> 0
      oWnd = aWindows[ nAt ]
      if ValType( oWnd ) == "O"
         aRet[ 1 ] = oWnd:HandleEvent( nMsg, nWParam, nLParam )
         aRet[ 2 ] = oWnd:nOldProc
      endif
      return aRet
   endif

return nil



UTILITY STATIC function TWindow_LastActiveCtrl() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local n := Len( ::aControls )
   local oControl, oRadMenu

   if n == 1
      return ::aControls[ 1 ]
   endif

   while n >= 1
      If Upper( ::aControls[ n ]:ClassName() ) == "TRADIO"
         oRadMenu = ::aControls[ n ]:oRadMenu


         while n >= 1 .AND. Upper( ::aControls[ n ]:ClassName() ) == "TRADIO" .AND.  ::aControls[ n ]:oRadMenu == oRadMenu .AND. ( !::aControls[ n ]:lChecked .OR.  !::aControls[ n ]:lActive)
            n--
         end
         oControl := ::aControls[ n ]
         exit
      endif




      If ::aControls[ n ]:lActive .AND.  lAnd( GetWindowLong( ::aControls[ n ]:hWnd, -16 ), 65536 )
         oControl := ::aControls[ n ]
         exit
      endif
      n--
   end

   if oControl == nil
      oControl := ::aControls[ 1 ]
   endif

return oControl



UTILITY STATIC function TWindow_FirstActiveCtrl() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local n := 1
   local oControl, oRadMenu

   if len(::aControls) == 1
      return ::aControls[ 1 ]
   endif

   while n <= Len( ::aControls )
      If Upper( ::aControls[ n ]:ClassName() ) == "TRADIO"
         oRadMenu = ::aControls[ n ]:oRadMenu


         while n <= Len( ::aControls ) .AND. Upper( ::aControls[ n ]:ClassName() ) == "TRADIO" .AND.  ::aControls[ n ]:oRadMenu == oRadMenu .AND. ( !::aControls[ n ]:lChecked .OR.  !::aControls[ n ]:lActive )
            n++
         end
         oControl := ::aControls[ n ]
         exit
      endif

      If ::aControls[ n ]:lActive .AND.  lAnd( GetWindowLong( ::aControls[ n ]:hWnd, -16 ), 65536 )
         oControl := ::aControls[ n ]
         exit
      endif
      n++
   end

   if oControl == nil
      oControl := ::aControls[ 1 ]
   endif

return oControl



UTILITY STATIC function TWindow_SetAlphaLevel() ; local Self AS CLASS TWindow := QSelf() AS CLASS TWindow

   local nExStyle    := GetWindowLong( ::hWnd, -20 )

   if !lAnd( ::nStyle, 1073741824 )
      if ::hAlphaColor == nil .AND. ::hAlphaLevel == nil

         if lAnd( nExStyle, 524288 )
            SetWindowLong( ::hWnd, nAnd( nExStyle, nNot( 524288 ) ) )
         endif
      else
         if ! lAnd( nExStyle, 524288 )
            SetWindowLong( ::hWnd, -20, nOr( nExStyle, 524288 ) )
         endif

         if ::hAlphaColor <> nil
            ::hAlphaColor  := nAnd( ::hAlphaColor, 255 )
         endif
         if ::hAlphaLevel <> nil
            ::hAlphaLevel  := nAnd( ::hAlphaLevel, 255 )
         endif



         SetLayeredWindowAttributes( ::hwnd,    IfNil( ::hAlphaColor, 0 ),    IfNil( ::hAlphaLevel, 255 ),  If( ::hAlphaColor == nil, 2, 1 ) )
      endif
   endif

return Self



function WndParents( xWnd1, xWnd2 )

   Local aParent1, aParent2
   Local nFor, nLen

   aParent1 := ScanParents( xWnd1 )
   aParent2 := ScanParents( xWnd2 )

   nLen := Len( aParent1 )

   for nFor := 1 to nLen
      if Ascan( aParent2, aParent1[ nFor ] ) > 0
         return .T.
      end
   next

return .F.



static function ScanParents( xWnd )

   local aWnd := {}
   local cClassName
   local hWnd

   if ValType( xWnd ) == "O"
      xWnd = xWnd:hWnd
   end

   while ( hWnd := GetParent( xWnd ) ) <> 0
      cClassName = Upper( GetClassName( hWnd ) )
      if "BROWSE" $ cClassName
         exit
      endif
      AAdd( aWnd, hWnd )

      if cClassName == "#32770" .AND.  ! lAnd( GetWindowLong( hWnd, -16 ), 1073741824 )
         exit
      endif
      if cClassName $ "TMDICHILD;TWINDOW"
         exit
      end
      xWnd := hWnd
   end

return aWnd



function oWndFromhWnd( hWnd )


   local nAt := AScan( aWindows, { | o | ValType( o ) == "O" .AND. o:hWnd == hWnd } )

return If( nAt > 0, aWindows[ nAt ] , nil )



function SetAlpha( lOnOff )

  local lOldStatus

  static lStatus := .T.

  lOldStatus = lStatus

  if PCount() == 1 .AND. ValType( lOnOff ) == "L"
     lStatus = lOnOff
  endif

return lOldStatus



function DBufferEnd( hDC, aRestore )

   aRestore[ 3 ] = hDC
   FWDispEnd( aRestore )

return nil
