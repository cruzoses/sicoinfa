#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 29 ".\Prg\Bitmap.prg"
_HB_CLASS TBitmap ; UTILITY FUNCTION TBitmap(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TBitmap" , {TControl():classh} ) ) ; ;

   _HB_MEMBER {AS LOGICAL lRegistered} ; IIF( !.F., s_oClass:AddMultiClsData("LOGICAL",, nScope + IIF( .F., 32, 0 ) + 64, { "lRegistered" }, .F. ), )

   _HB_MEMBER { aProperties} ; IIF( !.F., s_oClass:AddMultiClsData(, { "cBmpFile", "lStretch", "nTop", "nLeft", "nWidth", "nHeight", "nZoom" }, nScope + IIF( .F., 32, 0 ) + 64, { "aProperties" }, .F. ), )

   _HB_MEMBER { nX, nY, nOldX, nOldY} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nX" , "nY" , "nOldX" , "nOldY" }, .F., .F. ), )
   _HB_MEMBER { hBitmap, hPalette} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "hBitmap" , "hPalette" }, .F., .F. ), )
   _HB_MEMBER { cBmpFile, cResName} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cBmpFile" , "cResName" }, .F., .F. ), )
   _HB_MEMBER { lScroll, lStretch} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lScroll" , "lStretch" }, .F., .F. ), )
   _HB_MEMBER { aHotAreas} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aHotAreas" }, .F., .F. ), )
   _HB_MEMBER { nVStep, nHStep} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nVStep" , "nHStep" }, .F., .F. ), )
   _HB_MEMBER { nZoom} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nZoom" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lTransparent} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lTransparent" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lHasAlpha} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lHasAlpha" }, .F., .F. ), )
   _HB_MEMBER { bAlphaLevel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bAlphaLevel" }, .F., .F. ), )
   _HB_MEMBER { hAlphaLevel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "hAlphaLevel" }, .F., .F. ), )
   _HB_MEMBER { bMLeave} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bMLeave" }, .F., .F. ), )




   _HB_MEMBER New( nTop, nLeft, nWidth, nHeight, cResName, cBmpFile, lNoBorder, oWnd, bLClicked, bRClicked, lScroll, lStretch, oCursor, cMsg, lUpdate, bWhen, lPixel, bValid, lDesign) AS CLASS TBitmap; IIF( .F., s_oClass:ModMethod( "New", @TBitmap_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TBitmap_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Define( cResName, cBmpFile, oWnd) AS CLASS TBitmap; IIF( .F., s_oClass:ModMethod( "Define", @TBitmap_Define(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Define", @TBitmap_Define(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   _HB_MEMBER ReDefine( nId, cResName, cBmpFile, oWnd, bLClicked, bRClicked, lScroll, lStretch, oCursor, cMsg, lUpdate, bWhen, bValid, lTransparent) AS CLASS TBitmap; IIF( .F., s_oClass:ModMethod( "ReDefine", @TBitmap_ReDefine(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReDefine", @TBitmap_ReDefine(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AdjControls( lDown); IIF( .F., s_oClass:ModMethod( "AdjControls", @TBitmap_AdjControls(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AdjControls", @TBitmap_AdjControls(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Center(); IIF( .F., s_oClass:ModMethod( "Center", @TBitmap_Center(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Center", @TBitmap_Center(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CopyToClipboard(); IIF( .F., s_oClass:ModMethod( "CopyToClipboard", @TBitmap_CopyToClipboard(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CopyToClipboard", @TBitmap_CopyToClipboard(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Destroy(); IIF( .F., s_oClass:ModMethod( "Destroy", @TBitmap_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Destroy", @TBitmap_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER EraseBkGnd( hDC); IIF( .F., s_oClass:ModMethod( "EraseBkGnd", @TBitmap_EraseBkGnd(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "EraseBkGnd", @TBitmap_EraseBkGnd(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Zoom( nZoom); IIF( .F., s_oClass:ModMethod( "Zoom", @TBitmap_Zoom(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Zoom", @TBitmap_Zoom(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER Command(nWParam, nLParam); IIF( .F., s_oClass:ModInline( "Command", {|Self,nWParam, nLParam | Self, SendMessage( nLoWord( nLParam ), 1024+1024, 0, 0 ), 0 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Command", {|Self,nWParam, nLParam | Self, SendMessage( nLoWord( nLParam ), 1024+1024, 0, 0 ), 0 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Default(); IIF( .F., s_oClass:ModMethod( "Default", @TBitmap_Default(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Default", @TBitmap_Default(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GotFocus(); IIF( .F., s_oClass:ModInline( "GotFocus", {|Self | Self, ::TControl:GotFocus(), ::SetFore() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GotFocus", {|Self | Self, ::TControl:GotFocus(), ::SetFore() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Inspect( cData); IIF( .F., s_oClass:ModMethod( "Inspect", @TBitmap_Inspect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Inspect", @TBitmap_Inspect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER KeyDown( nKey, nFlag); IIF( .F., s_oClass:ModMethod( "KeyDown", @TBitmap_KeyDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "KeyDown", @TBitmap_KeyDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Display(); IIF( .F., s_oClass:ModInline( "Display", {|Self | Self, ::BeginPaint(), ::Paint(), ::EndPaint(), 0 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Display", {|Self | Self, ::BeginPaint(), ::Paint(), ::EndPaint(), 0 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER End(); IIF( .F., s_oClass:ModInline( "End", {|Self | Self, If( ::hWnd == 0, ::Destroy(), ::TControl:End() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "End", {|Self | Self, If( ::hWnd == 0, ::Destroy(), ::TControl:End() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER HandleEvent( nMsg, nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "HandleEvent", @TBitmap_HandleEvent(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HandleEvent", @TBitmap_HandleEvent(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER PageUp(); IIF( .F., s_oClass:ModMethod( "PageUp", @TBitmap_PageUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PageUp", @TBitmap_PageUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER PageDown(); IIF( .F., s_oClass:ModMethod( "PageDown", @TBitmap_PageDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PageDown", @TBitmap_PageDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER PageLeft(); IIF( .F., s_oClass:ModMethod( "PageLeft", @TBitmap_PageLeft(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PageLeft", @TBitmap_PageLeft(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER PageRight(); IIF( .F., s_oClass:ModMethod( "PageRight", @TBitmap_PageRight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PageRight", @TBitmap_PageRight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Paint(); IIF( .F., s_oClass:ModMethod( "Paint", @TBitmap_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Paint", @TBitmap_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER LoadFromClipboard( oWnd); IIF( .F., s_oClass:ModMethod( "LoadFromClipboard", @TBitmap_LoadFromClipboard(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LoadFromClipboard", @TBitmap_LoadFromClipboard(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER LoadFromString( cString); IIF( .F., s_oClass:ModMethod( "LoadFromString", @TBitmap_LoadFromString(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LoadFromString", @TBitmap_LoadFromString(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER LoadImage( cResName, cBmpFile); IIF( .F., s_oClass:ModMethod( "LoadImage", @TBitmap_LoadImage(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LoadImage", @TBitmap_LoadImage(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ReLoad( cResName, cBmpFile); IIF( .F., s_oClass:ModMethod( "ReLoad", @TBitmap_ReLoad(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReLoad", @TBitmap_ReLoad(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   _HB_MEMBER ReSize(nType, nWidth, nHeight); IIF( .F., s_oClass:ModInline( "ReSize", {|Self,nType, nWidth, nHeight | Self, ::ScrollAdjust(), ::TControl:ReSize( nType, nWidth, nHeight ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ReSize", {|Self,nType, nWidth, nHeight | Self, ::ScrollAdjust(), ::TControl:ReSize( nType, nWidth, nHeight ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetBMP(cResName); IIF( .F., s_oClass:ModInline( "SetBMP", {|Self,cResName | Self, ::ReLoad( cResName ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetBMP", {|Self,cResName | Self, ::ReLoad( cResName ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetFore(); IIF( .F., s_oClass:ModInline( "SetFore", {|Self | Self, SetForeBmp( ::hBitmap, ::hPalette ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetFore", {|Self | Self, SetForeBmp( ::hBitmap, ::hPalette ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER LoadBMP(cBmpFile); IIF( .F., s_oClass:ModInline( "LoadBMP", {|Self,cBmpFile | Self, ::ReLoad( "", AllTrim( cBmpFile ) ), ::HasAlpha() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "LoadBMP", {|Self,cBmpFile | Self, ::ReLoad( "", AllTrim( cBmpFile ) ), ::HasAlpha() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER ScrollAdjust(); IIF( .F., s_oClass:ModMethod( "ScrollAdjust", @TBitmap_ScrollAdjust(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ScrollAdjust", @TBitmap_ScrollAdjust(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Initiate(hDlg); IIF( .F., s_oClass:ModInline( "Initiate", {|Self,hDlg | Self, ::TControl:Initiate( hDlg ), ::Default() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Initiate", {|Self,hDlg | Self, ::TControl:Initiate( hDlg ), ::Default() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )




   _HB_MEMBER nHeight(); IIF( .F., s_oClass:ModInline( "nHeight", {|Self | Self, If( ::lDrag == nil, ::lDrag := .F.,), If( ::lDrag, ::TControl:nHeight(), If( ! Empty( ::hBitmap ), nBmpHeight( ::hBitmap ) * ::nZoom, 0 ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "nHeight", {|Self | Self, If( ::lDrag == nil, ::lDrag := .F.,), If( ::lDrag, ::TControl:nHeight(), If( ! Empty( ::hBitmap ), nBmpHeight( ::hBitmap ) * ::nZoom, 0 ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )




   _HB_MEMBER nWidth(); IIF( .F., s_oClass:ModInline( "nWidth", {|Self | Self, If( ::lDrag == nil, ::lDrag := .F.,), If( ::lDrag, ::TControl:nWidth(), If( ! Empty( ::hBitmap ), nBmpWidth( ::hBitmap ) * ::nZoom, 0 ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "nWidth", {|Self | Self, If( ::lDrag == nil, ::lDrag := .F.,), If( ::lDrag, ::TControl:nWidth(), If( ! Empty( ::hBitmap ), nBmpWidth( ::hBitmap ) * ::nZoom, 0 ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER ScrollUp(); IIF( .F., s_oClass:ModMethod( "ScrollUp", @TBitmap_ScrollUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ScrollUp", @TBitmap_ScrollUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ScrollLeft(); IIF( .F., s_oClass:ModMethod( "ScrollLeft", @TBitmap_ScrollLeft(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ScrollLeft", @TBitmap_ScrollLeft(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ScrollDown(); IIF( .F., s_oClass:ModMethod( "ScrollDown", @TBitmap_ScrollDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ScrollDown", @TBitmap_ScrollDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ScrollRight(); IIF( .F., s_oClass:ModMethod( "ScrollRight", @TBitmap_ScrollRight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ScrollRight", @TBitmap_ScrollRight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nXExtra(); IIF( .F., s_oClass:ModInline( "nXExtra", {|Self | Self, ::nHeight() - ( ::TControl:nHeight() ) + 1 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "nXExtra", {|Self | Self, ::nHeight() - ( ::TControl:nHeight() ) + 1 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER nYExtra(); IIF( .F., s_oClass:ModInline( "nYExtra", {|Self | Self, ::nWidth()  - ( ::TControl:nWidth() ) + 1 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "nYExtra", {|Self | Self, ::nWidth()  - ( ::TControl:nWidth() ) + 1 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER VScroll( nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "VScroll", @TBitmap_VScroll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "VScroll", @TBitmap_VScroll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER HScroll( nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "HScroll", @TBitmap_HScroll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HScroll", @TBitmap_HScroll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER HasAlpha(); IIF( .F., s_oClass:ModInline( "HasAlpha", {|Self | Self, ::lHasAlpha := HasAlpha( ::hBitmap ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "HasAlpha", {|Self | Self, ::lHasAlpha := HasAlpha( ::hBitmap ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER nAlphaLevel(nLevel); _HB_MEMBER _nAlphaLevel(nLevel); IIF( .F., s_oClass:ModMethod( "nAlphaLevel", @TBitmap_nAlphaLevel(), 1 + 32, .F. ), s_oClass:AddMethod( "nAlphaLevel", @TBitmap_nAlphaLevel(), 1 + 32, .F. ) ) ; IIF( .F., s_oClass:ModMethod( "_nAlphaLevel", @TBitmap_nAlphaLevel() ), s_oClass:AddMethod( "_nAlphaLevel", @TBitmap_nAlphaLevel() ) ) ;

   _HB_MEMBER MouseLeave( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "MouseLeave", @TBitmap_MouseLeave(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MouseLeave", @TBitmap_MouseLeave(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));






; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TBitmap ;





UTILITY STATIC function TBitmap_New( nTop, nLeft, nWidth, nHeight, cResName, cBmpFile, lNoBorder, oWnd, bLClicked, bRClicked, lScroll, lStretch, oCursor, cMsg, lUpdate, bWhen, lPixel, bValid, lDesign) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap








   IIF( nTop == nil, nTop := 0, ) ; IIF( nLeft == nil, nLeft := 0, ); IIF( oWnd == nil, oWnd := GetWndDefault(), ); IIF( lNoBorder == nil, lNoBorder := .F., ); IIF( lScroll == nil, lScroll := .F., ); IIF( lStretch == nil, lStretch := .F., ); IIF( lUpdate == nil, lUpdate := .F., ); IIF( lPixel == nil, lPixel := .F., ); IIF( lDesign == nil, lDesign := .F., );

   ::nZoom     = 1
   ::hBitmap   = 0
   ::hPalette  = 0
   ::lStretch  = lStretch

   ::LoadImage( cResName, cBmpFile )

   if ! Empty( cResName ) .OR. ! Empty( cBmpFile )

      IIF( nWidth == nil, nWidth := Min( ::nWidth(), oWnd:nWidth() ), ) ; IIF( nHeight == nil, nHeight := Min( ::nHeight(), oWnd:nHeight() ), );

   else
      IIF( nWidth == nil, nWidth := 100, ) ; IIF( nHeight == nil, nHeight := 100, );

   endif






      ::nTop   = If( lPixel, nTop, nTop * 14 )
      ::nLeft  = If( lPixel, nLeft, nLeft * 8)


   ::nBottom   = ::nTop + nHeight - 1
   ::nRight    = ::nLeft + nWidth - 1
   ::nX        = 0
   ::nY        = 0



   ::nStyle    = nOR( If( ! lNoBorder, 8388608, 0 ), If( lScroll, nOR( 2097152, 1048576 ), 0 ), 1073741824, 268435456, 67108864, 33554432, 131072 )
   ::nId       = ::GetNewId()
   ::oWnd      = oWnd
   ::lCaptured = .F.
   ::lDrag     = lDesign
   ::bLClicked = bLClicked
   ::bRClicked = bRClicked
   ::lScroll   = lScroll
   ::aHotAreas = {}
   ::nVStep    = 1
   ::nHStep    = 1
   ::lUpdate   = lUpdate
   ::bWhen     = bWhen
   ::bValid    = bValid
   ::lTransparent = .F.

   ::hAlphaLevel = 255

   ::SetColor( GetSysColor( 8 ), GetSysColor( 15 ) )

   if ! Empty( cBmpFile )
      ::cBmpFile = cBmpFile
   endif

   ::oCursor   = oCursor





   ::Register( nOR( 1, 2 ) )

   if ! Empty( oWnd:hWnd )
      ::Create()
      ::Default()
      ::lVisible = .T.
      oWnd:AddControl( Self )
   else
      oWnd:DefControl( Self )
      ::lVisible  = .F.
   endif

   if lDesign
      ::CheckDots()
   endif

return Self





UTILITY STATIC function TBitmap_Define( cResName, cBmpFile, oWnd) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   local aBmpPal

   IIF( oWnd == nil, oWnd := GetWndDefault(), ) ;

   ::oWnd     = oWnd
   ::nZoom    = 1
   ::hWnd     = 0
   ::hBitmap  = 0
   ::hPalette = 0
   ::lScroll  = .F.

   ::hAlphaLevel = 255

   ::SetColor( GetSysColor( 8 ), GetSysColor( 15 ) )

   if ! Empty( cResName )
      aBmpPal    = PalBmpLoad( cResName )
      ::hBitmap  = aBmpPal[ 1 ]
      ::hPalette = aBmpPal[ 2 ]
      cBmpFile   = nil
   endif

   if cBmpFile <> nil
      cBmpFile = AllTrim( cBmpFile )
   endif

   if ! Empty( cBmpFile ) .AND. File( cBmpFile )
      ::cBmpFile  = cBmpFile
      aBmpPal     = PalBmpRead( If( oWnd <> nil, oWnd:GetDC(), 0 ), cBmpFile )
      ::hBitmap   = aBmpPal[ 1 ]
      ::hPalette  = aBmpPal[ 2 ]
      IIF( oWnd <> nil, oWnd:ReleaseDC(), )
   endif

   if ::hBitmap <> 0
      PalBmpNew( 0, ::hBitmap, ::hPalette )
   endif

return Self



UTILITY STATIC function TBitmap_EraseBkGnd( hDC) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   if ! Empty( ::bEraseBkGnd )
      return Eval( ::bEraseBkGnd, hDC )
   endif

   if ::hBitmap <> 0
      return 1
   elseif ::oBrush <> nil
      FillRect( hDC, GetClientRect( ::hWnd ), ::oBrush:hBrush )
      return 1
   endif

return nil



UTILITY STATIC function TBitmap_AdjControls( lDown) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   local n, oCtl

   IIF( lDown == nil, lDown := .F., ) ;

   if ! Empty( ::aControls ) .AND. ::nOldX <> ::nX
      if ! lDown
         for n = 1 to Len( ::aControls )
             oCtl = ::aControls[ n ]
             ::aControls[ n ]:Move( oCtl:nTop + ( ::nX - ::nOldX ), oCtl:nLeft )
         next
      else
         for n = Len( ::aControls ) to 1 step -1
             oCtl = ::aControls[ n ]
             ::aControls[ n ]:Move( oCtl:nTop + ( ::nX - ::nOldX ), oCtl:nLeft )
         next
      endif
   endif

return nil



UTILITY STATIC function TBitmap_Center() ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   local aRect := ::oWnd:GetCliRect()

   local oRect := TRect():New( aRect:nTop, aRect:nLeft, aRect:nBottom, aRect:nRight )

   oRect:nTop    := Max( 0, Int( ( aRect:nBottom - ::nHeight ) / 2 ) )
   oRect:nBottom := oRect:nTop  + ::nHeight - 1
   oRect:nLeft   := Max( 0, Int( ( aRect:nRight - ::nWidth ) / 2 ) )
   oRect:nRight  := oRect:nLeft + ::nWidth - 1

   ::SetCoors( oRect )

return nil



UTILITY STATIC function TBitmap_Default() ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   if ::lScroll == nil
      ::lScroll = WndHasScrolls( ::hWnd )
   endif

   if ::lScroll
      ::oVScroll := TScrollBar():WinNew(,,, (!.F.) .OR. .T., Self,,,,,,,,, .F.,, )
      ::oHScroll := TScrollBar():WinNew(,,, (!.T.), Self,,,,,,,,, .F.,, )
      ::ScrollAdjust()
   endif




   if ::hBitmap <> 0
      PalBmpNew( ::hWnd, ::hBitmap, ::hPalette )
   endif

return nil



UTILITY STATIC function TBitmap_CopyToClipboard() ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   local oClipboard := TClipboard():New( 2 )

   oClipboard:SetBitmap( Self )

   oClipboard:End()

return nil



UTILITY STATIC function TBitmap_LoadFromClipboard( oWnd) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   local oClipboard := TClipboard():New( 2, oWnd )
   local hBitmap    := oClipboard:GetBitmap()
   local lSuccess   := .F.

   if hBitmap <> 0
      if ::hBitmap <> 0
         PalBmpFree( ::hBitmap, ::hPalette )
         ::hBitmap  = 0
         ::hPalette = 0
      endif

      ::hBitmap  = hBitmap
      ::hPalette = 0
      PalBmpNew( ::hWnd, hBitmap, 0 )
      ::ScrollAdjust()
      ::nX = 0
      ::nY = 0
      lSuccess = .T.
      ::hBitmap()
   endif


   oClipboard:End()

return lSuccess



UTILITY STATIC function TBitmap_LoadFromString( cString) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   local hBmpOld := ::hBitmap
   local hPalOld := ::hPalette

   if Empty( cString )
      return .F.
   endif

   ::hBitmap = CreateMemBitmap( ::GetDC(), cString )
   ::ReleaseDC()

   if ! Empty( hBmpOld )
      PalBmpFree( hBmpOld, hPalOld )
   endif

   PalBmpNew( ::hWnd, ::hBitmap, nil )
   ::HasAlpha()

return .T.



UTILITY STATIC function TBitmap_Destroy() ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   if ::hBitmap <> 0
      PalBmpFree( ::hBitmap, ::hPalette )
      ::hBitmap  = 0
      ::hPalette = 0
   endif

   if ::oVScroll <> nil
      ::oVScroll:End()
   endif

   if ::oHScroll <> nil
      ::oHScroll:End()
   endif

   if ::hWnd <> 0
      ::TControl:Destroy()
   else
      if ::oBrush <> nil
         ::oBrush:End()
      endif
   endif

return nil





UTILITY STATIC function TBitmap_ReDefine( nId, cResName, cBmpFile, oWnd, bLClicked, bRClicked, lScroll, lStretch, oCursor, cMsg, lUpdate,  bWhen, bValid, lTransparent) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap


   IIF( lScroll == nil, lScroll := .F., ) ; IIF( lStretch == nil, lStretch := .F., ); IIF( lUpdate == nil, lUpdate := .F., ); IIF( lTransparent == nil, lTransparent := .F., ); IIF( oWnd == nil, oWnd := GetWndDefault(), );

   ::nId       = nId
   ::nX        = 0
   ::nY        = 0
   ::nOldX     = 0
   ::nOldY     = 0
   ::lCaptured = .F.
   ::lDrag     = .F.
   ::bLClicked = bLClicked
   ::bRClicked = bRClicked
   ::lScroll   = lScroll
   ::lStretch  = lStretch
   ::aHotAreas = {}
   ::oCursor   = oCursor
   ::oWnd      = oWnd
   ::nVStep    = 1
   ::nHStep    = 1
   ::lUpdate   = lUpdate
   ::bWhen     = bWhen
   ::bValid    = bValid
   ::nZoom     = 1
   ::lTransparent = lTransparent

   ::LoadImage( cResName, If( cBmpFile <> nil, AllTrim( cBmpFile ), nil ) )

   ::Register( nOR( 1, 2 ) )

   if oWnd <> nil
      oWnd:DefControl( Self )
   endif



   ::SetColor( GetSysColor( 8 ), GetSysColor( 15 ) )

return Self



UTILITY STATIC function TBitmap_HandleEvent( nMsg, nWParam, nLParam) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   if nMsg == 675
      return ::MouseLeave( nHiWord( nLParam ), nLoWord( nLParam ), nWParam )
   elseif nMsg == 132
      return DefWindowProc( ::hWnd, nMsg, nWParam, nLParam )
   endif

return ::TControl:HandleEvent( nMsg, nWParam, nLParam )



UTILITY STATIC function TBitmap_MouseLeave( nRow, nCol, nFlags) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   if ! Empty( ::bMLeave )
      Eval( ::bMLeave, nRow, nCol, nFlags, Self )
   endif

return nil





UTILITY STATIC function TBitmap_KeyDown( nKey, nFlags) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   if ::lScroll

      do case
         case nKey == 38
              ::ScrollDown()

         case nKey == 40
              ::ScrollUp()

         case nKey == 33
              ::PageUp()

         case nKey == 34
              ::PageDown()

         otherwise
              return ::TControl:KeyDown( nKey, nFlags )
      endcase
   else
      return ::TControl:KeyDown( nKey, nFlags )
   endif

return 0



UTILITY STATIC function TBitmap_nAlphaLevel(uNew) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   if uNew <> NIL
      ::hAlphaLevel := uNew
   else
      if ::bAlphaLevel <> NIL
         ::hAlphaLevel = eval( ::bAlphaLevel, Self )
      endif
   endif

return ::hAlphaLevel



UTILITY STATIC function TBitmap_PageUp() ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   local nVisible := ::TControl:nHeight() - If( ::oHScroll:nMax <> 0, GetSysMetrics( 3 ), 0 ) - 1

   ::nOldX = ::nX
   if ::nX < -nVisible
      ::nX += nVisible
   else
      ::nX = 0
   endif
   ::Refresh( .F. )
   ::oVScroll:SetPos( Int( -::nX / ::nVStep ) )

   ::AdjControls()

return nil



UTILITY STATIC function TBitmap_PageDown() ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   local nVisible := ::TControl:nHeight() - If( ::oHScroll:nMax <> 0, GetSysMetrics( 3 ), 0 ) - 1

   ::nOldX = ::nX
   ::nX -= Min( nVisible, ::nHeight() + ::nX - nVisible )
   ::Refresh( .F. )
   ::oVScroll:SetPos( Int( -::nX / ::nVStep ) )

   ::AdjControls()

return nil



UTILITY STATIC function TBitmap_PageLeft() ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   local nVisible := ::TControl:nWidth() - If( ::oVScroll:nMax <> 0, GetSysMetrics( 2 ), 0 ) - 1

   ::nOldY = ::nY
   if ::nY < -nVisible
      ::nY += nVisible
   else
      ::nY = 0
   endif
   ::Refresh( .F. )
   ::oHScroll:SetPos( Int( -::nY / ::nHStep ) )

   ::AdjControls()

return nil



UTILITY STATIC function TBitmap_PageRight() ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   local nVisible := ::TControl:nWidth() - If( ::oVScroll:nMax <> 0, GetSysMetrics( 2 ), 0 ) - 1

   ::nOldY = ::nY
   ::nY -= Min( nVisible, ::nWidth() + ::nY - nVisible )
   ::Refresh( .F. )
   ::oHScroll:SetPos( Int( -::nY / ::nHStep ) )

   ::AdjControls()

return nil



UTILITY STATIC function TBitmap_Paint() ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   local aInfo := ::DispBegin(), hBmpOld, nZeroZeroClr, nOldClr
   local nAlphaLevel, hBitmap

   if IsAppThemed() .AND. Empty( ::oBrush:hBitmap ) .AND. ::lTransparent
      if ::oWnd:ClassName() == "TDIALOG"
         DrawPBack( ::hWnd, ::hDC )
      else
         FillRect( ::hDC, GetClientRect( ::hWnd ), ::oWnd:oBrush:hBrush )
      endif
   else
      SetBrushOrgEx( ::hDC, nBmpWidth( ::oBrush:hBitmap ) - ::nLeft, nBmpHeight( ::oBrush:hBitmap ) - ::nTop )
      FillRect( ::hDC, GetClientRect( ::hWnd ), ::oWnd:oBrush:hBrush )
   endif

   if Empty( ::hBitmap ) .AND. ! Empty( ::cBmpFile )
      ::LoadBmp( ::cBmpFile )
   endif

   if ! Empty( ::hBitmap )
      if ::lStretch
         if SetAlpha() .AND. ::lHasAlpha
            hBitmap := resizebmp( ::hBitmap, ::TControl:nWidth(), ::TControl:nHeight )
            ABPaint( ::hDC, ::nX, ::nY, hBitmap, ::nAlphaLevel() )
         else
            if ! ::lTransparent

               PalBmpDraw( ::hDC, ::nX, ::nY, ::hBitmap, ::hPalette, ::TControl:nWidth(), ::TControl:nHeight(),, ::lTransparent, ::nClrPane )
            else
               hBmpOld = SelectObject( ::hDC, ::hBitmap )
               nZeroZeroClr = GetPixel( ::hDC, 0, 0 )
               SelectObject( ::hDC, hBmpOld )
               nOldClr = SetBkColor( ::hDC, nRGB( 255, 255, 255 ) )

               TransBmp( ::hBitmap, ::nWidth(), ::nHeight(), nZeroZeroClr, ::hDC, ::nY, ::nX, ::TControl:nWidth(), ::TControl:nHeight() )
               SetBkColor( ::hDC, nOldClr )
            endif
         endif
      else
         if ::nZoom > 0

            if SetAlpha() .AND. ::lHasAlpha
               hBitmap := resizebmp( ::hBitmap, ::nWidth, ::nHeight )
               ABPaint( ::hDC, ::nX, ::nY, hBitmap, ::nAlphaLevel() )
            else
              if ! ::lTransparent

                  PalBmpDraw( ::hDC, ::nX, ::nY, ::hBitmap, ::hPalette, ::nWidth(), ::nHeight(),, ::lTransparent, ::nClrPane )
               else
                  hBmpOld = SelectObject( ::hDC, ::hBitmap )
                  nZeroZeroClr = GetPixel( ::hDC, 0, 0 )
                  SelectObject( ::hDC, hBmpOld )
                  nOldClr = SetBkColor( ::hDC, nRGB( 255, 255, 255 ) )
                  TransBmp( ::hBitmap, ::nWidth(), ::nHeight(), nZeroZeroClr, ::hDC, ::nY, ::nX, ::nWidth(), ::nHeight() )
                  SetBkColor( ::hDC, nOldClr )
               endif
            endif
         endif
      endif
   endif

   if ::bPainted <> nil
      Eval( ::bPainted, ::hDC )
   endif

   ::DispEnd( aInfo )

return nil



UTILITY STATIC function TBitmap_ReLoad( cResName, cBmpFile) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

  local lSuccess := ::LoadImage( cResName, cBmpFile )

  if lSuccess .AND. ! Empty( ::hWnd )
     ::ScrollAdjust()
     ::nX = 0
     ::nY = 0
     ::Refresh()
  endif

return lSuccess



UTILITY STATIC function TBitmap_LoadImage( cResName, cBmpFile) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   local lChanged := .F.
   local hBmpOld  := ::hBitmap
   local hPalOld  := ::hPalette
   local aBmpPal

   IIF( cResName == nil, cResName := ::cResName, ) ; IIF( cBmpFile == nil, cBmpFile := ::cBmpFile, );

   if ! Empty( cResName )
       aBmpPal    = PalBmpLoad( cResName )
       ::hBitmap  = aBmpPal[ 1 ]
       ::hPalette = aBmpPal[ 2 ]
       lChanged  := .T.
       cBmpFile  := nil

   elseif File( cBmpFile )
       aBmpPal = PalBmpRead( ::GetDC(), AllTrim( cBmpFile ) )
       ::hBitmap = aBmpPal[ 1 ]
       ::hPalette = aBmpPal[ 2 ]
       ::ReleaseDC()
       lChanged  := .T.
       cResName  := nil

   endif

   if lChanged

      ::cResName = cResName
      ::cBmpFile = cBmpFile

      if ! Empty( hBmpOld )
         PalBmpFree( hBmpOld, hPalOld )
      endif

      PalBmpNew( ::hWnd, ::hBitmap, ::hPalette )

   endif

   ::HasAlpha()

return lChanged



UTILITY STATIC function TBitmap_ScrollUp() ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   local nVisible := ::TControl:nHeight() - If( ::oHScroll:nMax <> 0, GetSysMetrics( 3 ), 0 )
   local nStep

   ::nOldX = ::nX
   ::oVScroll:GoDown()

   nStep := ( ::nHeight() + ::nX ) - nVisible

   if ::nHeight() > nVisible
      if ::nX > -::nXExtra() - If( ::oHScroll:nMax <> 0, GetSysMetrics( 3 ), 0 )
         ::nX -= Min( nStep, ::nVStep )
         ::Refresh( .F. )
      endif
   endif

   ::AdjControls()

return nil



UTILITY STATIC function TBitmap_ScrollDown() ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   ::nOldX = ::nX

   ::oVScroll:GoUp()
   ::nX := Min( ::nX + ::nVStep, 0 )
   ::Refresh( .F. )

   ::AdjControls( .T. )

return nil



UTILITY STATIC function TBitmap_ScrollLeft() ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   local nVisible := ::TControl:nWidth() - If( ::oVScroll:nMax <> 0, GetSysMetrics( 2 ), 0 ) - 1
   local nStep, n

   nStep := ( ::nWidth() + ::nY ) - nVisible

   ::oHScroll:GoDown()
   if ::nWidth() > nVisible
      if ::nY > -::nYExtra() - If( ::oVScroll:nMax <> 0, GetSysMetrics( 2 ), 0 )
         ::nY -= Min( nStep, ::nHStep )
         ::Refresh( .F. )
      endif
   endif

   if ! Empty( ::aControls )
      for n = Len( ::aControls ) to 1 step -1

          ::aControls[ n ]:Move( ::aControls[ n ]:nTop, ::aControls[ n ]:nLeft - 10 )
      next
   endif

return nil



UTILITY STATIC function TBitmap_ScrollRight() ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap


   local nVisible := ::TControl:nWidth() - If( ::oVScroll <> nil .AND.  ::oVScroll:nMax <> 0, GetSysMetrics( 2 ), 0 ) - 1
   local n

   ::oHScroll:GoUp()
   if ::nWidth() > nVisible
      ::nY := Min( ::nY + ::nHStep, 0 )
      ::Refresh( .F. )
   endif

   if ! Empty( ::aControls )
      for n = Len( ::aControls ) to 1 step -1

          ::aControls[ n ]:Move( ::aControls[ n ]:nTop, ::aControls[ n ]:nLeft + 10 )
      next
   endif

return nil



UTILITY STATIC function TBitmap_VScroll( nWParam, nLParam) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap




      local nScrollCode := nLoWord( nWParam )


   local nPos := nHiWord( nWParam )

   do case
      case nScrollCode == 0
           ::ScrollDown()

      case nScrollCode == 1
           ::ScrollUp()

      case nScrollCode == 2
           ::PageUp()

      case nScrollCode == 3
           ::PageDown()

      case nScrollCode == 6
           ::nX = 0
           ::oVScroll:GoTop()
           ::Refresh( .F. )

      case nScrollCode == 7
           ::nX = ::nXExtra()
           ::oVScroll:GoBottom()
           ::Refresh( .F. )






      otherwise
           return nil
   endcase

return 0



UTILITY STATIC function TBitmap_HScroll( nWParam, nLParam) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap




      local nScrollCode := nLoWord( nWParam )


   local nPos := nHiWord( nWParam )

   do case
      case nScrollCode == 0
           ::ScrollRight()

      case nScrollCode == 1
           ::ScrollLeft()

      case nScrollCode == 2
           ::PageLeft()

      case nScrollCode == 3
           ::PageRight()

      case nScrollCode == 6
           ::nY = 0
           ::oHScroll:GoTop()
           ::Refresh( .F. )

      case nScrollCode == 7
           ::nY = ::nYExtra()
           ::oHScroll:GoBottom()
           ::Refresh( .F. )






      otherwise
           return nil
   endcase

return 0



UTILITY STATIC function TBitmap_ScrollAdjust() ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   local nVisHeight, nVisWidth
   local lHor := .F., lVer := .F.

   nVisHeight = ::TControl:nHeight()
   nVisWidth  = ::TControl:nWidth()

   if ::lScroll .AND. ! Empty( ::hBitmap ) .AND. ::oVScroll <> nil
      if ::nHeight() <= nVisHeight .OR. ::lStretch
         ::oVScroll:SetRange( 0, 0 )
         ::nX = 0

      else
         lVer = .T.
      endif
      if ::nWidth() <= nVisWidth .OR. ::lStretch .AND. ::oHScroll <> nil
         ::oHScroll:SetRange( 0, 0 )

         ::nY = 0
      else
         lHor = .T.
      endif
      if lVer .AND. ::oVScroll <> nil

         ::oVScroll:SetRange( 0, ( ( ::nXExtra() +  If( lHor, GetSysMetrics( 3 ), 0 ) ) / ::nVStep ) )
         if ::nX == 0
            ::oVScroll:SetPos( 0 )
         endif
      endif
      if lHor .AND. ::oHScroll <> nil

         ::oHScroll:SetRange( 0, Int( ( ::nYExtra() +  If( lVer, GetSysMetrics( 2 ), 0 ) ) / ::nHStep ) )
         if ::nY == 0
            ::oHScroll:SetPos( 0 )
         endif
      endif
   endif

return nil



UTILITY STATIC function TBitmap_Zoom( nZoom) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   if nZoom <> nil
      ::nZoom = nZoom
   endif

return ::nZoom



UTILITY STATIC function TBitmap_Inspect( cData) ; local Self AS CLASS TBitmap := QSelf() AS CLASS TBitmap

   do case
      case cData == "cBmpFile"





           return { | cFileName |  cFileName := If( cFileName == nil, "*.bmp|*.bmp", cFileName + "|*.bmp" ), cFileName := cGetFile( cFileName, "Select a BMP file" ), ::LoadImage( ,cFileName ), cFileName }
   endcase

return nil













function PalBmpFree( hBmp, hPal )

   DeleteObject( hBmp )
   DeleteObject( hPal )

return nil
