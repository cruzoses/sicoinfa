#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 22 ".\Prg\Utildbf.prg"
static aResources             := {}
static aAdsDirectory          := {}









FUNCTION DbSwapUp( cAlias, oBrw )

    local aRecNew
   local aRecOld  := dbScatter( cAlias )
   local nOrdNum  := ( cAlias )->( OrdSetFocus( 0 ) )
   local nRecNum  := ( cAlias )->( RecNo() )

   ( cAlias )->( dbSkip( -1 ) )

   if ( cAlias )->( Bof() )
        Tone(300,1)
        ( cAlias )->( dbGoTo( nRecNum ) )
   else
      aRecNew     := dbScatter( cAlias )
      ( cAlias )->( dbSkip( 1 ) )
      dbGather( aRecNew, cAlias )
      ( cAlias )->( dbSkip( -1 ) )
      dbGather( aRecOld, cAlias )
   end

   ( cAlias )->( OrdSetFocus( nOrdNum ) )

   if !Empty( oBrw )
      oBrw:Refresh()
      oBrw:Select( 0 )
      oBrw:Select( 1 )
      oBrw:SetFocus()
   end

RETURN NIL



FUNCTION dbSwapDown( cAlias, oBrw )

    local aRecNew
   local aRecOld  := dbScatter( cAlias )
   local nOrdNum  := ( cAlias )->( OrdSetFocus( 0 ) )
   local nRecNum  := ( cAlias )->( RecNo() )

   ( cAlias )->( dbSkip() )

   if ( cAlias )->( Eof() )

      Tone( 300, 1 )
        ( cAlias )->( dbGoTo( nRecNum ) )

   else

      aRecNew     := dbScatter( cAlias )
      ( cAlias )->( dbSkip( -1 ) )

      dbGather( aRecNew, cAlias )
      ( cAlias )->( dbSkip() )

      dbGather( aRecOld, cAlias )

   end

   ( cAlias )->( OrdSetFocus( nOrdNum ) )

   if !Empty( oBrw )
      oBrw:Refresh()
      oBrw:Select( 0 )
      oBrw:Select( 1 )
      oBrw:SetFocus()
   end

Return nil



FUNCTION DBTrans( cAliOrigen, cAliDestino, lApp )

    local i
    local nField     := (cAliOrigen)->( Fcount() )

    IIF( lApp == nil, lApp := .F., ) ;

    IF lApp
        (cAliDestino)->( dbAppend() )
   ELSE
      (cAliDestino)->( dbRLock() )
   end

    for i = 1 to nField
        (cAliDestino)->( FieldPut( i, (cAliOrigen)->( FieldGet( i ) ) ) )
    next

   ( cAliDestino )->( dbUnLock() )

RETURN NIL






FUNCTION DBFLock( cAlias )

    if DBLock( cAlias, 1 )
      return .T.
   endif

   while ApoloMsgNoYes( "Fichero Bloquedo," + Chr(13)+Chr(10) + "¿ Reintentar ?" )

        if DBLock( cAlias, 1 )
         return .T.
        else
            loop
        endif

   enddo

RETURN .F.



Function aBlankArray( aBlank, cAlias )

   local i
   local aStruct  := ( cAlias )->( dbStruct() )

   for i = 1 to ( cAlias )->( fCount() )
      Do Case
         Case aStruct[ i, 2 ] == "C"
            aBlank[ i ] := Space( aStruct[ i, 3 ] )
         Case aStruct[ i, 2 ] == "M"
            aBlank[ i ] := ""
         Case aStruct[ i, 2 ] == "N"
            aBlank[ 1 ] := Val( "0." + Replicate( "0", aStruct[ i, 4 ] ) )
         Case aStruct[ i, 2 ] == "L"
            aBlank[ 1 ] := .F.
         Case aStruct[ i, 2 ] == "D"
            aBlank[ 1 ] := GetSysDate()
      end
   next

RETURN aBlank






FUNCTION cFilName( cFilName )

    local n := 1

    while file( cFilName + rjust( str( n ), "0", 2 ) )
        n++
    end

RETURN ( cFilName + rjust( str( n ), "0", 2 ) )








FUNCTION dbFirst( cAlias, nField, oGet, xDesde, nOrd )

    local xValRet
   local nPosAct
   local nOrdAct

   IIF( cAlias == nil, cAlias := Alias(), ) ;
    IIF( nField == nil, nField := 1, ) ;





   if IsObject( cAlias )
      cAlias      := cAlias:cAlias
   end

   nPosAct        := ( cAlias )->( Recno() )

   if nOrd <> nil
      nOrdAct     := ( cAlias )->( OrdSetFocus( nOrd ) )
   end


   if Empty( xDesde )
      ( cAlias )->( dbGoTop() )
   else
      ( cAlias )->( dbSeek( xDesde, .T. ) )
      if ( cAlias )->( eof() )
         ( cAlias )->( dbGoTop() )
      end
   end

   if IsChar( nField )
      nField      := ( cAlias )->( FieldPos( nField ) )
   end

   xValRet        := ( cAlias )->( FieldGet( nField ) )

   ( cAlias )->( dbGoTo( nPosAct ) )

   if !Empty( nOrd )
      ( cAlias )->( OrdSetFocus( nOrdAct ) )
   end

   if !Empty( oGet )
        oGet:cText( xValRet )
      Return .T.
   end

Return ( xValRet )







FUNCTION dbFirstIdx( cAlias, nOrden, oGet, xDesde )

    local xValRet

    IIF( cAlias == nil, cAlias := Alias(), ) ;

    IF nOrden == NIL
        nOrden := ( cAlias )->( OrdSetFocus() )
    ELSE
        ( cAlias )->( OrdSetFocus( nOrden ) )
    end

    dbSelectArea( ( cAlias ) )

    IF xDesde == NIL
        (cAlias)->( DbGoTop() )
    ELSE
        (cAlias)->( DbSeek( xDesde, .T. ) )
        IF (cAlias)->(Eof())
            (cAlias)->(DbGoTop())
        END
    END

    xValRet    := Eval( Compile( (cAlias)->( OrdKey( nOrden ) ) ) )

    IF oGet <> NIL
        oGet:cText( xValRet )
        RETURN .T.
    END

RETURN ( xValRet )







FUNCTION dbLastIdx( cAlias, nOrden, oGet, xHasta )

    LOCAL xValRet

    IIF( cAlias == nil, cAlias := Alias(), ) ;

    IF nOrden == NIL
        nOrden := ( cAlias )->( OrdSetFocus() )
    ELSE
        ( cAlias )->( OrdSetFocus( nOrden ) )
    end

    dbSelectArea( ( cAlias ) )

    IF xHasta == NIL
        (cAlias)->(DbGoBottom())
    ELSE
        (cAlias)->( DbSeek( xHasta, .T. ) )
        IF (cAlias)->( Eof() )
            (cAlias)->(DbGoBottom())
        END
    END

    xValRet := Eval( Compile( (cAlias)->( OrdKey( nOrden ) ) ) )

    IF oGet <> NIL
        oGet:cText( xValRet )
        RETURN .T.
    END

RETURN ( xValRet )







FUNCTION DBRetIndex( cAlias )

    local aIndexes := { "<Ninguno>" }
    local cIndice
   local i        := 1

   IF Empty( ( cAlias )->( OrdSetFocus() ) )
        RETURN aIndexes
    end

   while .T.
      cIndice     := ( cAlias )->( OrdName( i ) )

      if cIndice <> ""
         aAdd( aIndexes, cIndice )
      else
         exit
      end

        i++
   end

RETURN aIndexes



FUNCTION aDbfToArr( cAlias, nField )

   local aTabla   := {}

    IIF( cAlias == nil, cAlias := Alias(), ) ;
    IIF( nField == nil, nField := 1, ) ;

   ( cAlias )->( dbGoTop() )
   while !( cAlias )->( Eof() )
      aAdd( aTabla, cValToChar( ( cAlias )->( FieldGet( nField ) ) ) )
      ( cAlias )->( dbSkip() )
   end
   ( cAlias )->( dbGoTop() )

RETURN aTabla








FUNCTION ChangeIndex( cAlias, nRadOrden, oGetDesde, oGetHasta )

    IIF( cAlias == nil, cAlias := Alias(), ) ;
    IIF( nRadOrden == nil, nRadOrden := ( cAlias )->( OrdSetFocus() ), ) ;

    IF oGetDesde <> NIL
        oGetDesde:cText( DBFirstIdx( cAlias, nRadOrden ) )
    end

    IF oGetHasta <> NIL
        oGetHasta:cText( DBLastIdx( cAlias, nRadOrden ) )
    end

RETURN .T.



FUNCTION oExiste( oClave, cAlias )

RETURN Existe( oClave:varGet(), cAlias )



FUNCTION oNotExiste( oClave, cAlias )

RETURN ( !Existe( oClave:varGet(), cAlias ) )



function cNoExt( cFullFile )

   local cNameFile := AllTrim( cFullFile )
   local n         := AT( ".", cNameFile )

return AllTrim( if( n > 0, left( cNameFile, n - 1 ), cNameFile ) )



FUNCTION cNoPathInt( cFileName )

RETURN Alltrim( SubStr( cFileName, RAt( "/", cFileName ) + 1 ) )



FUNCTION cOnlyPath( cFileName )

RETURN Alltrim( SubStr( cFileName, 1, RAt( "\", cFileName ) ) )



FUNCTION cDrivePath( cFileName )

RETURN SubStr( cFileName, 1, RAt( ":", cFileName ) + 1 )



FUNCTION cFirstPath( cPath )

   local nRAt     := RAt( "\", cPath )

   if nRAT == 0
      nRAt        := RAt( "/", cPath )
   end

RETURN SubStr( cPath, 1, nRAt - 1 )



Function cLastPath( cFileName )

   local cLastPath   := cOnlyPath( cFileName )
   local n           := Rat( "\", SubStr( cLastPath, 1, Len( cLastPath ) - 1 ) ) + 1

Return ( SubStr( cLastPath, n ) )



Function cPath( cPath )

   cPath             := Rtrim( cPath )

   if Right( cPath, 1 ) <> "\"
      cPath          += "\"
   end

Return ( cPath )



FUNCTION EvalGet( aGet, nMode )

    local i
   local nLen  := len( aGet )

   for i = 1 to nLen

      if ValType( aGet[i] ) == "O"
         if "GET" $ aGet[ i ]:ClassName()
            aGet[ i ]:lValid()
         end
      end

   next

Return nil



FUNCTION bChar2Block( cChar, lLogic, lMessage, lHard )

    local bBlock
   local oBlock
   local oError
   local lError      := .F.

   IIF( lLogic == nil, lLogic := .F., ) ;
   IIF( lMessage == nil, lMessage := .T., ) ;
   IIF( lHard == nil, lHard := .F., ) ;

   if Empty( cChar )

      if lLogic
         bBlock      := {|| .T.}
      else
         bBlock      := {|| "" }
      end

      return ( bBlock )

   end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE










         if ValType( cChar ) == "C"
            cChar    := Rtrim( cChar )
            bBlock   := &( "{||" + cChar + "}" )

         elseif ValType( cChar ) == "N"
            bBlock   := {|| cChar }

         end





         Eval( bBlock )





   RECOVER USING oError

      lError         := .T.

   end

   ErrorBlock( oBlock )

   if lError

      if lMessage
         msgStop( "Expresión incorrecta " + cChar + Chr(13)+Chr(10) + ErrorMessage( oError ), "bChar2Block" + Type( cChar ) )
      end

      if lHard
         bBlock      := nil
      else
         if lLogic
            bBlock   := {|| .T.}
         else
            bBlock   := {|| "" }
         end
      end

   end

RETURN ( bBlock )






function SetMarkRec( cMark, nRec  )

   local nRecNo   := RecNo()
   local nHdl     := DbfHdl()
   local nOffSet  := 0

   nRec           := if( ValType( nRec )  <> "N", RecNo(), nRec  )
   cMark          := if( ValType( cMark ) <> "C", "#",     cMark )

   nOffSet        := ( RecSize() * ( nRec - 1 ) ) + Header()

   FSeek( nHdl, nOffSet, 0 )
   FWrite( nHdl, cMark, 1 )

   DbGoTo( nRecNo )

return( FError() == 0 )




function ChgMarked( cMark, nRec )

   if lMarked( cMark, nRec )
      SetMarkRec( Space( 1 ), nRec )
   else
      SetMarkRec( cMark, nRec )
   end

return ( nil )





function SetAllMark( cMark, cAlias )

   local nRecNo   := ( cAlias )->( RecNo() )

   cMark          := if( ValType( cMark ) <> "C", "#", cMark )

   ( cAlias )->( dbGoTop() )
   while !( cAlias )->( eof() )

      ( cAlias )->( SetMarkRec( cMark ) )
      ( cAlias )->( dbSkip() )

   end

   ( cAlias )->( DbGoTo( nRecNo ) )

return ( nil )



function SkipFor( nWantMoved, cAlias, bFor )

   local nMoved   := 0

   if nWantMoved < 0

      while nMoved > nWantMoved .AND. !( cAlias )->( bof() )
         ( cAlias )->( dbSkip( -1 ) )
         if ( cAlias )->( Eval( bFor ) )
            nMoved--
         end
      end

   else

      while nMoved < nWantMoved .AND. !( cAlias )->( eof() )
         ( cAlias )->( dbSkip() )
         if ( cAlias )->( Eval( bFor ) )
            nMoved++
         end
      end


   end

return ( nMoved )



function NotMinus( nUnits )

return ( if( nUnits < 0, 0, nUnits ) )



Function cDateTime()

Return ( Dtos( Date() ) + Left( StrTran( Time(), ":","" ), 4 ) )



Function lNegativo( nNum )

Return ( -0.1 > nNum )



Function IsArray( u )

Return ( Valtype( u ) == "A" )



Function retChr( cCadena )

   local cChr     := ""

   if Valtype( cCadena ) <> "C"
      Return ( cChr )
   end

   cCadena        := AllTrim( cCadena )

   if !Empty( cCadena )
      cCadena     += Space( 1 )
   end

   while !Empty( cCadena )
      cChr        += Chr( Val( SubStr( cCadena, 1, At( " ", cCadena ) ) ) )
      cCadena     := SubStr( cCadena, At( " ", cCadena ) + 1 )
   end

Return ( cChr )



Function DateToJuliano( dFecha )

   local dInicial

   IIF( dFecha == nil, dFecha := Date(), ) ;

   dInicial       := Ctod( "01/01/" + AllTrim( Str( Year( dFecha ) ) ) )

Return ( dFecha - dInicial + 1 )



Function JulianoToDate( nYear, nJuliana )

   local dFecIni

   IIF( nYear == nil, nYear := Year( Date() ), ) ;
   IIF( nJuliana == nil, nJuliana := 0, ) ;

   dFecIni           := Ctod( "01/01/" + Str( nYear, 4, 0 ) )

Return ( dFecIni + nJuliana - 1 )



FUNCTION addMonth( ddate, nMth )

   local nDay
   local nMonth
   local nYear
   local nLDOM

   nDay     := Day( dDate )
   nMonth   := Month( dDate )
   nYear    := Year( dDate )

   nMonth   += nmth

   if nMonth <= 0
      while nMonth <= 0
         nMonth += 12
         nYear--
      enddo
   endif

   if nMonth > 12
      while nMonth > 12
         nMonth -= 12
         nYear++
      enddo
   endif


   if nDay > ( nLDOM := lastdayom( nMonth ) )
     nDay   := nLDOM
   endif

return ( Ctod( StrZero( nDay, 2 ) + "/" + StrZero( nMonth, 2 ) + "/" + StrZero( nYear, 4 ) ) )



FUNCTION LastDayoM( xDate )

   local nMonth   := 0
   local nDays    := 0
   local lleap    := .F.

   do case
      case empty ( xDate)
         nMonth   := month( date() )

      case valtype ( xDate ) == "D"
         nMonth   := month (xdate)
         lleap    := isleap ( xdate)

      case valtype (xDate ) == "N"
         if xdate > 12
            nmonth := 0
         else
            nMonth := xDate
         endif
   endcase

   if nmonth <> 0
      ndays       := daysInmonth( nMonth, lleap )
   endif

return ndays



FUNCTION isLeap ( ddate )

   local nYear
   local nMmyr
   local nCyYr
   local nQdYr
   local lRetval

   if empty ( ddate )
     ddate  := date()
   endif

   nYear    := year (ddate)
   nCyYr    := nYear / 400
   nMmyr    := nYear /100
   nQdYr    := nYear / 4

   do case
      case int (nCyYr) == nCyYr
         lRetVal := .T.

      case int (nMmyr) == nMmyr
         lRetVal := .F.

      case int (nQdYr) == nQdYr
         lRetVal := .T.

      otherwise
         lRetVal := .F.
   endcase

return lRetVal



FUNCTION daysInmonth ( nMonth, lLeap )

   local nday := 0

   do case
   case nMonth == 2 .AND. lLeap
      nday  := 29
   case nMonth == 2 .AND. !lLeap
      nday  := 28
   case nMonth == 4 .OR. nMonth == 6 .OR. nMonth == 9 .OR. nMonth == 11
      nday  := 30
   otherwise
      nday  := 31
   endcase

return nday







Function lSelectAll( oBrw, dbf, cFieldName, lSelect, lTop, lMeter )

   local nPos
   local nRecAct        := ( dbf )->( Recno() )

   IIF( cFieldName == nil, cFieldName := "lSndDoc", ) ;
   IIF( lSelect == nil, lSelect := .T., ) ;
   IIF( lTop == nil, lTop := .T., ) ;
   IIF( lMeter == nil, lMeter := .F., ) ;

   if lMeter
      CreateWaitMeter( nil, nil, ( dbf )->( OrdKeyCount() ) )
   else
      CursorWait()
   end

   if lTop
      ( dbf )->( dbGoTop() )
   end

   while !( dbf )->( eof() )

      if dbLock( dbf )
         nPos           := ( dbf )->( FieldPos( cFieldName ) )
         ( dbf )->( FieldPut( nPos, lSelect ) )
         dbSafeUnLock( dbf )
      end

      ( dbf )->( dbSkip() )

      if lMeter
         RefreshWaitMeter( ( dbf )->( OrdKeyNo() ) )
      else
         SysRefresh()
      end

   end

   ( dbf )->( dbGoTo( nRecAct ) )

   if lMeter
      EndWaitMeter()
   else
      CursorWE()
   end

   if !Empty( oBrw )
      oBrw:Refresh()
      oBrw:SetFocus()
   end

Return nil



Function ChangeField( dbfAlias, xField, xValue, oBrowse )

   if ( dbfAlias )->( dbRLock() )
      ( dbfAlias )->( FieldPut( ( dbfAlias )->( FieldPos( xField ) ), xValue ) )
      ( dbfAlias )->( dbCommit() )
      ( dbfAlias )->( dbUnLock() )
   end

   if oBrowse <> nil
      oBrowse:Refresh()
   end

Return nil



Function Capitalize( cChar )

Return ( Upper( Left( cChar, 1 ) ) + Rtrim( Lower( SubStr( cChar, 2 ) ) ) )





_HB_CLASS TDesdeHasta ; UTILITY FUNCTION TDesdeHasta(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TDesdeHasta" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { cSerieInicio} ; IIF( !.F., s_oClass:AddMultiData(, "A", nScope + IIF( .F., 32, 0 ), { "cSerieInicio" }, .F., .F. ), )
   _HB_MEMBER { cSerieFin} ; IIF( !.F., s_oClass:AddMultiData(, "A", nScope + IIF( .F., 32, 0 ), { "cSerieFin" }, .F., .F. ), )
   _HB_MEMBER { nNumeroInicio} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nNumeroInicio" }, .F., .F. ), )
   _HB_MEMBER { nNumeroFin} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nNumeroFin" }, .F., .F. ), )
   _HB_MEMBER { cSufijoInicio} ; IIF( !.F., s_oClass:AddMultiData(, Space( 2 ), nScope + IIF( .F., 32, 0 ), { "cSufijoInicio" }, .F., .F. ), )
   _HB_MEMBER { cSufijoFin} ; IIF( !.F., s_oClass:AddMultiData(, Space( 2 ), nScope + IIF( .F., 32, 0 ), { "cSufijoFin" }, .F., .F. ), )
   _HB_MEMBER { dFechaInicio} ; IIF( !.F., s_oClass:AddMultiData(, Date(), nScope + IIF( .F., 32, 0 ), { "dFechaInicio" }, .F., .F. ), )
   _HB_MEMBER { dFechaFin} ; IIF( !.F., s_oClass:AddMultiData(, Date(), nScope + IIF( .F., 32, 0 ), { "dFechaFin" }, .F., .F. ), )
   _HB_MEMBER { nRadio} ; IIF( !.F., s_oClass:AddMultiData(, 1, nScope + IIF( .F., 32, 0 ), { "nRadio" }, .F., .F. ), )

   _HB_MEMBER Init() AS CLASS TDesdeHasta; IIF( .F., s_oClass:ModMethod( "Init", @TDesdeHasta_Init(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Init", @TDesdeHasta_Init(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER cNumeroInicio(); IIF( .F., s_oClass:ModInline( "cNumeroInicio", {|Self | Self, ::cSerieInicio + Str( ::nNumeroInicio ) + ::cSufijoInicio }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "cNumeroInicio", {|Self | Self, ::cSerieInicio + Str( ::nNumeroInicio ) + ::cSufijoInicio }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TDesdeHasta ;



UTILITY STATIC function TDesdeHasta_Init( cSerie, nNumero, cSufijo, dFecha) ; local Self AS CLASS TDesdeHasta := QSelf() AS CLASS TDesdeHasta

   IIF( cSerie == nil, cSerie := "A", ) ;
   IIF( nNumero == nil, nNumero := 0, ) ;
   IIF( cSufijo == nil, cSufijo := Space( 2 ), ) ;
   IIF( dFecha == nil, dFecha := Date(), ) ;

   ::cSerieInicio       := cSerie
   ::cSerieFin          := cSerie
   ::nNumeroInicio      := nNumero
   ::nNumeroFin         := nNumero
   ::cSufijoInicio      := cSufijo
   ::cSufijoFin         := cSufijo
   ::dFechaInicio       := dFecha
   ::dFechaFin          := dFecha

Return ( Self )



Function DecimalMod( nDividend, nDivisor )

   local nMod  := Int( nDividend / nDivisor )
   nMod        := nDividend - ( nMod * nDivisor )

Return ( nMod )



Function LTrans( Exp, cSayPicture )

Return ( Ltrim( Trans( Exp, cSayPicture ) ) )






Function cNumTiket( cCodAlb, dbfAlbCliT )

   local oBlock
   local oError
   local dbfTiket
   local cNumTiq  := ""
   local cNumDoc  := cCodAlb

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "TIKET.DBF" ), ( cCheckArea( "TIKET", @dbfTiket ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "TIKET.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
   ( dbfTiket )->( OrdSetFocus( "CNUMDOC" ) )

   if ( dbfTiket )->( dbSeek( cCodAlb ) )

      if Empty( ( dbfTiket )->cRetMat )

         cNumTiq     := ( dbfTiket )->cNumDoc

         if ( dbfAlbCliT )->( dbSeek( cNumTiq ) )
            cNumDoc  := ( dbfAlbCliT )->cSerAlb + "/" + AllTrim( Str( ( dbfAlbCliT )->nNumAlb ) ) + "/" + ( dbfAlbCliT )->cSufAlb
         end

      else

         cNumTiq     := ( dbfTiket )->cNumDoc
         cNumDoc     := ( dbfTiket )->cSerTik + "/" + AllTrim( ( dbfTiket )->cNumTik ) + "/" + ( dbfTiket )->cSufTik

      end

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   ( dbfTiket )->( dbCloseArea() )

return ( cNumDoc )



Function MsgDbfInfo( dbfAlias )

   local oDlg
   local oTreeInfo

   oDlg = TDialog():New(,,,,, "DBINFO",, .F.,,,,,, .F.,,,,,, .F., )

      oTreeInfo   := TTreeView():Redefine( 100, oDlg )

   TButton():ReDefine( ( 2 ), {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   oDlg:bStart    := {|| StartDbfInfo( dbfAlias, oTreeInfo ) }

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

Return ( nil )

Static Function StartDbfInfo( dbfAlias, oTreeInfo )

   local n := 0

   dbSelectArea( ( dbfAlias ) )

   oTreeInfo:Add( "RDDI_ISDBF       : "  + cValToChar( dbInfo( 1       ) ) )
   oTreeInfo:Add( "RDDI_CANPUTREC   : "  + cValToChar( dbInfo( 2   ) ) )
   oTreeInfo:Add( "RDDI_DELIMITER   : "  + cValToChar( dbInfo( 3   ) ) )
   oTreeInfo:Add( "RDDI_SEPARATOR   : "  + cValToChar( dbInfo( 4   ) ) )
   oTreeInfo:Add( "RDDI_TABLEEXT    : "  + cValToChar( dbInfo( 5    ) ) )
   oTreeInfo:Add( "RDDI_MEMOEXT     : "  + cValToChar( dbInfo( 6     ) ) )
   oTreeInfo:Add( "RDDI_ORDBAGEXT   : "  + cValToChar( dbInfo( 7   ) ) )
   oTreeInfo:Add( "RDDI_ORDEREXT    : "  + cValToChar( dbInfo( 8    ) ) )
   oTreeInfo:Add( "RDDI_ORDSTRUCTEXT: "  + cValToChar( dbInfo( 9) ) )
   oTreeInfo:Add( "RDDI_LOCAL       : "  + cValToChar( dbInfo( 10       ) ) )
   oTreeInfo:Add( "RDDI_REMOTE      : "  + cValToChar( dbInfo( 11      ) ) )
   oTreeInfo:Add( "RDDI_CONNECTION  : "  + cValToChar( dbInfo( 12  ) ) )
   oTreeInfo:Add( "RDDI_TABLETYPE   : "  + cValToChar( dbInfo( 13   ) ) )
   oTreeInfo:Add( "RDDI_MEMOTYPE    : "  + cValToChar( dbInfo( 14    ) ) )
   oTreeInfo:Add( "RDDI_LARGEFILE   : "  + cValToChar( dbInfo( 15   ) ) )
   oTreeInfo:Add( "RDDI_LOCKSCHEME  : "  + cValToChar( dbInfo( 16  ) ) )
   oTreeInfo:Add( "RDDI_RECORDMAP   : "  + cValToChar( dbInfo( 17   ) ) )
   oTreeInfo:Add( "RDDI_ENCRYPTION  : "  + cValToChar( dbInfo( 18  ) ) )
   oTreeInfo:Add( "RDDI_AUTOLOCK    : "  + cValToChar( dbInfo( 20    ) ) )

   oTreeInfo:Add( "Index parameters" )
   oTreeInfo:Add( "RDDI_STRUCTORD   : "  + cValToChar( dbInfo( 21   ) ) )
   oTreeInfo:Add( "RDDI_STRICTREAD  : "  + cValToChar( dbInfo( 22  ) ) )
   oTreeInfo:Add( "RDDI_STRICTSTRUCT: "  + cValToChar( dbInfo( 23) ) )
   oTreeInfo:Add( "RDDI_OPTIMIZE    : "  + cValToChar( dbInfo( 24    ) ) )
   oTreeInfo:Add( "RDDI_FORCEOPT    : "  + cValToChar( dbInfo( 25    ) ) )
   oTreeInfo:Add( "RDDI_AUTOOPEN    : "  + cValToChar( dbInfo( 26    ) ) )
   oTreeInfo:Add( "RDDI_AUTOORDER   : "  + cValToChar( dbInfo( 27   ) ) )
   oTreeInfo:Add( "RDDI_AUTOSHARE   : "  + cValToChar( dbInfo( 28   ) ) )
   oTreeInfo:Add( "RDDI_MULTITAG    : "  + cValToChar( dbInfo( 29    ) ) )
   oTreeInfo:Add( "RDDI_SORTRECNO   : "  + cValToChar( dbInfo( 30   ) ) )
   oTreeInfo:Add( "RDDI_MULTIKEY    : "  + cValToChar( dbInfo( 31    ) ) )

   oTreeInfo:Add( "Memo parameters" )
   oTreeInfo:Add( "RDDI_MEMOBLOCKSIZE: "  + cValToChar( dbInfo( 32  ) ) )
   oTreeInfo:Add( "RDDI_MEMOVERSION  : "  + cValToChar( dbInfo( 33    ) ) )
   oTreeInfo:Add( "RDDI_MEMOGCTYPE   : "  + cValToChar( dbInfo( 34     ) ) )
   oTreeInfo:Add( "RDDI_MEMOREADLOCK : "  + cValToChar( dbInfo( 35   ) ) )
   oTreeInfo:Add( "RDDI_MEMOREUSE    : "  + cValToChar( dbInfo( 36      ) ) )
   oTreeInfo:Add( "RDDI_BLOB_SUPPORT : "  + cValToChar( dbInfo( 37   ) ) )

   oTreeInfo:Add( "OrderInfo" )
   oTreeInfo:Add( "DBOI_CONDITION    : "  + cValToChar( dbOrderInfo( 1       ) ) )
   oTreeInfo:Add( "DBOI_EXPRESSION   : "  + cValToChar( dbOrderInfo( 2      ) ) )
   oTreeInfo:Add( "DBOI_POSITION     : "  + cValToChar( dbOrderInfo( 3        ) ) )

   oTreeInfo:Add( "DBOI_NAME         : "  + cValToChar( dbOrderInfo( 5            ) ) )
   oTreeInfo:Add( "DBOI_NUMBER       : "  + cValToChar( dbOrderInfo( 6          ) ) )
   oTreeInfo:Add( "DBOI_BAGNAME      : "  + cValToChar( dbOrderInfo( 7         ) ) )
   oTreeInfo:Add( "DBOI_BAGEXT       : "  + cValToChar( dbOrderInfo( 8          ) ) )
   oTreeInfo:Add( "DBOI_INDEXEXT     : "  + cValToChar( dbOrderInfo( 8        ) ) )
   oTreeInfo:Add( "DBOI_INDEXNAME    : "  + cValToChar( dbOrderInfo( 7       ) ) )
   oTreeInfo:Add( "DBOI_ORDERCOUNT   : "  + cValToChar( dbOrderInfo( 9      ) ) )
   oTreeInfo:Add( "DBOI_FILEHANDLE   : "  + cValToChar( dbOrderInfo( 10      ) ) )
   oTreeInfo:Add( "DBOI_ISCOND       : "  + cValToChar( dbOrderInfo( 11          ) ) )
   oTreeInfo:Add( "DBOI_ISDESC       : "  + cValToChar( dbOrderInfo( 12          ) ) )
   oTreeInfo:Add( "DBOI_UNIQUE       : "  + cValToChar( dbOrderInfo( 13          ) ) )
   oTreeInfo:Add( "DBOI_FULLPATH     : "  + cValToChar( dbOrderInfo( 20        ) ) )
   oTreeInfo:Add( "DBOI_KEYTYPE      : "  + cValToChar( dbOrderInfo( 24         ) ) )
   oTreeInfo:Add( "DBOI_KEYSIZE      : "  + cValToChar( dbOrderInfo( 25         ) ) )
   oTreeInfo:Add( "DBOI_KEYCOUNT     : "  + cValToChar( dbOrderInfo( 26        ) ) )
   oTreeInfo:Add( "DBOI_HPLOCKING    : "  + cValToChar( dbOrderInfo( 29       ) ) )
   oTreeInfo:Add( "DBOI_LOCKOFFSET   : "  + cValToChar( dbOrderInfo( 35      ) ) )
   oTreeInfo:Add( "DBOI_KEYVAL       : "  + cValToChar( dbOrderInfo( 38          ) ) )
   oTreeInfo:Add( "DBOI_SCOPETOP     : "  + cValToChar( dbOrderInfo( 39        ) ) )
   oTreeInfo:Add( "DBOI_SCOPEBOTTOM  : "  + cValToChar( dbOrderInfo( 40     ) ) )
   oTreeInfo:Add( "DBOI_SCOPETOPCLEAR: "  + cValToChar( dbOrderInfo( 41   ) ) )
   oTreeInfo:Add( "DBOI_SCOPEBOTTOMCLEAR:"+ cValToChar( dbOrderInfo( 42) ) )
   oTreeInfo:Add( "DBOI_CUSTOM       : "  + cValToChar( dbOrderInfo( 45          ) ) )

   oTreeInfo:Add( "DBOI_KEYSINCLUDED : "  + cValToChar( dbOrderInfo( 50    ) ) )
   oTreeInfo:Add( "DBOI_KEYGOTO      : "  + cValToChar( dbOrderInfo( 3         ) ) )
   oTreeInfo:Add( "DBOI_KEYGOTORAW   : "  + cValToChar( dbOrderInfo( 51      ) ) )
   oTreeInfo:Add( "DBOI_KEYNO        : "  + cValToChar( dbOrderInfo( 3           ) ) )
   oTreeInfo:Add( "DBOI_KEYNORAW     : "  + cValToChar( dbOrderInfo( 51        ) ) )
   oTreeInfo:Add( "DBOI_KEYCOUNTRAW  : "  + cValToChar( dbOrderInfo( 52     ) ) )

Return ( nil )









FUNCTION cNoPath( cFileName )

RETURN Alltrim( SubStr( cFileName, RAt( "\", cFileName ) + 1 ) )







FUNCTION cCheckArea( cDbfName, cAlias )

   local n     := 2

   cAlias      := cDbfName

    while Select( cAlias ) <> 0
      cAlias   := cDbfName + AllTrim( Str( n++ ) )
    end

RETURN cAlias



Function dbSeekInOrd( uVal, cOrd, cAlias, lSoft, lLast )

   local nOrd
   local lRet        := .F.

   if ( cAlias )->( Used() )
      nOrd           := ( cAlias )->( OrdSetFocus( cOrd ) )
      lRet           := ( cAlias )->( dbSeek( uVal, lSoft, lLast ) )
      ( cAlias )->( OrdSetFocus( nOrd ) )
   end

Return ( lRet )



Function aSqlStruct( aStruct )

   local a
   local aSqlStruct  := {}

   for each a in aStruct
      if a[2] == "+"

         WQout( { a[1] } )
         WQout( { "N" } )
         WQout( { a[3] } )
         WQout( { a[4] } )
         WQout( { 0x0008 } )
         WQout( { 1 } )

         aAdd( aSqlStruct, { a[1], "N", a[3], a[4], 0x0008, 1 } )
      else
         aAdd( aSqlStruct, { a[1], a[2], a[3], a[4] } )
      end
   next

Return ( aSqlStruct )



Function lExistTable( cTable, cVia )









   if lAIS()
      return .T.
   end

Return ( File( cTable ) )



Function lExistIndex( cIndex, cVia )









   if lAIS()
      return .T.
   end

Return ( File( cIndex ) )



Function fEraseTable( cTable, cVia )

   local lErase   := .T.

   lErase         := ( fErase( cTable ) == 0 )
   if !lErase
      MsgStop( "Imposible eliminar el fichero " + cTable + ". Código de error " + Str( fError() ) )
   end

Return ( lErase )



Function fRenameTable( cTableOld, cTableNew, cVia )









Return ( fRename( cTableOld, cTableNew ) )



Function dbSafeUnlock( cAlias )

   CursorWait()

   if Select( cAlias ) <> 0
      ( cAlias )->( dbUnLock() )
   end

   CursorWE()

Return nil



FUNCTION dbAppendDefault( cAliOrigen, cAliDestino, aStruct )

    local i
   local cNom
    local    xVal
   local nPos
   local lPass    := .F.
   local nField   := ( cAliDestino )->( fCount() )

   ( cAliDestino )->( dbAppend() )

   if ( cAliDestino )->( !NetErr() )

      for i := 1 to nField

         if ( len( aStruct[ i ] ) >= 9 ) .AND. ( !Empty( aStruct[ i, 9 ] ) )
            ( cAliDestino )->( FieldPut( i, aStruct[ i, 9 ] ) )
         end

      next

      for i := 1 to nField

         cNom     := ( cAliDestino )->( FieldName( i ) )
         nPos     := ( cAliOrigen  )->( FieldPos( cNom ) )

         if nPos <> 0
            xVal  := ( cAliOrigen )->( FieldGet( nPos ) )
            ( cAliDestino )->( FieldPut( i, xVal ) )
         end

      next

      dbSafeUnLock( cAliDestino )

      lPass    := .T.

   end

Return ( lPass )



Function fEraseIndex( cTable, cVia )









Return ( fErase( cTable ) )



FUNCTION bCheck2Block( cChar, lMessage )

   local cType
    local bBlock
   local oBlock
   local oError
   local lError      := .F.

   IIF( lMessage == nil, lMessage := .T., ) ;

   if Empty( cChar )
      return ( bBlock )
   end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      cType          := Type( cChar )

      if cType <> "UE"

         cChar       := Rtrim( cChar )
         bBlock      := &( "{||" + cChar + "}" )

      else

         lError      := .T.

      end

   RECOVER USING oError

      lError         := .T.

   end

   ErrorBlock( oBlock )

   if lError

      if lMessage
         msgStop( "Expresión incorrecta " + cChar, "Tipo de expresión " + Type( cChar ) )
      end

      bBlock         := nil

   end

RETURN ( bBlock )














FUNCTION WinAppRec( oBrw, bEdit, cAlias, bWhen, bValid, xOthers )

   local aTmp
   local aGet
   local lReturn     := .F.
   local nOrd        := 0

   IIF( cAlias == nil, cAlias := Alias(), ) ;
   IIF( bWhen == nil, bWhen := "", ) ;
   IIF( bValid == nil, bValid := "", ) ;

   if Select( cAlias ) == 0
      return .F.
   end

   if lDemoMode() .AND. ( cAlias )->( lastRec() ) >= 50
      msgStop( "Esta usted utilizando una versión demo.", "El programa se abortará" )
      return .F.
   end

   if Empty( ( cAlias )->( OrdSetFocus() ) )
      nOrd        := ( cAlias )->( OrdSetFocus( 1 ) )
   end

   if lAdsRDD()
      ( cAlias )->( dbClearFilter() )
   end

   aTmp           := dbBlankRec( cAlias )

   aGet           := Array( ( cAlias )->( fCount() ) )





   lReturn        := Eval( bEdit, aTmp, aGet, cAlias, oBrw, bWhen, bValid, 1, xOthers )

   if lReturn
      dbSafeUnLock( cAlias )
   end

   if IsNum( nOrd ) .AND. ( nOrd <> 0 )
      ( cAlias )->( OrdSetFocus ( nOrd ) )
   end

   if lReturn .AND. !Empty( oBrw ) .AND. ( oBrw:lActive )
      oBrw:Select( 0 )
      oBrw:Select( 1 )
      oBrw:Refresh()
   end

RETURN lReturn














FUNCTION WinDupRec( oBrw, bEdit, cAlias, bWhen, bValid, xOthers )

   local aTmp
   local aGet
   local nRec
   local lResult  := .F.
   local nOrd     := 0

   if Select( cAlias ) == 0
      Return .F.
   end

   if lDemoMode() .AND. ( cAlias )->( lastRec() ) >= 50
      msgStop( "Esta usted utilizando una versión demo.", "El programa se abortará" )
      Return .F.
   end

   nRec           := ( cAlias )->( Recno() )

   if Empty( ( cAlias )->( OrdSetFocus() ) )
      nOrd        := ( cAlias )->( OrdSetFocus( 1 ) )
   end

   if lAdsRDD()
      ( cAlias )->( dbClearFilter() )
   end





   if !( cAlias )->( eof() )

      aTmp        := dbScatter( cAlias )

      aGet        := Array( ( cAlias )->( fCount() ) )

      lResult     := Eval( bEdit, aTmp, aGet, cAlias, oBrw, bWhen, bValid, 4, xOthers )

      if lResult
         dbSafeUnLock( cAlias )
      end

   end

   if IsNum( nOrd ) .AND. nOrd <> 0
      ( cAlias )->( OrdSetFocus( nOrd ) )
   end

   if !lResult
      ( cAlias )->( dbGoTo( nRec ) )
   end

   if lResult .AND. !Empty( oBrw ) .AND. ( oBrw:lActive )
      oBrw:Select( 0 )
      oBrw:Select( 1 )
      oBrw:Refresh()
   end

RETURN lResult














FUNCTION WinEdtRec( oBrw, bEdit, cAlias, bWhen, bValid, xOthers )

   local aTmp
   local aGet
   local lResult     := .F.
   local nOrd        := 0

   IIF( cAlias == nil, cAlias := Alias(), ) ;
   IIF( bWhen == nil, bWhen := "", ) ;
   IIF( bValid == nil, bValid := "", ) ;

   if Select( cAlias ) == 0 .OR. ( ( cAlias )->( LastRec() ) == 0 )
      return .F.
   end

   if Empty( ( cAlias )->( OrdSetFocus() ) )
      nOrd           := ( cAlias )->( OrdSetFocus( 1 ) )
   end

   if !( cAlias )->( eof() )
      if dbDialogLock( cAlias )
         aTmp        := dbScatter( cAlias )
         aGet        := Array( ( cAlias )->( fCount() ) )
         lResult     := Eval( bEdit, aTmp, aGet, cAlias, oBrw, bWhen, bValid, 2, xOthers )
         dbSafeUnLock( cAlias )
      end
   end

   if ValType( nOrd ) == "N" .AND. nOrd <> 0
      ( cAlias )->( OrdSetFocus( nOrd ) )
   end

   if lResult .AND. oBrw <> nil
      oBrw:Refresh()
      oBrw:Select( 0 )
      oBrw:Select( 1 )
   end

RETURN lResult













FUNCTION WinZooRec( oBrw, bEdit, cAlias, bWhen, bValid, xOthers )

   local aTmp
   local aGet
   local lResult     := .F.
   local nOrd        := 0

   IIF( cAlias == nil, cAlias := Alias(), ) ;
   IIF( bWhen == nil, bWhen := "", ) ;
   IIF( bValid == nil, bValid := "", ) ;

    IF Select( cAlias ) == 0
        RETURN .F.
    end

   if Empty( ( cAlias )->( OrdSetFocus() ) )
      nOrd        := ( cAlias )->( OrdSetFocus( 1 ) )
   end

   IF !( cAlias )->( eof() )
      aTmp        := DBScatter( cAlias )
      aGet        := Array( (cAlias)->(fCount()) )
      lResult     := Eval( bEdit, aTmp, aGet, cAlias, oBrw, bWhen, bValid, 3, xOthers )
    end

   if ValType( nOrd ) == "N" .AND. nOrd <> 0
      ( cAlias )->( OrdSetFocus( nOrd ) )
   end

RETURN lResult






FUNCTION dbScatter( cAlias )

   local i
   local aField := {}
   local nField := ( cAlias )->( fCount() )



   for i := 1 to nField
      aAdd( aField, ( cAlias )->( FieldGet( i ) ) )
    next

RETURN aField







FUNCTION aScatter( cAlias, aTmp )

   aEval( aTmp, {|x,n| aTmp[ n ] := ( cAlias )->( FieldGet( n ) ) } )

RETURN aTmp







FUNCTION dbDialogLock( cAlias, lAppend )

   IIF( lAppend == nil, lAppend := .F., ) ;

   if DBLock( cAlias, If( lAppend, 3, 2 ) )
      return .T.
    endif

   while ApoloMsgNoYes( "Registro bloqueado," + Chr(13)+Chr(10) + "¿ Reintentar ?" )

        if DBLock( cAlias, If( lAppend, 3, 2 ) )
         return .T.
        else
            loop
        endif

   enddo

Return .F.






Function dbBlankRec( cAlias )

   local i
   local aBlank   := {}
   local aStruct  := ( cAlias )->( dbStruct() )

   for i = 1 to ( cAlias )->( fCount() )

         Do Case
         Case aStruct[ i, 2 ] == "C"
            AAdd( aBlank, Space( aStruct[ i, 3 ] ) )
         Case aStruct[ i, 2 ] == "M"
            AAdd( aBlank, "" )
         Case aStruct[ i, 2 ] == "N"
            AAdd( aBlank, Val( "0." + Replicate( "0", aStruct[ i, 4 ] ) ) )
         Case aStruct[ i, 2 ] == "L"
            AAdd( aBlank, .F. )
         Case aStruct[ i, 2 ] == "D"
            AAdd( aBlank, GetSysDate() )
      end

   next

RETURN aBlank






Function dbLock( cAlias, nMode )

   local i

   IIF( nMode == nil, nMode := 2, ) ;

    for i = 1 to 10

      if nMode == 3

         ( cAlias )->( dbAppend() )
         if !NetErr()
            return .T.
            endif

        else

         if ( cAlias )->( dbRLock() )
                return .T.
            end

        endif

    next

Return .F.







FUNCTION WinDelRec( oBrw, cAlias, bPreBlock, bPostBlock, lMaster, lTactil )

   local nRec        := 0
   local cTxt        := "¿Desea eliminar el registro en curso?"
   local nMarked     := 0
   local lReturn     := .F.
   local lTrigger    := .T.

   IIF( cAlias == nil, cAlias := Alias(), ) ;
   IIF( lMaster == nil, lMaster := .F., ) ;
   IIF( lTactil == nil, lTactil := .F., ) ;

   if Select( cAlias ) == 0 .OR. ( cAlias )->( LastRec() ) == 0
      return ( .F. )
   end





   if !Empty( oBrw ) .AND. ( "XBROWSE" $ oBrw:ClassName() )

      nMarked        := len( oBrw:aSelected )
      if nMarked > 1
         cTxt        := "¿ Desea eliminar definitivamente " + AllTrim( Trans( nMarked, "999999" ) ) + " registros ?"
      end

      if oUser():lNotConfirmDelete() .OR. ApoloMsgNoYes( cTxt, "Confirme supresión", lTactil )

         CursorWait()

         for each nRec in ( oBrw:aSelected )

            ( cAlias )->( dbGoTo( nRec ) )

            if !Empty( bPreBlock )
               lTrigger    := CheckEval( bPreBlock )
            end

            if Valtype( lTrigger ) <> "L" .OR. lTrigger

               dbDel( cAlias )

               if !Empty( bPostBlock )
                  CheckEval( bPostBlock )
               end

               oBrw:Refresh()

            end

         next

         CursorWE()

      end

   else

      if oUser():lNotConfirmDelete() .OR. ApoloMsgNoYes( cTxt, "Confirme supersión", lTactil )

         if !Empty( bPreBlock )
            lTrigger    := CheckEval( bPreBlock )
         end

         if Valtype( lTrigger ) <> "L" .OR. lTrigger

            dbDel( cAlias )

            if !Empty( bPostBlock )
               lTrigger := CheckEval( bPostBlock )
            end

            lReturn     := .T.

         end

      end

   end

   if !Empty( oBrw )
      oBrw:Select( 0 )
      oBrw:Select( 1 )
      oBrw:Refresh()
      oBrw:SetFocus()
   end

RETURN ( lReturn )







FUNCTION dbDelRec( oBrw, cAlias, bPreBlock, bPostBlock, lDelMarked, lBig )

   local nRec           := 0
   local cTxt           := "¿Desea eliminar el registro en curso?"
   local nMarked        := 0
   local lReturn        := .F.

   IIF( cAlias == nil, cAlias := Alias(), ) ;
   IIF( lDelMarked == nil, lDelMarked := .F., ) ;
   IIF( lBig == nil, lBig := .F., ) ;

   if Select( cAlias ) == 0 .OR. ( cAlias )->( LastRec() ) == 0
      return ( .F. )
   end





   if ( lDelMarked ) .AND. ( "TXBROWSE" $ oBrw:ClassName() )
      nMarked           := len( oBrw:aSelected )
      if nMarked > 1
         cTxt           := "¿ Desea eliminar definitivamente " + AllTrim( Str( nMarked, 3 ) ) + " registros ?"
      end

      if oUser():lNotConfirmDelete() .OR. ApoloMsgNoYes( cTxt, "Confirme supersión", lBig )
         for each nRec in oBrw:aSelected

            ( cAlias )->( dbGoTo( nRec ) )

            CheckEval( bPreBlock )
            dbDel( cAlias )
            CheckEval( bPostBlock )

            IIF( !( cAlias )->( eof() ), oBrw:GoUp(), )
            oBrw:Refresh()
            oBrw:SetFocus()

         next

      end

   else
      if oUser():lNotConfirmDelete() .OR. ApoloMsgNoYes( cTxt, "Confirme supersión" )

         CheckEval( bPreBlock )

         DelRecno( cAlias, oBrw )

         CheckEval( bPostBlock )

         if !Empty( oBrw )
            oBrw:Refresh()
         end

         lReturn        := .T.

      end

   end

RETURN ( lReturn )



FUNCTION DelRecno( cAlias, oBrw, lDelMarked )

   local nRec
   local nNtx

   IIF( lDelMarked == nil, lDelMarked := .F., ) ;

   if lDelMarked

      ( cAlias )->( dbGoTop() )
      while !( cAlias )->( eof() )
         if ( cAlias )->( lMarked() ) .AND.  dbLock( cAlias, .F. )
            ( cAlias )->( dbDelete() )
            dbSafeUnLock( cAlias )
         end
      end

   else

      dbDel( cAlias )

   end

   if oBrw <> nil
      oBrw:Select( 0 )
      oBrw:Select( 1 )
      oBrw:SetFocus()
   end

Return nil



Function CheckEval( bCodeBlock )

   local oBlock
   local oError
   local lCheckEval  := .T.

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      if !Empty( bCodeBlock ) .AND. Valtype( bCodeBlock ) == "B"
         lCheckEval  := Eval( bCodeBlock )
      end

   RECOVER USING oError

      lCheckEval     := .F.

   end

   ErrorBlock( oBlock )

Return ( lCheckEval )



function nGetAllMark( cMark, cAlias )

   local nNum     := 0
   local nRecNo   := ( cAlias )->( RecNo() )

   cMark          := if( ValType( cMark ) <> "C", "#", cMark )

   ( cAlias )->( dbGoTop() )
   while !( cAlias )->( eof() )

      if ( cAlias )->( lMarked( cMark ) )
         ++nNum
      end
      ( cAlias )->( dbSkip() )

   end

   ( cAlias )->( dbGoTo( nRecNo ) )

return ( nNum )



Function dbDel( cAlias )

   if dbLock( cAlias )
      ( cAlias )->( dbDelete() )
      ( cAlias )->( dbUnLock() )
   end

   ( cAlias )->( dbSkip( 0 ) )







Return nil




function lMarked( cMark, nRec )

    cMark := if( ValType( cMark ) == "C", cMark, "#" )

return( GetMarkRec( cMark, nRec ) == cMark )




function GetMarkRec( nRec )

   local nRecNo   := RecNo()
   local nHdl     := DbfHdl()
   local nOffSet  := 0
   local cMark    := " "

   nRec           := if( ValType( nRec )  <> "N", RecNo(), nRec  )
   nOffSet        := ( RecSize() * ( nRec - 1 ) ) + Header()

   FSeek( nHdl, nOffSet, 0 )
   FRead( nHdl, @cMark, 1  )

   DbGoTo( nRecNo )

return( cMark )



FUNCTION WinGather( aTmp, aGet, cAlias, oBrw, nMode, bPostAction, lEmpty )

   local lAdd     := ( nMode == 1 .OR. nMode == 4 )

    IIF( lEmpty == nil, lEmpty := .T., ) ;

    CursorWait()

   if dbDialogLock( cAlias, lAdd )
      aEval( aTmp, { | uTmp, n | ( cAlias )->( fieldPut( n, uTmp ) ) } )
      dbSafeUnLock( cAlias )
   end

   if lEmpty
      aCopy( dbBlankRec( cAlias ), aTmp )
      if !Empty( aGet )
         aEval( aGet, {| o, i | if( "GET" $ o:ClassName(), o:cText( aTmp[ i ] ), ) } )
      end
   end

   if bPostAction <> nil
        Eval( bPostAction )
   end

   if oBrw <> nil
      oBrw:Refresh()
   end

   ( cAlias )->( dbCommit() )

   CursorWe()

Return ( nil )



FUNCTION dbCopy( cAliOrigen, cAliDestino, lApp )

    local i
    local nField     := (cAliOrigen)->( Fcount() )

    IIF( lApp == nil, lApp := .F., ) ;

    IF lApp
        (cAliDestino)->( dbAppend() )
   ELSE
      (cAliDestino)->( dbRLock() )
    end

    for i = 1 to nField
        (cAliDestino)->( FieldPut( i, (cAliOrigen)->( FieldGet( i ) ) ) )
    next

   IF !lApp
      dbSafeUnLock( cAliDestino )
    end

RETURN NIL



function NotCero( nUnits )

return ( if( nUnits <> 0, nUnits, 1 ) )



function NotCaja( nUnits )

   if !lCalCaj()
      nUnits   := 1
   end

return ( if( nUnits == 0, 1, nUnits ) )



function SetStatus( cAlias, aStatus )

   ( cAlias )->( OrdSetFocus( aStatus[ 2 ] ) )
   ( cAlias )->( dbGoTo( aStatus[ 1 ] ) )

return nil



function aGetStatus( cAlias, lInit )

   local aStatus  := { ( cAlias )->( Recno() ), ( cAlias )->( OrdSetFocus() ) }

   IIF( lInit == nil, lInit := .F., ) ;

   if lInit
      ( cAlias )->( OrdSetFocus( 1 ) )
      ( cAlias )->( dbGoTop() )
   end

return ( aStatus )







FUNCTION NotValid( oGet, uAlias, lRjust, cChar, nTag, nLen )

   local nOldTag
   local cAlias
   local lReturn  := .T.
   local xClave   := oGet:VarGet()

   IIF( uAlias == nil, uAlias := Alias(), ) ;
   IIF( lRjust == nil, lRjust := .F., ) ;
    IIF( cChar == nil, cChar := "0", ) ;
    IIF( nTag == nil, nTag := 1, ) ;

   if ValType( uAlias ) == "O"
      cAlias      := uAlias:cAlias
   else
      cAlias      := uAlias
   end

   nOldTag        := ( cAlias )->( OrdSetFocus( nTag ) )





   if Empty( ( cAlias )->( OrdSetFocus() ) )
      MsgInfo( "Indice no disponible, comprobación imposible" )
      return .T.
   end

    IF ValType( xClave ) == "C" .AND. At( ".", xClave ) <> 0
        PntReplace( oGet, cChar, nLen )
    ELSEIF lRjust
        RJustObj( oGet, cChar, nLen )
    end

   xClave         := oGet:VarGet()

   if Existe( xClave, cAlias )
      msgStop( "Clave existente", "Aviso del sistema" )
      lReturn     := .F.
   end

    ( cAlias )->( OrdSetFocus( nOldTag ) )

RETURN lReturn



FUNCTION ValidKey( oGet, uAlias, lRjust, cChar, nTag, nLen )

   local nOldTag
   local cAlias
   local lReturn  := .T.
   local xClave   := oGet:VarGet()

   IIF( uAlias == nil, uAlias := Alias(), ) ;
   IIF( lRjust == nil, lRjust := .F., ) ;
    IIF( cChar == nil, cChar := "0", ) ;
    IIF( nTag == nil, nTag := 1, ) ;

   if ValType( uAlias ) == "O"
      cAlias      := uAlias:cAlias
   else
      cAlias      := uAlias
   end

   nOldTag        := ( cAlias )->( OrdSetFocus( nTag ) )





   if Empty( ( cAlias )->( OrdSetFocus() ) )
      MsgInfo( "Indice no disponible, comprobación imposible" )
      return .T.
   end

   if lRjust
        RJustObj( oGet, cChar, nLen )
   end

   xClave         := oGet:VarGet()

   if Existe( xClave, cAlias )
      msgStop( "Clave existente", "Aviso del sistema" )
      lReturn     := .F.
   end

    ( cAlias )->( OrdSetFocus( nOldTag ) )

RETURN lReturn







FUNCTION Existe( xClave, cAlias, nOrd )

   local nRec
   local lFound

    IIF( cAlias == nil, cAlias := Alias(), ) ;
   IIF( nOrd == nil, nOrd := ( cAlias )->( OrdSetFocus() ), ) ;

   nRec           := ( cAlias )->( Recno() )
   nOrd           := ( cAlias )->( OrdSetFocus( nOrd ) )

   lFound         := ( cAlias )->( dbSeek( xClave ) )

   ( cAlias )->( OrdSetFocus( nOrd ) )
   ( cAlias )->( dbGoTo( nRec ) )

RETURN ( lFound )



FUNCTION LblTitle( nMode )

   local cTitle   := ""

   do case
      case nMode  == 1
         cTitle   := "Añadiendo "
      case nMode  == 2
         cTitle   := "Modificando "
      case nMode  == 3
         cTitle   := "Visualizando "
      case nMode  == 4
         cTitle   := "Duplicando "
   end

RETURN ( cTitle )



Function dbAppe( cAlias )

   ( cAlias )->( dbAppend() )
   if !( cAlias )->( NetErr() )
      return .T.
   endif

Return .F.



Function dbfErase( cFileName )

   if Empty( cFileName )
      return .T.
   end

   if dbExists( cFileName )
      dbDrop( cFileName )
   end

   if file( cFileName + ".Dbf" )
      if fErase( cFileName + ".Dbf" ) == -1
         Return .F.
      end
   end

   if file( cFileName + ".Cdx" )
      if fErase( cFileName + ".Cdx" ) == -1
         Return .F.
      end
   end

   if file( cFileName + ".Fpt" )
      if fErase( cFileName + ".Fpt" ) == -1
         Return .F.
      end
   end













Return .T.



Function dbfRename( cFileNameOld, cFileNameNew )

   if file( cFileNameOld + ".Dbf" )
      if fRename( cFileNameOld + ".Dbf", cFileNameNew + ".Dbf" ) == -1

         Return .F.
      end
   end

   if file( cFileNameOld + ".Cdx" )
      if fRename( cFileNameOld + ".Cdx", cFileNameNew + ".Cdx" ) == -1

         Return .F.
      end
   end

   if file( cFileNameOld + ".Fpt" )
      if fRename( cFileNameOld + ".Fpt", cFileNameNew + ".Fpt" ) == -1
         MsgStop( "No se pudo renombrar el fichero " + cFileNameOld + ".Fpt" )
         Return .F.
      end
   end

Return .T.



Function dbDelKit( oBrw, dbfTmp, nNumLin )

   local nRec  := ( dbfTmp )->( Recno() )
   local nOrd  := ( dbfTmp )->( OrdSetFocus( "nNumLin" ) )

   while ( dbfTmp )->( dbSeek( Str( nNumLin, 4 ) ) )
      ( dbfTmp )->( dbDelete() )
      SysRefresh()
   end

   ( dbfTmp )->( OrdSetFocus( nOrd ) )
   ( dbfTmp )->( dbGoTo( nRec ) )

   if !Empty( oBrw )
      oBrw:Refresh()
   end

Return nil



FUNCTION cGetNewFileName( cName, cExt, lExt, cPath )

   local cTemp
   local nId      := Val( cCurUsr() )

   IIF( cExt == nil, cExt := { "Dbf", "Cdx", "Fpt" }, ) ;
   IIF( lExt == nil, lExt := .F., ) ;
   IIF( cPath == nil, cPath := "", ) ;

   cTemp          := cName + cCurUsr()

   if Valtype( cExt ) == "A"

      while File( cPath + cTemp + "." + cExt[ 1 ] ) .OR. File( cPath + cTemp + "." + cExt[ 2 ] ) .OR. File( cPath + cTemp + "." + cExt[ 3 ] )
         cTemp    := cName + StrZero( ++nId, 3 )
      end

   else

      while File( cPath + cTemp + "." + cExt )
         cTemp    := cName + StrZero( ++nId, 3 )
      end

   end

   if lExt
      cTemp       += "." + cExt
   end

RETURN cTemp



Function CommitTransaction()



      if lAds() .OR. lAIS()
         Return ( AdsCommitTransaction() )
      end



Return ( .T. )



Function BeginTransaction()



      if lAds() .OR. lAIS()
         Return ( AdsBeginTransaction() )
      end



Return ( .T. )



Function RollBackTransaction()



      if lAds() .OR. lAIS()
         Return ( AdsRollback() )
      end



Return ( .T. )



Function Div( nDividend, nDivisor )

Return( if( nDivisor <> 0, ( nDividend / nDivisor ), 0 ) )



FUNCTION cFileBitmap( cPath, cFileName )

   local cFileBitmap

   if At( ":", cFileName ) <> 0
      cFileBitmap       := Rtrim( cFileName )
   else
      cFileBitmap       := Rtrim( cPath ) + Rtrim( cFileName )
   end

RETURN ( cFileBitmap )







FUNCTION dbLast( cAlias, nField, oGet, xHasta, nOrd )

   local xValRet
   local nPosAct
   local nOrdAct

   IIF( cAlias == nil, cAlias := Alias(), ) ;
    IIF( nField == nil, nField := 1, ) ;





   if IsObject( cAlias )
      cAlias      := cAlias:cAlias
   end

   nPosAct        := ( cAlias )->( Recno() )





   if nOrd <> nil
      nOrdAct     := ( cAlias )->( OrdSetFocus( nOrd ) )
   end

   if Empty( xHasta )
      ( cAlias )->( dbGoBottom() )
   else
      ( cAlias )->( dbSeek( xHasta, .T., .T. ) )
      if ( cAlias )->( eof() )
         ( cAlias )->( dbGoBottom() )
      end
   end

   if IsChar( nField )
      nField      := ( cAlias )->( FieldPos( nField ) )
   end
   xValRet        := ( cAlias )->( FieldGet( nField ) )





   ( cAlias )->( dbGoTo( nPosAct ) )

   if !Empty( nOrd )
      ( cAlias )->( OrdSetFocus( nOrdAct ) )
   end

   if !Empty( oGet )
        oGet:cText( xValRet )
      return .T.
   end

Return ( xValRet )



Function IsNil( u )

Return ( u == nil )



FUNCTION WinMulRec( oBrw, bEdit, cAlias, bWhen, bValid, xOthers )

   local aTmp
   local aGet
   local lReturn     := .F.
   local nOrd        := 0

   IIF( cAlias == nil, cAlias := Alias(), ) ;
   IIF( bWhen == nil, bWhen := "", ) ;
   IIF( bValid == nil, bValid := "", ) ;

    IF Select( cAlias ) == 0
        RETURN .F.
    end

   if Empty( ( cAlias )->( OrdSetFocus() ) )
      nOrd        := ( cAlias )->( OrdSetFocus( 1 ) )
   end

   aTmp           := dbBlankRec( cAlias )
   aGet           := Array( ( cAlias)->( fCount() ) )





   lReturn        := Eval( bEdit, aTmp, aGet, cAlias, oBrw, bWhen, bValid, 5, xOthers )
   if lReturn
      dbSafeUnLock( cAlias )
   end

   if ValType( nOrd ) == "N" .AND. nOrd <> 0
      ( cAlias )->( OrdSetFocus( nOrd ) )
   end

RETURN ( lReturn )



Function lMayorIgual( nTotal, nCobrado, nDiferencia )

   IIF( nDiferencia == nil, nDiferencia := 0, ) ;

   nTotal               := Abs( nTotal )
   nCobrado             := Abs( nCobrado )

Return ( ( nTotal >= nCobrado ) .AND. ( ( nTotal - nCobrado ) >= nDiferencia ) )



Function lDiferencia( nTotal, nCobrado, nDiferencia )

   IIF( nDiferencia == nil, nDiferencia := 0, ) ;

Return ( Abs( nTotal - nCobrado ) >= nDiferencia )



FUNCTION dbPass( cAliOrigen, cAliDestino, lApp, xField1, xField2, xField3, xField4, xField5 )

    local i
   local cNom
    local    xVal
   local nPos
   local lPass    := .F.
   local nField   := ( cAliDestino )->( fCount() )

    IIF( lApp == nil, lApp := .F., ) ;

   if lApp

      ( cAliDestino )->( dbAppend() )

      if ( cAliDestino )->( !NetErr() )

         for i = 1 to nField

            cNom     := ( cAliDestino )->( FieldName( i ) )
            nPos     := ( cAliOrigen  )->( FieldPos( cNom ) )

            if nPos <> 0
               xVal  := ( cAliOrigen )->( FieldGet( nPos ) )
               ( cAliDestino )->( FieldPut( i, xVal ) )
            end

         next

         if !Empty( xField1 )
            ( cAliDestino )->( FieldPut( 1, xField1 ) )
         end

         if !Empty( xField2 )
            ( cAliDestino )->( FieldPut( 2, xField2 ) )
         end

         if !Empty( xField3 )
            ( cAliDestino )->( FieldPut( 3, xField3 ) )
         end

         if !Empty( xField4 )
            ( cAliDestino )->( FieldPut( 4, xField4 ) )
         end

         if !Empty( xField5 )
            ( cAliDestino )->( FieldPut( 5, xField5 ) )
         end

         ( cAliDestino )->( dbUnLock() )

         lPass       := .T.

      end

   else

      if ( cAliDestino )->( dbRLock() )

         for i = 1 to nField

            cNom     := ( cAliDestino )->( FieldName( i ) )
            nPos     := ( cAliOrigen  )->( FieldPos( cNom ) )

            if nPos <> 0
               xVal  := ( cAliOrigen )->( FieldGet( nPos ) )
               ( cAliDestino )->( FieldPut( i, xVal ) )
            end

         next

         if !Empty( xField1 )
            ( cAliDestino )->( FieldPut( 1, xField1 ) )
         end

         if !Empty( xField2 )
            ( cAliDestino )->( FieldPut( 2, xField2 ) )
         end

         if !Empty( xField3 )
            ( cAliDestino )->( FieldPut( 3, xField3 ) )
         end

         if !Empty( xField4 )
            ( cAliDestino )->( FieldPut( 4, xField4 ) )
         end

         if !Empty( xField5 )
            ( cAliDestino )->( FieldPut( 5, xField5 ) )
         end

         dbSafeUnLock( cAliDestino )

         lPass       := .T.

      end

   end

Return ( lPass )



Function IsTrue( u )

Return ( Valtype( u ) == "L" .AND. u )



Function IsFalse( u )

Return ( Valtype( u ) == "L" .AND. !u )



Function ValidEmailAddress( cMail, lMessage )

   local lValid      := .T.

   IIF( lMessage == nil, lMessage := .F., ) ;

   lValid            := Empty( cMail ) .OR. HB_RegExMatch( "[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}", cMail, .F. )

   if !lValid .AND. lMessage
      MsgStop( "La dirección de mail introducida no es correcta" )
   end

Return ( lValid )



Function IsChar( u )

Return ( Valtype( u ) == "C" )



Function IsNum( u )

Return ( Valtype( u ) == "N" )



Function IsLogic( u )

Return ( Valtype( u ) == "L" )



Function IsObject( u )

Return ( Valtype( u ) == "O" )



Function IsDate( u )

Return ( Valtype( u ) == "D" )



Function IsBlock( u )

Return ( Valtype( u ) == "B" )






Function dbGather( aField, cAlias, lAppend )

   local i

   IIF( lAppend == nil, lAppend := .F., ) ;

   if dbLock( cAlias, If( lAppend, 3, 2 ) )
      for i := 1 to Len( aField )
         ( cAlias )->( FieldPut( i, aField[ i ] ) )
      next
      dbSafeUnlock( cAlias )
   end



Return Nil



Function DisableMainWnd( oWnd )

   local oBlock

   IIF( oWnd == nil, oWnd := oWnd(), ) ;

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if !Empty( oWnd:oMenu )
      oWnd:oMenu:Disable()
   end

   if !Empty( oWnd:oTop:oTop )
      oWnd:oTop:oTop:Disable()
   end

   end

   ErrorBlock( oBlock )

Return ( nil )



Function EnableMainWnd( oWnd )

   local oBlock

   IIF( oWnd == nil, oWnd := oWnd(), ) ;

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if !Empty( oWnd:oMenu )
      oWnd:oMenu:Enable()
   end

   if !Empty( oWnd:oTop:oTop )
      oWnd:oTop:oTop:Enable()
   end

   end

   ErrorBlock( oBlock )

Return ( nil )



Function IsLock( cAlias )

   local n
   local a  := ( cAlias )->( dbRLockList() )

   for each n in a

      if ( n == ( cAlias )->( Recno() ) )
         Return .T.
      end
   end

Return .F.



Function pdaLockSemaphore( cAlias )

   local h
   local cFile := cPatLog() + Alltrim( Str( ( cAlias )->( Recno() ) ) ) + ".txt"

   if !file( cFile )
      h        := fCreate( cFile, 0 )
      if h <> -1
         fClose( h )
      end
   end

Return .T.



Function pdaUnLockSemaphore( cAlias )

   local cFile := cPatLog() + Alltrim( Str( ( cAlias )->( Recno() ) ) ) + ".txt"

   if file( cFile )
      fErase( cFile )
   end

Return .T.



Function pdaIsLockSemaphore( cAlias )

Return ( file( cPatLog() + Alltrim( Str( ( cAlias )->( Recno() ) ) ) + ".txt" ) )



Function AdsFile( cFile )

   local cAdsFile

   if Empty( aAdsDirectory )
      aAdsDirectory  := AdsDirectory()
   end

   for each cAdsFile in aAdsDirectory

      if ( cAdsFile == cFile )
         return .T.
      end

   next

Return .F.



Function ApoloBreak( oError )

Return ( if( oError:GenCode == 5, 0, Break( oError ) ) )
