#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 8 ".\Prg\Cfaccli.prg"
FUNCTION CntFacCli( lSimula, lPago, lExcCnt, lMessage, oTree, nAsiento, aSimula, dbfFacCliT, dbfFacCliL, dbfFacCliP, dbfAntCliT, dbfAlbCliT, dbfCli, dbfDiv, dbfArt, dbfFPago, dbfIva, oNewImp, oBrw, cCodEmp, cCodPro )

    local n
    local nIva
   local lIvaCEE
   local cCtaVent
   local nPos
    local dFecha
   local cConcepto
    local cPago
    local cSubCtaIva
    local cSubCtaReq
   local cSubCtaIvm
   local cSubCtaTrn
   local nImpDet
   local nImpTrn
   local nImpPnt
   local nImpIvm
   local nImpIva
   local cRuta
   local nDouDiv
   local nRouDiv
   local nDpvDiv
   local aTotAnt
   local nNetAnt
   local nIvaAnt
   local nAcuAnt     := 0
   local nTotAnt     := 0
   local aIva        := {}
   local aIvm        := {}
   local aTrn        := {}
   local nCalculo    := 0
   local nBase       := 0
    local aVentas        := {}
   local lIvaInc     := ( dbfFacCliT )->lIvaInc
   local cCodDiv     := ( dbfFacCliT )->cDivFac
   local cCtaCli     := cCliCta( ( dbfFacCliT )->cCodCli, dbfCli )
   local cCtaCliVta  := cCliCtaVta( ( dbfFacCliT )->cCodCli, dbfCli )
   local cCtaAnticipo:= cCtaAnt()
   local nFactura    := ( dbfFacCliT )->cSerie + Str( ( dbfFacCliT )->nNumFac ) + ( dbfFacCliT )->cSufFac
   local cFactura    := ( dbfFacCliT )->cSerie + Alltrim( Str( ( dbfFacCliT )->nNumFac ) )
   local pFactura    := ( dbfFacCliT )->cSerie + "/" + Alltrim( Str( ( dbfFacCliT )->nNumFac ) ) + "/" + ( dbfFacCliT )->cSufFac
   local lRecargo    := ( dbfFacCliT )->lRecargo
   local cTerNif     := ( dbfFacCliT )->cDniCli
   local cTerNom     := ( dbfFacCliT )->cNomCli
   local lErrorFound := .F.
   local cProyecto
   local cClave
   local a
   local ptaDebe
   local ptaRet
   local lReturn     := .T.
   local lOpenDiario := lOpenDiario()
   local nTotDebe    := 0
   local nTotHaber   := 0

    IIF( lSimula == nil, lSimula := .T., ) ;
   IIF( nAsiento == nil, nAsiento := 0, ) ;
   IIF( aSimula == nil, aSimula := {}, ) ;
   IIF( cCodEmp == nil, cCodEmp := cCodEmpCnt( ( dbfFacCliT )->cSerie ), ) ;
   IIF( cCodPro == nil, cCodPro := ( dbfFacCliT )->cCodPro, ) ;

   nDouDiv           := nDouDiv( ( dbfFacCliT )->cDivFac, dbfDiv )
   nRouDiv           := nRouDiv( ( dbfFacCliT )->cDivFac, dbfDiv )
   nDpvDiv           := nDpvDiv( ( dbfFacCliT )->cDivFac, dbfDiv )

   dFecha            := ( dbfFacCliT )->dFecFac
   a                 := aTotFacCli( ( dbfFacCliT )->cSerie + Str( ( dbfFacCliT )->nNumFac ) + ( dbfFacCliT )->cSufFac, dbfFacCliT, dbfFacCliL, dbfIva, dbfDiv, dbfFacCliP, dbfAntCliT, nil, nil, .F., lExcCnt  )
   ptaDebe           := a[ 4 ]
   ptaRet            := a[ 12 ]

   cProyecto         := Left( cCodPro, 3 )
   cClave            := Right( cCodPro, 6 )












   cRuta             := cRutCnt()
   lIvaCEE           := ( ( dbfFacCliT )->nRegIva == 2 )

   if Empty( cCodEmp )
      oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " no se definierón empresas asociadas.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkRuta( cRutCnt() )
      oTree:Select( oTree:Add(  "Factura cliente : " + rtrim( pFactura ) + " ruta no valida.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkFecha( cRuta, cCodEmp, ( dbfFacCliT )->dFecFac, .F., oTree, "Factura cliente : " + Rtrim( pFactura ) )

      lErrorFound    := .T.
   end






   if Empty( cCtaCli )
      cCtaCli        := cCtaSin()
   end

   if Empty( cCtaCliVta )
      cCtaCliVta     := cCtaCli()
   end






   if ( dbfFacCliL )->( dbSeek( nFactura ) )

      while ( ( dbfFacCliL )->cSerie + Str( ( dbfFacCliL )->nNumFac ) + ( dbfFacCliL )->cSufFac == nFactura .AND. !( dbfFacCliL )->( eof() ) )



         if !( dbfFacCliL )->lTotLin                           .AND.  lValLine( dbfFacCliL )                             .AND.  nTotLFacCli( dbfFacCliL, nDouDiv, nRouDiv, nil, .T., .T., .T. ) <> 0



            if ( lExcCnt == nil                                .OR. ( lExcCnt .AND. ( dbfFacCliL )->nCtlStk <> 2 )  .OR. ( !lExcCnt .AND. ( dbfFacCliL )->nCtlStk == 2 ) )

               nIva           := ( dbfFacCliL )->nIva
               nImpDet        := nTotLFacCli( dbfFacCliL, nDouDiv, nRouDiv, nil, .T., .F., .F. )
               nImpTrn        := nTrnLFacCli( dbfFacCliL, nDouDiv, nRouDiv )
               nImpPnt        := nPntLFacCli( dbfFacCliL, nDpvDiv )
               nImpIva        := nIvaLFacCli( dbfFacCliT, dbfFacCliL, nDouDiv, nRouDiv )
               nImpIvm        := nTotIFacCli( dbfFacCliL, nDouDiv, nRouDiv )
               cCtaVent       := RetCtaVta( ( dbfFacCliL )->cRef, dbfArt )

               if Empty( cCtaVent )
                  cCtaVent    := cCtaCliVta + RetGrpVta( ( dbfFacCliL )->cRef, cRuta, cCodEmp, dbfArt, nIva )
               end





               nPos           := aScan( aVentas, {|x| x[ 1 ] == cCtaVent .AND. x[ 2 ] == nIva } )
               if nPos  == 0
                  aAdd( aVentas, { cCtaVent, nIva, nImpDet, nImpPnt, nImpTrn, nImpIva } )
               else
                  aVentas[ nPos, 3 ]   += nImpDet
                  aVentas[ nPos, 4 ]   += nImpPnt
                  aVentas[ nPos, 5 ]   += nImpTrn
                  aVentas[ nPos, 6 ]   += nImpIva
               end





               if lIvaCEE
                  cSubCtaIva  := uFieldEmpresa( "cCtaCeeRpt" )
                  cSubCtaReq  := uFieldEmpresa( "cCtaCeeSpt" )
               else
                  cSubCtaIva  := cSubCuentaIva( nIva, ( dbfFacCliT )->lRecargo, cRuta, cCodEmp, dbfIva )
                  cSubCtaReq  := cSubCuentaRecargo( nIva, ( dbfFacCliT )->lRecargo, cRuta, cCodEmp, dbfIva )
               end

               if uFieldEmpresa( "lIvaImpEsp" )
                  nImpDet     += nImpIvm
               end

               nPos           := aScan( aIva, {|x| x[ 1 ] == nIva } )
               if nPos  == 0
                  aAdd( aIva, { nIva, cSubCtaIva, cSubCtaReq, nImpDet, nImpPnt, nImpTrn, 0 } )
               else
                  aIva[ nPos, 4 ] += nImpDet
                  aIva[ nPos, 5 ] += nImpPnt
                  aIva[ nPos, 6 ] += nImpTrn
               end





               if nImpTrn <> 0

                  cSubCtaTrn  := RetCtaTrn( ( dbfFacCliL )->cRef, dbfArt )

                  nPos        := aScan( aTrn, {|x| x[1] == cSubCtaTrn } )
                  if nPos == 0
                     aAdd( aTrn, { cSubCtaTrn, nImpTrn } )
                  else
                     aTrn[ nPos, 2 ] += nImpTrn
                  end

               end





               nImpIvm        := nTotIFacCli( dbfFacCliL, nDouDiv, nRouDiv )

               if nImpIvm <> 0

                  cSubCtaIvm  := oNewImp:cCtaImp( ( dbfFacCliL )->nValImp )

                  if !Empty( cSubCtaIvm )

                     nPos     := aScan( aIvm, {|x| x[1] == cSubCtaIvm } )
                     if nPos == 0
                        aAdd( aIvm, { cSubCtaIvm, nImpIvm } )
                     else
                        aIvm[ nPos, 2 ] += nImpIvm
                     end

                  end

               end

            end

         end

         SysRefresh()

         ( dbfFacCliL )->( dbSkip() )

      end

   else

      oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " factura sin artículos.", 0 ) )

      lErrorFound := .T.

   end






   for n := 1 to Len( aVentas )

      if ( dbfFacCliT )->nDtoEsp <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfFacCliT )->nDtoEsp / 100, nRouDiv )
      end

      if ( dbfFacCliT )->nDpp <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfFacCliT )->nDpp / 100, nRouDiv )
      end

      if ( dbfFacCliT )->nDtoUno <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfFacCliT )->nDtoUno / 100, nRouDiv )
      end

      if ( dbfFacCliT )->nDtoDos <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfFacCliT )->nDtoDos / 100, nRouDiv )
      end

      if ( dbfFacCliT )->nPctDto <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfFacCliT )->nPctDto / 100, nRouDiv )
      end

   next





   for n := 1 to Len( aVentas )
      aVentas[ n, 3 ]   += aVentas[ n, 4 ]
   next






   for n := 1 to Len( aIva )

      if ( dbfFacCliT )->nDtoEsp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfFacCliT )->nDtoEsp / 100, nRouDiv )
      end

      if ( dbfFacCliT )->nDpp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfFacCliT )->nDpp / 100, nRouDiv )
      end

      if ( dbfFacCliT )->nDtoUno <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfFacCliT )->nDtoUno / 100, nRouDiv )
      end

      if ( dbfFacCliT )->nDtoDos <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfFacCliT )->nDtoDos / 100, nRouDiv )
      end

      if ( dbfFacCliT )->nPctDto <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfFacCliT )->nPctDto / 100, nRouDiv )
      end

   next





   for n := 1 to Len( aIva )
      aIva[ n, 4 ]   += aIva[ n, 5 ]
   next





   n                 := ( dbfAntCliT )->( OrdSetFocus( "cNumDoc" ) )

   if ( dbfAntCliT )->( dbSeek( nFactura ) )

      while ( ( dbfAntCliT )->cNumDoc == nFactura .AND. !( dbfAntCliT )->( eof() ) )

         aTotAnt     := aTotAntCli( dbfAntCliT, dbfIva, dbfDiv )
         nNetAnt     := aTotAnt[ 1 ]
         nIvaAnt     := aTotAnt[ 2 ]
         nTotAnt     := aTotAnt[ 5 ]
         nAcuAnt     += nNetAnt



         if ( dbfAntCliT )->nPctIva <> 0

            cSubCtaReq  := cSubCuentaRecargo( ( dbfAntCliT )->nPctIva, ( dbfAntCliT )->lRecargo, cRuta, cCodEmp, dbfIva )
            cSubCtaIva  := cSubCuentaIva( ( dbfAntCliT )->nPctIva, ( dbfAntCliT )->lRecargo, cRuta, cCodEmp, dbfIva )

            if lIvaInc

               nPos     := aScan( aIva, {|x| x[ 1 ] == ( dbfAntCliT )->nPctIva } )
               if nPos  == 0
                  aAdd( aIva, { ( dbfAntCliT )->nPctIva, cSubCtaIva, cSubCtaReq, 0, 0, 0, - nTotAnt } )
               else
                  aIva[ nPos, 7 ] -= nTotAnt
               end

            else

               nPos     := aScan( aIva, {|x| x[ 1 ] == ( dbfAntCliT )->nPctIva } )
               if nPos  == 0
                  aAdd( aIva, { ( dbfAntCliT )->nPctIva, cSubCtaIva, cSubCtaReq, 0, 0, 0, - nNetAnt } )
               else
                  aIva[ nPos, 7 ] -= nNetAnt
               end

            end

         end

         ( dbfAntCliT )->( dbSkip() )

      end

   end

   ( dbfAntCliT )->( OrdSetFocus( n ) )






   if ( dbfFacCliT )->lContab
      oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " contabilizada.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkSubCta( cRuta, cCodEmp, cCtaCli, , .F., .F. )
      oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " subcuenta " + cCtaCli + " no encontada.", 0 ) )
      lErrorFound    := .T.
   end

   if ptaRet <> 0
      if !ChkSubCta( cRuta, cCodEmp, cCtaRet(), , .F., .F. )
         oTree:Select( oTree:Add( "Factura cliente : " + Rtrim( cFactura ) + " subcuenta " + cCtaRet() + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   end






   for n := 1 to len( aIva )

      if !ChkSubCta( cRutCnt(), cCodEmp, aIva[ n, 2 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura cliente : " + Rtrim( pFactura ) + " subcuenta " + aIva[ n, 2 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end

      if lRecargo .AND. !ChkSubCta( cRutCnt(), cCodEmp, aIva[ n, 3 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura cliente : " + Rtrim( pFactura ) + " subcuenta " + aIva[ n, 3 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end

   next

   for n := 1 to len( aVentas )
      if !ChkSubCta( cRuta, cCodEmp, aVentas[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " subcuenta " + aVentas[ n, 1 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   next

   for n := 1 to len( aIvm )
      if !lSimula .AND. !ChkSubCta( cRuta, cCodEmp, aIvm[ n, 1 ], , .F., .F. )
         oTree:Add( "Factura cliente : " + rtrim( nFactura ) + " subcuenta " + aIvm[ n, 1 ] + " no encontada.", 0 )
         lErrorFound := .T.
      end
   next






   for n := 1 to len( aTrn )
      if !ChkSubCta( cRuta, cCodEmp, aTrn[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " subcuenta " + aTrn[ n, 1 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   next





   if nTotAnt <> 0 .AND. !ChkSubCta( cRuta, cCodEmp, cCtaAnticipo, , .F., .F. )
      oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " subcuenta de anticipo " + cCtaAnticipo + " no encontada.", 0 ) )
      lErrorFound := .T.
   end








   if ( "TEFESA" $ cParamsMain()  )       .AND. ( ( dbfFacCliT )->cSerie == "B" )   .AND. dbSeekInOrd( ( dbfFacCliT )->cSerie + Str( ( dbfFacCliT )->nNumFac ) + ( dbfFacCliT )->cSufFac, "cNumFac", dbfAlbCliT )
      cConcepto   := "N/Alb. N." + ( dbfAlbCliT )->cSerAlb + "/" + AllTrim( Str( ( dbfAlbCliT )->nNumAlb ) + "/" + ( dbfAlbCliT )->cSufAlb )
   else
      cConcepto   := "N/Fcta. N." + ( dbfFacCliT )->CSERIE + "/" + AllTrim( Str( (dbfFacCliT)->NNUMFAC ) + "/" + (dbfFacCliT)->CSUFFAC )
   end

   cPago          := "C/Fcta. N." + ( dbfFacCliT )->CSERIE + "/" + AllTrim( Str( (dbfFacCliT)->NNUMFAC ) + "/" + (dbfFacCliT)->CSUFFAC )















   nTotDebe          += Round( ptaDebe, nRouDiv )


   for n := 1 to len( aVentas )

      if lIvaInc

         nCalculo    := Round( aVentas[ n, 3 ], nRouDiv )

         if aVentas[ n, 2 ] <> 0
            nCalculo -= Round( aVentas[ n, 3 ] / ( 100 / aVentas[ n, 2 ] + 1 ), nRouDiv )
         end

      else

         nCalculo    := Round( aVentas[ n, 3 ], nRouDiv )

      end

      nTotHaber      += nCalculo

   next

   nTotDebe          += ptaRet
   nTotDebe          += nAcuAnt

   for n := 1 to Len( aIvm )
      nTotHaber      += Round( aIvm[ n, 2 ], nRouDiv )
   next

   for n := 1 to Len( aTrn )
      nTotHaber      += Round( aTrn[ n, 2 ], nRouDiv )
   next

   for n := 1 to len( aIva )

      if lIvaInc

         if aIva[ n, 1 ] <> 0
            nCalculo := Round( aIva[ n, 4 ] / ( 100 / aIva[ n, 1 ] + 1 ), nRouDiv )
            nCalculo += Round( aIva[ n, 7 ] / ( 100 / aIva[ n, 1 ] + 1 ), nRouDiv )
         else
            nCalculo := 0
         end

      else

         nCalculo    := Round( aIva[ n, 4 ] * aIva[ n, 1 ] / 100, nRouDiv )
         nCalculo    += Round( aIva[ n, 7 ] * aIva[ n, 1 ] / 100, nRouDiv )

      end

      nTotHaber      += nCalculo

   next

   if lRecargo

      for n := 1 to len( aIva )
         nTotHaber   += Round( nPReq( dbfIva, aIva[ n, 1 ] ) * aIva[ n, 4 ] / 100, nRouDiv )
      next

   end

   nTotDebe          := Round( nTotDebe, nRouDiv )
   nTotHaber         := Round( nTotHaber, nRouDiv )













   if lSimula .OR. !lErrorFound

      if lOpenDiario .OR. OpenDiario( , cCodEmp )
         nAsiento    := RetLastAsi()
      else
         oTree:Select( oTree:Add( "Factura cliente : " + Rtrim( pFactura ) + " imposible abrir ficheros de contaplus.", 0 ) )
         Return .F.
      end

























      aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha, cCtaCli, , Round( ptaDebe, nRouDiv ), cConcepto, , cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )






      for n := 1 to Len( aVentas )

         if lIvaInc

         nCalculo    := Round( aVentas[ n, 3 ], nRouDiv )

         if aVentas[ n, 2 ] <> 0
            nCalculo -= Round( aVentas[ n, 3 ] / ( 100 / aVentas[ n, 2 ] + 1 ), nRouDiv )
         end





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aVentas[ n, 1 ], , , cConcepto, nCalculo, cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

         else





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aVentas[ n, 1 ], , , cConcepto, Round( aVentas[ n, 3 ], nRouDiv ), cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

         end

      next





      if ptaRet <> 0





















         aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaRet(), , ptaRet, cConcepto, , cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      end







      if nTotAnt <> 0





















      aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaAnticipo, , nAcuAnt, cConcepto, , cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      end






      for n := 1 to Len( aIvm )



















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIvm[ n, 1 ], , , cConcepto, Round( aIvm[ n, 2 ], nRouDiv ), cFactura, , , , , cProyecto, cClave, , , , lSimula ) )

      next






      for n := 1 to Len( aTrn )





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aTrn[ n, 1 ], , , cConcepto, Round( aTrn[ n, 2 ], nRouDiv ), cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next






      for n := 1 to len( aIva )

         nBase          := Round( aIva[ n, 4 ], nRouDiv ) + Round( aIva[ n, 7 ], nRouDiv )

         if lIvaInc

            if aIva[ n, 1 ] <> 0
               nCalculo := Round( aIva[ n, 4 ] / ( 100 / aIva[ n, 1 ] + 1 ), nRouDiv )
               nCalculo += Round( aIva[ n, 7 ] / ( 100 / aIva[ n, 1 ] + 1 ), nRouDiv )
            else
               nCalculo := 0
            end

            if aIva[ n, 1 ] <> 0 .OR. uFieldEmpresa( "lConIva" )





















               aAdd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIva[ n, 2 ], if( lIvaCEE, aIva[ n, 3 ], cCtaCli ), , cConcepto, nCalculo, cFactura, nBase - nCalculo, Round( aIva[ n, 1 ], nRouDiv ), If( lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), ), , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

            end

         else

            nCalculo    := Round( aIva[ n, 4 ] * aIva[ n, 1 ] / 100, nRouDiv )
            nCalculo    += Round( aIva[ n, 7 ] * aIva[ n, 1 ] / 100, nRouDiv )

            if aIva[ n, 1 ] <> 0 .OR. uFieldEmpresa( "lConIva" )





















               aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIva[ n, 2 ], if( lIvaCEE, aIva[ n, 3 ], cCtaCli ), , cConcepto, nCalculo, cFactura, nBase, Round( aIva[ n, 1 ], nRouDiv ), If( lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), ), , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

            end

         end

      next






      if lRecargo

         for n := 1 to len( aIva )

            if Round( nPReq( dbfIva, aIva[ n, 1 ] ) * ( aIva[ n, 4 ] ) / 100, nRouDiv ) <> 0





















               aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, aIva[ n, 3 ], , , cConcepto, Round( nPReq( dbfIva, aIva[ n, 1 ] ) * ( aIva[ n, 4 ] ) / 100, nRouDiv ), cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )
            end

         next

      end

   end






   if lPago .AND. !lErrorFound .AND. ( dbfFacCliP )->( dbSeek( nFactura ) )

      while ( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac == nFactura ) .AND. !( dbfFacCliP )->( eof() )

         ContabilizaReciboCliente( oBrw, oTree, lSimula, aSimula, dbfFacCliT, dbfFacCliP, dbfDiv, .T., nAsiento )

         ( dbfFacCliP )->( dbSkip() )

      end

   end






   if lSimula

      if lMessage
         lReturn  := msgTblCon( aSimula, cCodDiv, dbfDiv, !lErrorFound, pFactura, {|| aWriteAsiento( aSimula, cCodDiv, lMessage, oTree, pFactura, nAsiento ), lCntFacCli( nFactura, pFactura, nAsiento, lPago, oTree, dbfFacCliT, dbfFacCliP ) } )
      end

   else

      if !lErrorFound
         lReturn  := lCntFacCli( nFactura, pFactura, nAsiento, lPago, oTree, dbfFacCliT )
      end

   end





   if !lOpenDiario
      CloseDiario()
   end

   if !Empty( oBrw )
      oBrw:Refresh()
   end

RETURN ( lReturn )



Static Function lCntFacCli( nFactura, pFactura, nAsiento, lPago, oTree, dbfFacCliT, dbfFacCliP )






   if ( dbfFacCliT )->( dbRLock() )
      ( dbfFacCliT )->lContab := .T.
      ( dbfFacCliT )->( dbUnLock() )
   end

   oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " asiento generado num. " + Alltrim( Str( nAsiento ) ), 1 ) )

   if !Empty( dbfFacCliP )

      if lPago .AND. ( dbfFacCliP )->( dbSeek( nFactura ) )

         while ( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac == nFactura ) .AND. !( dbfFacCliP )->( eof() )

            lContabilizaReciboCliente( nil, nil, .T., oTree, dbfFacCliP )

            ( dbfFacCliP )->( dbSkip() )

         end

      end

   end

Return ( .T. )



Function DlgCntTicket( dbfTikT, dbfTikL, dbfTikP, dbfClient, dbfArt, dbfFPago, dbfDiv, oBrw )

   local oRad
   local nRad        := 1
    local oDlg
   local oChk1
   local oChk2
   local lChk1       := .T.
   local lChk2       := .T.
    local oSelTik
   local nSelTik     := 1
   local nOrdAnt     := ( dbfTikT )->( OrdSetFocus( 1 ) )
   local nRecAnt     := ( dbfTikT )->( RecNo() )
   local oSerIni
   local cSerIni     := ( dbfTikT )->cSerTik
   local oDocIni
   local nDocIni     := Val( ( dbfTikT )->cNumTik )
   local oSufIni
   local cSufIni     := ( dbfTikT )->cSufTik
   local oSerFin
   local cSerFin     := ( dbfTikT )->cSerTik
   local oDocFin
   local nDocFin     := Val( ( dbfTikT )->cNumTik )
   local cSufFin     := ( dbfTikT )->cSufTik
   local oSufFin
   local dFecIni     := ( dbfTikT )->dFecTik
   local dFecFin     := ( dbfTikT )->dFecTik
   local lSimula     := .T.
   local lCobros     := .T.
   local oMtrInf
   local nMtrInf
   local lFechas     := .T.
   local dDesde      := CtoD( "01/01/" + Str( Year( Date() ) ) )
   local dHasta      := Date()
   local oTree
   local oImageList
   local oBtnCancel

   oImageList        := TImageList():New( 16, 16 )
   oImageList:AddMasked( TBitmap():Define( "bRed" ), ( 255 + ( 0 * 256 ) + ( 255 * 65536 ) ) )
   oImageList:AddMasked( TBitmap():Define( "bGreen" ), ( 255 + ( 0 * 256 ) + ( 255 * 65536 ) ) )

   oDlg = TDialog():New(,,,,, "SelectRango",, .F.,,,,,, .F.,,,,,, .F., )



   oRad := TRadMenu():Redefine( { | u | If( PCount()==0, nRad, nRad:= u ) }, oDlg,, { 80, 81 },,,,, .F.,, )










   oSerIni := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, cSerIni, cSerIni:= u ) }, oDlg,, "@!", {||    ( cSerIni >= "A" .AND. cSerIni <= "Z" )},,,,,, .T., {||     ( oRad:nOption == 2 )},, .F., .T., {||    ( UpSerie( oSerIni ) )}, {||  ( DwSerie( oSerIni ) )},,,, nil,,, )






   TBtnBmp():ReDefine( 101, "Up16",,,,, {|Self|( oDocIni:cText( Val( dbFirst( dbfTikT, "cNumTik", , cSerIni, "cNumTik" ) ) ) )}, oDlg, .F.,, .F.,,,,,, !.T.,, .F.,,, .F., !.F. )










   oSerFin := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, cSerFin, cSerFin:= u ) }, oDlg,, "@!", {||    ( cSerFin >= "A" .AND. cSerFin <= "Z" )},,,,,, .T., {||     ( oRad:nOption == 2 )},, .F., .T., {||    ( UpSerie( oSerFin ) )}, {||  ( DwSerie( oSerFin ) )},,,, nil,,, )






   TBtnBmp():ReDefine( 111, "Down16",,,,, {|Self|( oDocFin:cText( Val( dbLast( dbfTikT, "cNumTik", , cSerIni, "cNumTik" ) ) ) )}, oDlg, .F.,, .F.,,,,,, !.T.,, .F.,,, .F., !.F. )






   oDocIni := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, nDocIni, nDocIni:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( nRad == 2 )},, .F., .T.,,,,,, nil,,, )






   oDocFin := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, nDocFin, nDocFin:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( nRad == 2 )},, .F., .T.,,,,,, nil,,, )





   oSufIni := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, cSufIni, cSufIni:= u ) }, oDlg,, "##",,,,,,, .F., {||     ( nRad == 2 )},, .F., .F.,,,,,, nil,,, )





   oSufFin := TGetHlp():ReDefine( 150, { | u | If( PCount()==0, cSufFin, cSufFin:= u ) }, oDlg,, "##",,,,,,, .F., {||     ( nRad == 2 )},, .F., .F.,,,,,, nil,,, )



   oChk1 := TCheckBox():ReDefine( 160, { | u | If( PCount()==0, lChk1, lChk1:= u ) }, oDlg,,,,,,, .F.,, .F. )



   oChk2 := TCheckBox():ReDefine( 180, { | u | If( PCount()==0, lChk2, lChk2:= u ) }, oDlg,,,,,,, .F.,, .F. )







   TCheckBox():ReDefine( 300, { | u | If( PCount()==0, lFechas, lFechas:= u ) }, oDlg,,,,,,, .F.,, .F. )





   TGetHlp():ReDefine( 310, { | u | If( PCount()==0, dDesde, dDesde:= u ) }, oDlg,,,,,,,,, .F., {||     ( !lFechas )},, .F., .T.,,,,,, nil,,, )





    TGetHlp():ReDefine( 320, { | u | If( PCount()==0, dHasta, dHasta:= u ) }, oDlg,,,,,,,,, .F., {||     ( !lFechas )},, .F., .T.,,,,,, nil,,, )

   oTree             := TTreeView():Redefine( 170, oDlg )
   oTree:bLDblClick  := {|| TreeChanged( oTree ) }






   oMtrInf := TMeter():ReDefine( 200, { | u | If( PCount()==0, nMtrInf, nMtrInf:= u ) }, ( dbfTikT )->( LastRec() ), oDlg, .F.,, "Proceso", .F.,,,, )




   TButton():ReDefine( 1, {||( ContaSerieTiket( nRad, cSerIni + Str( nDocIni, 10 ) + cSufIni, cSerFin + Str( nDocFin, 10 ) + cSufFin, lFechas, dDesde, dHasta, lChk1, lChk2, oBrw, oMtrInf, oTree, oDlg, oBtnCancel, dbfTikT, dbfTikL, dbfTikP, dbfClient, dbfArt, dbfFPago, dbfDiv ) )}, oDlg,,, .F.,,,, .F. )





   oBtnCancel := TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   oDlg:AddFastKey( 116, {|| ContaSerieTiket( nRad, cSerIni + Str( nDocIni, 10 ) + cSufIni, cSerFin + Str( nDocFin, 10 ) + cSufFin, lFechas, dDesde, dHasta, lChk1, lChk2, oBrw, oMtrInf, oTree, oDlg, oBtnCancel, dbfTikT, dbfTikL, dbfTikP, dbfClient, dbfArt, dbfFPago, dbfDiv ) } )

   oDlg:bStart := {|| StartGetSelRec( oBrw, oRad, oChk1, oChk2, oSerIni, oSerFin, oDocIni, oDocFin, oSufIni, oSufFin ) }


   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( oTree:SetImageList( oImageList ) )}, oDlg:bRClicked,,, )

    ( dbfTikT )->( OrdSetFocus( nOrdAnt ) )
    ( dbfTikT )->( dbGoTo( nRecAnt ) )

   oImageList:End()

   oTree:Destroy()

   oBrw:Refresh()

RETURN ( oDlg:nResult == 1 )



Static Function StartGetSelRec( oBrw, oRad, oChk1, oChk2, oSerIni, oSerFin, oDocIni, oDocFin, oSufIni, oSufFin )

   if !Empty( oBrw ) .AND. ( len( oBrw:oBrw:aSelected ) > 1 )
      oRad:SetOption( 1 )
   else
      oRad:SetOption( 2 )
      oSerIni:Enable()
      oSerFin:Enable()
      oDocIni:Enable()
      oDocFin:Enable()
      oSufIni:Enable()
      oSufFin:Enable()
   end

   oChk1:SetText( "Simular resultados" )

   oChk2:SetText( "Contabilizar cobors" )

Return ( nil )



Static Function TreeChanged( oTree )

   local oItemTree   := oTree:GetItem()

   if !Empty( oItemTree ) .AND. !Empty( oItemTree:bAction )
      Eval( oItemTree:bAction )
   end

Return nil



Static Function ContaSerieTiket( nRad, cNumIni, cNumFin, lFechas, dDesde, dHasta, lSimula, lCobro, oBrw, oMtrInf, oTree, oDlg, oBtnCancel, dbfTikT, dbfTikL, dbfTikP, dbfClient, dbfArt, dbfFPago, dbfDiv )

   local n        := 0
   local aPos
   local nPos
   local lRet
   local nRecAnt  := ( dbfTikT )->( RecNo() )
   local nOrdAnt  := ( dbfTikT )->( OrdSetFocus( "cNumTik" ) )
   local lWhile   := .T.





   if lSimula
      aPos        := { 0, 0 }
      ClientToScreen( oDlg:hWnd, aPos )
      oDlg:Move( aPos[ 1 ] - 22, aPos[ 2 ] - 510 )
   end





   oDlg:Disable()

   oTree:Enable()
   oTree:DeleteAll()

   oBtnCancel:bAction   := {|| lWhile := .F. }
   oBtnCancel:Enable()

   if nRad == 1

      oMtrInf:SetTotal( len( oBrw:oBrw:aSelected ) )

      for each nPos in ( oBrw:oBrw:aSelected )

         ( dbfTikT )->( dbGoTo( nPos ) )

         if lFechas .OR.( ( dbfTikT )->dFecTik >= dDesde .AND. ( dbfTikT )->dFecTik <= dHasta )

            do case
               case ( dbfTikT )->cTipTik == "1"
                  lRet  := CntTiket( lSimula, lCobro, .F., .T., oTree, 0, , dbfTikT, dbfTikL, dbfTikP, dbfClient, dbfArt, dbfFPago, dbfDiv )
               case ( dbfTikT )->cTipTik == "4"
                  lRet  := CntTiket( lSimula, lCobro, .T., .T., oTree, 0, , dbfTikT, dbfTikL, dbfTikP, dbfClient, dbfArt, dbfFPago, dbfDiv )
            end

         end

         if IsFalse( lRet )
            exit
         end

         oMtrInf:Set( ++n )

         SysRefresh()

         if !lWhile
            exit
         end

      next

      oMtrInf:Set( len( oBrw:oBrw:aSelected ) )

   else

      if ( dbfTikT )->( dbSeek( cNumIni, .T. ) )

         oMtrInf:Set( ( dbfTikT )->( OrdKeyNo() ) )





         while ( lWhile )                                .AND. !Empty( ( dbfTikT )->( OrdKeyVal() ) )    .AND. ( dbfTikT )->( OrdKeyVal() ) >= cNumIni   .AND. ( dbfTikT )->( OrdKeyVal() ) <= cNumFin   .AND. ( dbfTikT )->( !eof() )

            if lFechas .OR.( ( dbfTikT )->dFecTik >= dDesde .AND. ( dbfTikT )->dFecTik <= dHasta )

               do case
                  case ( dbfTikT )->cTipTik == "1"
                     lRet  := CntTiket( lSimula, lCobro, .F., .T., oTree, 0, , dbfTikT, dbfTikL, dbfTikP, dbfClient, dbfArt, dbfFPago, dbfDiv )
                  case ( dbfTikT )->cTipTik == "4"
                     lRet  := CntTiket( lSimula, lCobro, .T., .T., oTree, 0, , dbfTikT, dbfTikL, dbfTikP, dbfClient, dbfArt, dbfFPago, dbfDiv )
               end

               if IsFalse( lRet )
                  exit
               end

            end

            ( dbfTikT )->( dbSkip() )

            oMtrInf:Set( ( dbfTikT )->( OrdKeyNo() ) )

         end

         oMtrInf:Set( ( dbfTikT )->( LastRec() ) )

      end

   end

   if lSimula
      WndCenter( oDlg:hWnd )
   end

   oBtnCancel:bAction   := {|| oDlg:End() }

   oDlg:Enable()

   ( dbfTikT )->( dbGoTo( nRecAnt ) )
   ( dbfTikT )->( OrdSetFocus( nOrdAnt ) )

Return Nil



Function CntTiket( lSimula, lCobro, lDev, lMessage, oTree, nAsiento, aSimula, dbfTikT, dbfTikL, dbfTikP, dbfClient, dbfArt, dbfFPago, dbfDiv )

   local n
   local nPos
   local dFecha
   local cConcepto
   local cPago
   local nIvaDeta
   local nImpDeta
   local nIvmDeta
   local cSubCtaIvm
   local cSubCtaIva
   local cCtaVent
   local aIva        := {}
   local aIvm        := {}
    local aVentas        := {}
   local aPago       := {}
   local nTotTik     := 0
   local nTotPgo     := 0
   local cCtaPgo     := cCtaCob()
   local cRuta       := cRutCnt()
   local nOrdAnt
   local cCodEmp     := cCodEmpCnt( ( dbfTikT )->cSerTik )
   local cCodPro     := ( dbfTikT )->cCodPro
   local cCtaCli     := cCliCta( ( dbfTikT )->cCliTik, dbfClient )
   local cNumTik     := ( dbfTikT )->cSerTik + ( dbfTikT )->cNumTik + ( dbfTikT )->cSufTik
   local cTxtNumTik  := Rtrim( ( dbfTikT )->cSerTik + "/" + Alltrim( ( dbfTikT )->cNumTik ) + "/" + ( dbfTikT )->cSufTik )
   local cCodDiv     := ( dbfTikT )->cDivTik
   local nDouDiv     := nDouDiv( ( dbfTikT )->cDivTik, dbfDiv )
   local nRouDiv     := nRouDiv( ( dbfTikT )->cDivTik, dbfDiv )
   local lErrorFound := .F.
   local cProyecto
   local cClave
   local cTerNif     := ( dbfTikT )->cDniCli
   local cTerNom     := ( dbfTikT )->cNomTik
   local lReturn

   IIF( nAsiento == nil, nAsiento := 0, ) ;
   IIF( aSimula == nil, aSimula := {}, ) ;

   cProyecto         := Left( cCodPro, 3 )
   cClave            := Right( cCodPro, 6 )






   if !ChkRuta( cRuta )
      oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " ruta no valida para acceso a Contaplus®", 0 ) )
      lErrorFound    := .T.
   end

   if Empty( cCodEmp )
      oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " empresa de Contaplus® no encontrada", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkFecha( cRuta, cCodEmp, ( dbfTikT )->dFecTik, .F., oTree )
      lErrorFound    := .T.
   end

   if ( dbfTikT )->lConTik
      oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + ", ya contabilizado", 0 ) )
      lErrorFound    := .T.
   else
      oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik, 0 ) )
   end

   nTotTik           := nTotTik( cNumTik, dbfTikT, dbfTikL, dbfDiv, nil, nil, .F., nil )

   if lDev
      nTotTik        := - nTotTik
   end






   if Empty( cCtaCli )
      cCtaCli        := cCtaSin()
   end






   if ( dbfTikL )->( dbSeek( cNumTik ) )

      while ( dbfTikL )->cSerTil + ( dbfTikL )->cNumTil + ( dbfTikL )->cSufTil == cNumTik .AND. !( dbfTikL )->( eof() )





         cCtaVent    := RetCtaVta( ( dbfTikL )->cCbaTil, dbfArt )
         if Empty( cCtaVent )
            cCtaVent := cCtaCli() + RetGrpVta( ( dbfTikL )->cCbaTil, cRuta, cCodEmp, dbfArt, ( dbfTikL )->nIvaTil )
         end





         nImpDeta    := nNetLTpv( dbfTikL, nDouDiv, nRouDiv )

         if ( dbfTikT )->nDtoEsp <> 0
            nImpDeta -= Round( nImpDeta * ( dbfTikT )->nDtoEsp / 100, nRouDiv )
         end

         if ( dbfTikT )->nDpp <> 0
            nImpDeta -= Round( nImpDeta * ( dbfTikT )->nDpp / 100, nRouDiv )
         end





         nIvaDeta    := nTotLTpv( dbfTikL, nDouDiv, nRouDiv )

         if ( dbfTikT )->nDtoEsp <> 0
            nIvaDeta -= Round( nIvaDeta * ( dbfTikT )->nDtoEsp / 100, nRouDiv )
         end

         if ( dbfTikT )->nDpp <> 0
            nIvaDeta -= Round( nIvaDeta * ( dbfTikT )->nDpp / 100, nRouDiv )
         end

         nIvaDeta    -= nImpDeta





         nIvmDeta    := nIvmLTpv( dbfTikL, nDouDiv, nRouDiv )

         if ( dbfTikT )->nDtoEsp <> 0
            nIvmDeta -= Round( nIvmDeta * ( dbfTikT )->nDtoEsp / 100, nRouDiv )
         end

         if ( dbfTikT )->nDpp <> 0
            nIvmDeta -= Round( nIvmDeta * ( dbfTikT )->nDpp / 100, nRouDiv )
         end

         nImpDeta    -= nIvmDeta





         if lDev
            nImpDeta := - nImpDeta
            nIvaDeta := - nIvaDeta
            nIvmDeta := - nIvmDeta
         end

         nPos        := aScan( aVentas, {|x| x[ 1 ] == cCtaVent } )
         if nPos == 0
            aAdd( aVentas, { cCtaVent, ( dbfTikL )->nIvaTil, nImpDeta, nIvaDeta } )
         else
            aVentas[ nPos, 3 ] += nImpDeta
            aVentas[ nPos, 4 ] += nIvaDeta
         end






         cSubCtaIva  := cSubCuentaIva( ( dbfTikL )->nIvaTil, .F., cRuta, cCodEmp )

         nPos        := aScan( aIva, {|x| x[ 1 ] == cSubCtaIva } )
         if nPos == 0
            aAdd( aIva, { cSubCtaIva, ( dbfTikL )->nIvaTil, nImpDeta, nIvaDeta } )
         else
            aIva[ nPos, 3 ] += nImpDeta
            aIva[ nPos, 4 ] += nIvaDeta
         end






         if nIvmDeta <> 0

            cSubCtaIvm  := RJust( ( dbfTikL )->nValImp, "0", 2 )
            cSubCtaIvm  := cCtaVta() + RJust( cSubCtaIvm, "0", nLenCuentaContaplus( cRuta, cCodEmp ) )

            nPos        := aScan( aIvm, {|x| x[ 1 ] == cSubCtaIvm } )
            if nPos == 0
               aAdd( aIvm, { cSubCtaIvm, nIvmDeta } )
            else
               aIvm[ nPos, 2 ] += nIvmDeta
            end

         end

         ( dbfTikL )->( dbSkip() )

      end

   end



































































   nOrdAnt           := ( dbfTikP )->( OrdSetFocus( "cNumTik" ) )

   if ( dbfTikP )->( dbSeek( cNumTik ) )

      while ( dbfTikP )->cSerTik + ( dbfTikP )->cNumTik + ( dbfTikP )->cSufTik == cNumTik .AND. !( dbfTikP )->( eof() )

         if !Empty( ( dbfTikP )->cCtaPgo )
            cCtaPgo  := ( dbfTikP )->cCtaPgo
         else
            cCtaPgo  := cCtaFPago( ( dbfTikT )->cFpgTik, dbfFPago )
         end

         if Empty( cCtaPgo )
            cCtaPgo  := cCtaCob()
         end

         nTotPgo     := nCnv2Div( ( dbfTikP )->nImpTik, ( dbfTikP )->cDivPgo, cDivEmp(), dbfDiv )

         if lDev
            nTotPgo  := - nTotPgo
         end

         nPos        := aScan( aPago, {|x| x[ 1 ] + x[ 2 ] == cCtaPgo + cCtaCli } )
         if nPos == 0
            aAdd( aPago, { cCtaPgo, cCtaCli, nTotPgo } )
         else
            aPago[ nPos, 3 ] += nTotPgo
         end

         ( dbfTikP )->( dbSkip() )

      end

   end

   ( dbfTikP )->( OrdSetFocus( nOrdAnt ) )






   if !ChkSubCta( cRuta, cCodEmp, cCtaCli, , .F., .F. )
      oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " subcuenta de cliente " + RTrim( cCtaCli ) + " no encontada, en empresa" + cCodEmp, 0 ) )
      lErrorFound    := .T.
   end

   for n := 1 to len( aVentas )
      if !ChkSubCta( cRuta, cCodEmp, aVentas[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " subcuenta de ventas " + RTrim( aVentas[ n, 1 ] ) + " no encontada, en empresa" + cCodEmp, 0 ) )
         lErrorFound := .T.
      end
   next

   for n := 1 to len( aIva )
      if !ChkSubCta( cRuta, cCodEmp, aIva[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " subcuenta de " + cImp() + " " + RTrim( aIva[ n, 1 ] ) + " no encontada, en empresa" + cCodEmp, 0 ) )
         lErrorFound := .T.
      end
   next

   for n := 1 to len( aIvm )
      if !ChkSubCta( cRuta, cCodEmp, aIvm[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " subcuenta de IVM " + RTrim( aIvm[ n, 1 ] ) + " no encontada, en empresa" + cCodEmp, 0 ) )
         lErrorFound := .T.
      end
   end

   for n := 1 to len( aPago )
      if !ChkSubCta( cRuta, cCodEmp, aPago[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " subcuenta de pago " + RTrim( aPago[ n, 1 ] ) + " no encontada, en empresa" + cCodEmp, 0 ) )
         lErrorFound := .T.
      end
   next






   dFecha      := ( dbfTikT )->dFecTik

   cConcepto   := "N/Tiket N. " + cTxtNumTik
   cPago       := "C/Tiket N. " + cTxtNumTik






   if lSimula .OR. !lErrorFound

      if OpenDiario( , cCodEmp )
         nAsiento := RetLastAsi()
      else
         oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " imposible abrir ficheros.", 0 ) )
         return .F.
      end

























      aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha, cCtaCli, , Round( nTotTik, nRouDiv ), cConcepto, , cNumTik, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )






      for n := 1 to Len( aVentas )





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aVentas[ n, 1 ], , , cConcepto, Round( aVentas[ n, 3 ], nRouDiv ), cNumTik, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next






      for n := 1 to Len( aIvm )





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIvm[ n, 1 ], , , cConcepto, Round( aIvm[ n, 2 ], nRouDiv ), cNumTik, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next






      for n := 1 to len( aIva )

         if aIva[ n, 4 ] <> 0 .OR. uFieldEmpresa( "lConIva" )





















            aAdd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIva[ n, 1 ], cCtaCli, , cConcepto, aIva[ n, 4 ], cNumTik, aIva[ n, 3 ], aIva[ n, 2 ], , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

         end

      next






      if lCobro

         for n := 1 to len( aPago )

            if aPago[ n, 3 ] <> 0





















               aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha,  aPago[ n, 1 ], , aPago[ n, 3 ], cPago, , cNumTik, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

            end





            if aPago[ n, 3 ] <> 0





















               aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha,  aPago[ n, 2 ], , , cPago, aPago[ n, 3 ], cNumTik, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

            end

         next

      end






      if !lSimula

         if !lErrorFound
            lReturn  := lCntTiket( cNumTik, cTxtNumTik, nAsiento, lCobro, oTree, dbfTikT, dbfTikP )
         end

      else

         if lMessage
            lReturn  := msgTblCon( aSimula, cCodDiv, dbfDiv, !( dbfTikT )->lConTik .AND. !lErrorFound, cTxtNumTik, {|| aWriteAsiento( aSimula, cCodDiv, lMessage, oTree, cTxtNumTik, nAsiento ), lCntTiket( cNumTik, cTxtNumTik, nAsiento, lCobro, oTree, dbfTikT, dbfTikP ) } )
         end

      end

   end

   CloseDiario()

RETURN ( lReturn )



Static Function lCntTiket( cNumTik, cTxtNumTik, nAsiento, lCobro, oTree, dbfTikT, dbfTikP )

   local nOrdAnt






   if ( dbfTikT )->( dbRLock() )
      ( dbfTikT )->lConTik          := .T.
      ( dbfTikT )->( dbRUnLock() )
   end






   if lCobro

      nOrdAnt  := ( dbfTikP )->( OrdSetFocus( "cNumTik" ) )

      if ( dbfTikP )->( dbSeek( cNumTik ) )

         while ( dbfTikP )->cSerTik + ( dbfTikP )->cNumTik + ( dbfTikP )->cSufTik == cNumTik .AND. !( dbfTikP )->( eof() )

            if ( dbfTikP )->( dbRLock() )
               ( dbfTikP )->lConPgo := .T.
               ( dbfTikP )->( dbRUnLock() )
            end

            ( dbfTikP )->( dbSkip() )

         end

      end

      ( dbfTikP )->( OrdSetFocus( nOrdAnt ) )

   end

   oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " asiento generado num. " + Alltrim( Str( nAsiento ) ), 1 ) )

Return ( .T. )






Function cSubCuentaIva( nIva, lRecargo, cRuta, cCodEmp, dbfIva, lVentas )

   local nReq        := 0
   local cReq        := ""
   local cIva        := RJust( nIva, "0", 2 )
   local cSubCtaIva  := ""

   IIF( lVentas == nil, lVentas := .T., ) ;

   if ( nLenCuentaContaplus( cRuta, cCodEmp ) >= 4 )
      cReq           := "00"
   end

   if ( lRecargo )
      nReq           := nPReq( dbfIva, nIva )

      if nReq  < 1 .OR. uFieldEmpresa( "lReqDec" )
         nReq        := nReq * 10
      end

      cReq           := RJust( nReq, "0", 2 )
   end

   if lIvaReq()
      cSubCtaIva     := cIva + cReq
   else
      cSubCtaIva     := cReq + cIva
   end

   if lVentas
      cSubCtaIva     := RetCtaEsp( 2 ) + RJust( cSubCtaIva, "0", nLenCuentaContaplus( cRuta, cCodEmp ) )
   else
      cSubCtaIva     := RetCtaEsp( 1 ) + RJust( cSubCtaIva, "0", nLenCuentaContaplus( cRuta, cCodEmp ) )
   end

Return ( cSubCtaIva )






Function cSubCuentaRecargo( nIva, lRecargo, cRuta, cCodEmp, dbfIva )

   local nReq        := 0
   local cSubCtaReq  := ""

   if lRecargo

      nReq           := nPReq( dbfIva, nIva )

      if nReq < 1 .OR. uFieldEmpresa( "lReqDec" )
         nReq        := nReq * 10
      end

   end

   cSubCtaReq        := RetCtaEsp( 3 ) + RJust( nReq, "0", nLenCuentaContaplus( cRuta, cCodEmp ) )

Return ( cSubCtaReq )



FUNCTION CntAlbCli( lSimula, lExcCnt, lMessage, oTree, nAsiento, aSimula, dbfAlbCliT, dbfAlbCliL, dbfCli, dbfDiv, dbfArt, dbfFPago, dbfIva, oNewImp, oBrw )

    local n
    local nIva
   local cCtaVent
   local nPos
    local dFecha
    local ptaDebe
    local cConcepto
    local cPago
    local cSubCtaIva
    local cSubCtaReq
   local cSubCtaIvm
   local cSubCtaTrn
   local nImpDet
   local nImpTrn
   local nImpPnt
   local nImpIvm
   local nImpIva
   local cCodEmp
   local cRuta
   local nDouDiv
   local nRouDiv
   local nDpvDiv
   local nTotAnt     := 0
   local aIva        := {}
   local aIvm        := {}
   local aTrn        := {}
   local nCalculo    := 0
   local nBase       := 0
    local aVentas        := {}
   local lIvaInc     := ( dbfAlbCliT )->lIvaInc
   local cCodDiv     := ( dbfAlbCliT )->cDivAlb
   local cCtaCli     := cCliCta( ( dbfAlbCliT )->cCodCli, dbfCli )
   local cCtaCliVta  := cCliCtaVta( ( dbfAlbCliT )->cCodCli, dbfCli )
   local cCtaAnticipo:= cCtaAnt()
   local nAlbaran    := ( dbfAlbCliT )->cSerAlb + Str( ( dbfAlbCliT )->nNumAlb ) + ( dbfAlbCliT )->cSufAlb
   local cAlbaran    := ( dbfAlbCliT )->cSerAlb + Alltrim( Str( ( dbfAlbCliT )->nNumAlb ) )
   local lRecargo    := ( dbfAlbCliT )->lRecargo
   local lErrorFound := .F.
   local cTerNif     := ( dbfAlbCliT )->cDniCli
   local cTerNom     := ( dbfAlbCliT )->cNomCli
   local lReturn

    IIF( lSimula == nil, lSimula := .T., ) ;
   IIF( nAsiento == nil, nAsiento := 0, ) ;
   IIF( aSimula == nil, aSimula := {}, ) ;

   nDouDiv           := nDouDiv( ( dbfAlbCliT )->cDivAlb, dbfDiv )
   nRouDiv           := nRouDiv( ( dbfAlbCliT )->cDivAlb, dbfDiv )
   nDpvDiv           := nDpvDiv( ( dbfAlbCliT )->cDivAlb, dbfDiv )






   cRuta             := cRutCnt()
   cCodEmp           := cCodEmpCnt( ( dbfAlbCliT )->cSerAlb )

   if Empty( cCodEmp ) .AND. !lSimula
      oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " no se definierón empresas asociadas.", 0 ) )
      lErrorFound    := .T.
   end

   if !lSimula .AND. !ChkRuta( cRutCnt() )
      oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " ruta no valida.", 0 ) )
      lErrorFound    := .T.
   end

   if !lSimula .AND. !ChkFecha( cRuta, cCodEmp, ( dbfAlbCliT )->dFecAlb, .F., oTree )
      lErrorFound    := .T.
   end






   if Empty( cCtaCli )
      cCtaCli        := cCtaSin()
   end

   if Empty( cCtaCliVta )
      cCtaCliVta     := cCtaCli()
   end






   if ( dbfAlbCliL )->( dbSeek( nAlbaran ) )

      while ( ( dbfAlbCliL )->cSerAlb + Str( ( dbfAlbCliL )->nNumAlb ) + ( dbfAlbCliL )->cSufAlb == nAlbaran .AND. !( dbfAlbCliL )->( eof() ) )




         if !( dbfAlbCliL )->lControl                          .AND.  !( dbfAlbCliL )->lTotLin                           .AND.  lValLine( dbfAlbCliL )                             .AND.  nTotLAlbCli( dbfAlbCliL, nDouDiv, nRouDiv, nil, .T., .F., .F. ) <> 0



            if ( lExcCnt == nil                                .OR. ( lExcCnt .AND. ( dbfAlbCliL )->nCtlStk <> 2 )  .OR. ( !lExcCnt .AND. ( dbfAlbCliL )->nCtlStk == 2 ) )

               nIva        := ( dbfAlbCliL )->nIva
               nImpDet     := nTotLAlbCli( dbfAlbCliL, nDouDiv, nRouDiv, nil, .T., .F., .F. )
               nImpTrn     := nTrnLAlbCli( dbfAlbCliL, nDouDiv, nRouDiv )
               nImpPnt     := nPntLAlbCli( dbfAlbCliL, nDpvDiv )
               nImpIva     := nIvaLAlbCli( dbfAlbCliL, nDouDiv, nRouDiv )

               cCtaVent    := RetCtaVta( ( dbfAlbCliL )->cRef, dbfArt )

               if Empty( cCtaVent )
                  cCtaVent := cCtaCliVta + RetGrpVta( ( dbfAlbCliL )->cRef, cRuta, cCodEmp, dbfArt, nIva )
               end





               if nImpDet <> 0 .OR. nImpPnt <> 0 .OR. nImpTrn <> 0

                  nPos     := aScan( aVentas, {|x| x[ 1 ] == cCtaVent .AND. x[ 2 ] == nIva } )
                  if nPos  == 0
                     aAdd( aVentas, { cCtaVent, nIva, nImpDet, nImpPnt, nImpTrn, nImpIva } )
                  else
                     aVentas[ nPos, 3 ]   += nImpDet
                     aVentas[ nPos, 4 ]   += nImpPnt
                     aVentas[ nPos, 5 ]   += nImpTrn
                     aVentas[ nPos, 6 ]   += nImpIva
                  end






                  cSubCtaReq  := cSubCuentaRecargo( nIva, ( dbfAlbCliT )->lRecargo, cRuta, cCodEmp, dbfIva )
                  cSubCtaIva  := cSubCuentaIva( nIva, ( dbfAlbCliT )->lRecargo, cRuta, cCodEmp, dbfIva )

                  nPos        := aScan( aIva, {|x| x[ 1 ] == nIva } )
                  if nPos  == 0
                     aAdd( aIva, { nIva, cSubCtaIva, cSubCtaReq, nImpDet, nImpPnt, nImpTrn, 0 } )
                  else
                     aIva[ nPos, 4 ] += nImpDet
                     aIva[ nPos, 5 ] += nImpPnt
                     aIva[ nPos, 6 ] += nImpTrn
                  end





                  if nImpTrn <> 0

                     cSubCtaTrn  := RetCtaTrn( ( dbfAlbCliL )->cRef, dbfArt )

                     nPos        := aScan( aTrn, {|x| x[1] == cSubCtaTrn } )
                     if nPos == 0
                        aAdd( aTrn, { cSubCtaTrn, nImpTrn } )
                     else
                        aIvm[ nPos, 2 ] += nImpTrn
                     end

                  end





                  nImpIvm        := nTotIAlbCli( dbfAlbCliL, nDouDiv, nRouDiv )

                  if nImpIvm <> 0

                     cSubCtaIvm  := oNewImp:cCtaImp( ( dbfAlbCliL )->nValImp )

                     nPos        := aScan( aIvm, {|x| x[1] == cSubCtaIvm } )
                     if nPos == 0
                        aAdd( aIvm, { cSubCtaIvm, nImpIvm } )
                     else
                        aIvm[ nPos, 2 ] += nImpIvm
                     end

                  end

               end

            end

         end

         SysRefresh()

         ( dbfAlbCliL )->( dbSkip() )

      end

   else

      oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " Albaran sin artículos.", 0 ) )
      lErrorFound := .T.

   end






   for n := 1 to Len( aVentas )

      if ( dbfAlbCliT )->nDtoEsp <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfAlbCliT )->nDtoEsp / 100, nRouDiv )
      end

      if ( dbfAlbCliT )->nDpp <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfAlbCliT )->nDpp / 100, nRouDiv )
      end

      if ( dbfAlbCliT )->nDtoUno <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfAlbCliT )->nDtoUno / 100, nRouDiv )
      end

      if ( dbfAlbCliT )->nDtoDos <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfAlbCliT )->nDtoDos / 100, nRouDiv )
      end

   next





   for n := 1 to Len( aVentas )
      aVentas[ n, 3 ] += aVentas[ n, 4 ]
   next






   for n := 1 to Len( aIva )

      if ( dbfAlbCliT )->nDtoEsp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfAlbCliT )->nDtoEsp / 100, nRouDiv )
      end

      if ( dbfAlbCliT )->nDpp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfAlbCliT )->nDpp / 100, nRouDiv )
      end

      if ( dbfAlbCliT )->nDtoUno <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfAlbCliT )->nDtoUno / 100, nRouDiv )
      end

      if ( dbfAlbCliT )->nDtoDos <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfAlbCliT )->nDtoDos / 100, nRouDiv )
      end

   next





   for n := 1 to Len( aIva )
      aIva[ n, 4 ]   += aIva[ n, 5 ]
   next






   if !lSimula .AND. ( dbfAlbCliT )->lContab
      oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " contabilizada.", 0 ) )
      lErrorFound    := .T.
   end

   if !lSimula .AND. !ChkSubCta( cRuta, cCodEmp, cCtaCli, , .F., .F. )
      oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " subcuenta " + cCtaCli + " no encontada.", 0 ) )
      lErrorFound    := .T.
   end






   for n := 1 TO len( aIva )

      if !lSimula .AND. !ChkSubCta( cRutCnt(), cCodEmp, aIva[ n, 2 ], , .F., .F. )
         oTree:Select( oTree:Add( "Albaran cliente : " + Rtrim( nAlbaran ) + " subcuenta " + aIva[ n, 2 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end

      if lRecargo .AND. !lSimula .AND. !ChkSubCta( cRutCnt(), cCodEmp, aIva[ n, 3 ], , .F., .F. )
         oTree:Select( oTree:Add( "Albaran cliente : " + Rtrim( nAlbaran ) + " subcuenta " + aIva[ n, 3 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end

   next

   for n := 1 to len( aVentas )
      if !lSimula .AND. !ChkSubCta( cRuta, cCodEmp, aVentas[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " subcuenta " + aVentas[ n, 1 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   next

   for n := 1 to len( aIvm )
      if !lSimula .AND. !ChkSubCta( cRuta, cCodEmp, aIvm[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " subcuenta " + aIvm[ n, 1 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   next






   for n := 1 to len( aTrn )
      if !lSimula .AND. !ChkSubCta( cRuta, cCodEmp, aTrn[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " subcuenta " + aTrn[ n, 1 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   next





   if !lSimula .AND. nTotAnt <> 0 .AND. !ChkSubCta( cRuta, cCodEmp, cCtaAnticipo, , .F., .F. )
      oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " subcuenta de anticipo " + cCtaAnticipo + " no encontada.", 0 ) )
      lErrorFound := .T.
   end

   if !lErrorFound






      dFecha      := ( dbfAlbCliT )->dFecAlb
      ptaDebe     := nTotAlbCli( ( dbfAlbCliT )->cSerAlb + Str( ( dbfAlbCliT )->nNumAlb ) + ( dbfAlbCliT )->cSufAlb, dbfAlbCliT, dbfAlbCliL, dbfIva, dbfDiv, nil, nil, .F., lExcCnt  )
      cConcepto   := "N/Alb. N." + ( dbfAlbCliT )->cSerAlb + "/" + AllTrim( Str( ( dbfAlbCliT )->nNumAlb ) + "/" + ( dbfAlbCliT )->cSufAlb )
      cPago       := "C/Alb. N." + ( dbfAlbCliT )->cSerAlb + "/" + AllTrim( Str( ( dbfAlbCliT )->nNumAlb ) + "/" + ( dbfAlbCliT )->cSufAlb )






      if OpenDiario( , cCodEmp )
         nAsiento := RetLastAsi()
      else
         oTree:Select( oTree:Add( "Albaran cliente : " + Rtrim( nAlbaran ) + " imposible abrir ficheros.", 0 ) )
         return .F.
      end

























      aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha, cCtaCli, , Round( ptaDebe, nRouDiv ), cConcepto, , cAlbaran, , , , , , , , , , lSimula, cTerNif, cTerNom ) )






      for n := 1 to Len( aVentas )

         if lIvaInc

         nCalculo    := Round( aVentas[ n, 3 ], nRouDiv )
         if aVentas[ n, 2 ] <> 0
            nCalculo -= Round( aVentas[ n, 3 ] / ( 100 / aVentas[ n, 2 ] + 1 ), nRouDiv )
         end





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aVentas[ n, 1 ], , , cConcepto, nCalculo, cAlbaran, , , , , , , , , , lSimula, cTerNif, cTerNom ) )

         else





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aVentas[ n, 1 ], , , cConcepto, Round( aVentas[ n, 3 ], nRouDiv ), cAlbaran, , , , , , , , , , lSimula, cTerNif, cTerNom ) )

         end

      next






      for n := 1 to Len( aIvm )





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIvm[ n, 1 ], , , cConcepto, Round( aIvm[ n, 2 ], nRouDiv ), cAlbaran, , , , , , , , , , lSimula, cTerNif, cTerNom ) )

      next






      for n := 1 to Len( aTrn )





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aTrn[ n, 1 ], , , cConcepto, Round( aTrn[ n, 2 ], nRouDiv ), cAlbaran, , , , , , , , , , lSimula, cTerNif, cTerNom ) )

      next






      for n := 1 to len( aIva )

         nBase          := Round( aIva[ n, 4 ], nRouDiv ) + Round( aIva[ n, 7 ], nRouDiv )

         if lIvaInc

            if aIva[ n, 1 ] <> 0
               nCalculo := Round( aIva[ n, 4 ] / ( 100 / aIva[ n, 1 ] + 1 ), nRouDiv )
               nCalculo += Round( aIva[ n, 7 ] / ( 100 / aIva[ n, 1 ] + 1 ), nRouDiv )
            else
               nCalculo := 0
            end

            if aIva[ n, 1 ] <> 0 .OR. uFieldEmpresa( "lConIva" )





















               aAdd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIva[ n, 2 ], cCtaCli, , cConcepto, nCalculo, cAlbaran, nBase - nCalculo, Round( aIva[ n, 1 ], nRouDiv ), If( lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), ), , , , , , , lSimula, cTerNif, cTerNom ) )

            end

         else

            nCalculo    := Round( aIva[ n, 4 ] * aIva[ n, 1 ] / 100, nRouDiv )
            nCalculo    += Round( aIva[ n, 7 ] * aIva[ n, 1 ] / 100, nRouDiv )

            if aIva[ n, 1 ] <> 0 .OR. uFieldEmpresa( "lConIva" )





















               aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIva[ n, 2 ], cCtaCli, , cConcepto, nCalculo, cAlbaran, nBase, Round( aIva[ n, 1 ], nRouDiv ), If( lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), ), , , , , , , lSimula, cTerNif, cTerNom ) )

            end

         end

      next






      if lRecargo

         for n := 1 TO len( aIva )

            if Round( nPReq( dbfIva, aIva[ n, 1 ] ) * ( aIva[ n, 4 ] ) / 100, nRouDiv ) <> 0





















               aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, aIva[ n, 3 ], , , cConcepto, Round( nPReq( dbfIva, aIva[ n, 1 ] ) * ( aIva[ n, 4 ] ) / 100, nRouDiv ), cAlbaran, , , , , , , , , , lSimula, cTerNif, cTerNom ) )
            end

         next

      end






      if !lSimula

         if ( dbfAlbCliT )->( dbRLock() )
            ( dbfAlbCliT )->lContab := .T.
            ( dbfAlbCliT )->( dbUnLock() )
         end

         oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " asiento generado num. " + Alltrim( Str( nAsiento ) ), 0 ) )

      else

         if lMessage
            lReturn  := msgTblCon( aSimula, cCodDiv, dbfDiv )
         end

      end

   end

   CloseDiario()

   if oBrw <> NIL
        oBrw:refresh()
   end

RETURN ( lReturn )







FUNCTION CntFacRec( lSimula, lPago, lExcCnt, lMessage, oTree, nAsiento, aSimula, dbfFacRecT, dbfFacRecL, dbfFacCliP, dbfCli, dbfDiv, dbfArt, dbfFPago, dbfIva, oNewImp, oBrw )

    local n
    local nIva
   local lIvaCEE
   local cCtaVent
   local nPos
    local dFecha
    local ptaDebe
    local cConcepto
    local cSubCtaIva
    local cSubCtaReq
   local cSubCtaTrn
   local cSubCtaIvm
   local nImpDet
   local nImpTrn
   local nImpPnt
   local nImpIva
   local nImpIvm
   local cRuta
   local nDouDiv
   local nRouDiv
   local nDpvDiv
   local nOrdAnt
   local nAcuAnt     := 0
   local nTotAnt     := 0
   local aIva        := {}
   local aTrn        := {}
   local aIvm        := {}
   local nCalculo    := 0
   local nBase       := 0
    local aVentas        := {}
   local lIvaInc     := ( dbfFacRecT )->lIvaInc
   local cCodDiv     := ( dbfFacRecT )->cDivFac
   local cCtaCli     := cCliCta( ( dbfFacRecT )->cCodCli, dbfCli )
   local cCtaCliVta  := cCliCtaVta( ( dbfFacRecT )->cCodCli, dbfCli )
   local cCtaAnticipo:= cCtaAnt()
   local nFactura    := ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac
   local cFactura    := ( dbfFacRecT )->cSerie + Alltrim( Str( ( dbfFacRecT )->nNumFac ) )
   local pFactura    := ( dbfFacRecT )->cSerie + "/" + Alltrim( Str( ( dbfFacRecT )->nNumFac ) ) + "/" + ( dbfFacRecT )->cSufFac
   local lRecargo    := ( dbfFacRecT )->lRecargo
   local lErrorFound := .F.
   local cTerNif     := ( dbfFacRecT )->cDniCli
   local cTerNom     := ( dbfFacRecT )->cNomCli
   local cCodEmp     := cCodEmpCnt( ( dbfFacRecT )->cSerie )
   local cCodPro     := ( dbfFacRecT )->cCodPro
   local cProyecto
   local cClave
   local lReturn

    IIF( lSimula == nil, lSimula := .T., ) ;
   IIF( nAsiento == nil, nAsiento := 0, ) ;
   IIF( aSimula == nil, aSimula := {}, ) ;

   nDouDiv           := nDouDiv( (dbfFacRecT)->CDIVFAC, dbfDiv )
   nRouDiv           := nRouDiv( (dbfFacRecT)->CDIVFAC, dbfDiv )
   nDpvDiv           := nDpvDiv( (dbfFacRecT)->CDIVFAC, dbfDiv )

   cProyecto         := Left( cCodPro, 3 )
   cClave            := Right( cCodPro, 6 )






   cRuta             := cRutCnt()
   lIvaCEE           := ( ( dbfFacRecT )->nRegIva == 2 )

   if Empty( cCodEmp )
      oTree:Select( oTree:Add( "Factura rectificativa de cliente : " + rtrim( pFactura ) + " no se definierón empresas asociadas.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkRuta( cRutCnt() )
      oTree:Select( oTree:Add( "Factura rectificativa de cliente : " + rtrim( pFactura ) + " ruta no valida.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkFecha( cRuta, cCodEmp, ( dbfFacRecT )->dFecFac, .F., oTree, "Factura rectificativa de cliente : " + rtrim( pFactura ) )
      lErrorFound    := .T.
   end






   if ( dbfFacRecT )->lContab
      oTree:Select( oTree:Add( "Factura rectificativa de cliente : " + rtrim( pFactura ) + " contabilizada.", 0 ) )
      lErrorFound    := .T.
   end






   if Empty( cCtaCli )
      cCtaCli        := cCtaSin()
   end

   if Empty( cCtaCliVta )
      cCtaCliVta     := cCtaCli()
   end






   if ( dbfFacRecL )->( dbSeek( nFactura ) )

      while ( ( dbfFacRecL )->cSerie + Str( ( dbfFacRecL )->nNumFac ) + ( dbfFacRecL )->cSufFac == nFactura .AND. !( dbfFacRecL )->( eof() ) )




         if !( dbfFacRecL )->lControl                             .AND. !( dbfFacRecL )->lTotLin                              .AND. lValLine( dbfFacRecL )                                .AND. nTotLFacRec( dbfFacRecL, nDouDiv, nRouDiv, nil, .T., .F., .F. ) <> 0



            if ( lExcCnt == nil                                   .OR. ( lExcCnt .AND. ( dbfFacRecL )->nCtlStk <> 2 )     .OR. ( !lExcCnt .AND. ( dbfFacRecL )->nCtlStk == 2 ) )

               nIva        := ( dbfFacRecL )->nIva
               nImpDet     := nTotLFacRec( dbfFacRecL, nDouDiv, nRouDiv, nil, .T., .F., .F. )
               nImpIvm     := nTotIFacRec( dbfFacRecL, nDouDiv, nRouDiv )
               nImpTrn     := nTrnLFacRec( dbfFacRecL, nDouDiv, nRouDiv )
               nImpPnt     := nPntLFacRec( dbfFacRecL, nDpvDiv )
               nImpIva     := nIvaLFacRec( dbfFacRecT, dbfFacRecL, nDouDiv, nRouDiv )

               cCtaVent    := RetCtaVta( ( dbfFacRecL )->cRef, dbfArt )

               if Empty( cCtaVent )
                  cCtaVent := cCtaCliVta + RetGrpVta( ( dbfFacRecL )->cRef, cRuta, cCodEmp, dbfArt, nIva )
               end







                  nPos        := aScan( aVentas, {|x| x[ 1 ] == cCtaVent .AND. x[ 2 ] == nIva } )
                  if nPos  == 0
                     aAdd( aVentas, { cCtaVent, nIva, nImpDet, nImpPnt, nImpTrn, nImpIva } )
                  else
                     aVentas[ nPos, 3 ]   += nImpDet
                     aVentas[ nPos, 4 ]   += nImpPnt
                     aVentas[ nPos, 5 ]   += nImpTrn
                     aVentas[ nPos, 6 ]   += nImpIva
                  end





                  if lIvaCEE
                     cSubCtaIva  := uFieldEmpresa( "cCtaCeeRpt" )
                     cSubCtaReq  := uFieldEmpresa( "cCtaCeeSpt" )
                  else
                     cSubCtaIva  := cSubCuentaIva( nIva, ( dbfFacRecT )->lRecargo, cRuta, cCodEmp, dbfIva )
                     cSubCtaReq  := cSubCuentaRecargo( nIva, ( dbfFacRecT )->lRecargo, cRuta, cCodEmp, dbfIva )
                  end

                  if uFieldEmpresa( "lIvaImpEsp" )
                     nImpDet     += nImpIvm
                  end

                  nPos           := aScan( aIva, {|x| x[ 1 ] == nIva } )
                  if nPos  == 0
                     aAdd( aIva, { nIva, cSubCtaIva, cSubCtaReq, nImpDet, nImpPnt, nImpTrn, 0 } )
                  else
                     aIva[ nPos, 4 ] += nImpDet
                     aIva[ nPos, 5 ] += nImpPnt
                     aIva[ nPos, 6 ] += nImpTrn
                  end





                  if nImpTrn <> 0

                     cSubCtaTrn  := RetCtaTrn( ( dbfFacRecL )->cRef, dbfArt )

                     nPos        := aScan( aTrn, {|x| x[1] == cSubCtaTrn } )
                     if nPos == 0
                        aAdd( aTrn, { cSubCtaTrn, nImpTrn } )
                     else
                        aTrn[ nPos, 2 ] += nImpTrn
                     end

                  end





                  nImpIvm        := nTotIFacRec( dbfFacRecL, nDouDiv, nRouDiv )

                  if nImpIvm <> 0

                     cSubCtaIvm  := oNewImp:cCtaImp( ( dbfFacRecL )->nValImp )

                     nPos        := aScan( aIvm, {|x| x[1] == cSubCtaIvm } )
                     if nPos == 0
                        aAdd( aIvm, { cSubCtaIvm, nImpIvm } )
                     else
                        aIvm[ nPos, 2 ] += nImpIvm
                     end

                  end



            end

         end

         SysRefresh()

         ( dbfFacRecL )->( dbSkip() )

      end

   else

      oTree:Select( oTree:Add( "Factura rectificativa de cliente : " + rtrim( pFactura ) + " factura sin artículos.", 0 ) )
      lErrorFound := .T.

   end






   for n := 1 to Len( aVentas )

      if ( dbfFacRecT )->nDtoEsp <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfFacRecT )->nDtoEsp / 100, nRouDiv )
      end

      if ( dbfFacRecT )->nDpp <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfFacRecT )->nDpp / 100, nRouDiv )
      end

      if ( dbfFacRecT )->nDtoUno <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfFacRecT )->nDtoUno / 100, nRouDiv )
      end

      if ( dbfFacRecT )->nDtoDos <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfFacRecT )->nDtoDos / 100, nRouDiv )
      end

   next





   for n := 1 to Len( aVentas )
      aVentas[ n, 3 ] += aVentas[ n, 4 ]
   next






   for n := 1 to Len( aIva )

      if ( dbfFacRecT )->nDtoEsp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfFacRecT )->nDtoEsp / 100, nRouDiv )
      end

      if ( dbfFacRecT )->nDpp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfFacRecT )->nDpp / 100, nRouDiv )
      end

      if ( dbfFacRecT )->nDtoUno <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfFacRecT )->nDtoUno / 100, nRouDiv )
      end

      if ( dbfFacRecT )->nDtoDos <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfFacRecT )->nDtoDos / 100, nRouDiv )
      end

   next





   for n := 1 to Len( aIva )
      aIva[ n, 4 ]   += aIva[ n, 5 ]
   next

   if !ChkSubCta( cRuta, cCodEmp, cCtaCli, , .F., .F. )
      oTree:Select( oTree:Add( "Factura rectificativa de cliente : " + rtrim( pFactura ) + " subcuenta " + cCtaCli + " no encontada.", 0 ) )
      lErrorFound    := .T.
   end






   for n := 1 TO len( aIva )

      if !ChkSubCta( cRutCnt(), cCodEmp, aIva[ n, 2 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura rectificativa de cliente : " + rtrim( pFactura ) + " subcuenta " + aIva[ n, 2 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end

      if lRecargo .AND. !ChkSubCta( cRutCnt(), cCodEmp, aIva[ n, 3 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura rectificativa de cliente : " + rtrim( pFactura ) + " subcuenta " + aIva[ n, 3 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end

   next

   for n := 1 to len( aVentas )
      if !ChkSubCta( cRuta, cCodEmp, aVentas[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura rectificativa de cliente : " + rtrim( pFactura ) + " subcuenta " + aVentas[ n, 1 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   next

   for n := 1 to len( aIvm )
      if !lSimula .AND. !ChkSubCta( cRuta, cCodEmp, aIvm[ n, 1 ], , .F., .F. )
         oTree:Add( "Factura rectificativa de cliente : " + rtrim( nFactura ) + " subcuenta " + aIvm[ n, 1 ] + " no encontada.", 0 )
         lErrorFound := .T.
      end
   next






   for n := 1 to len( aTrn )
      if !ChkSubCta( cRuta, cCodEmp, aTrn[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura rectificativa de cliente : " + rtrim( pFactura ) + " subcuenta " + aTrn[ n, 1 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   next





   if nTotAnt <> 0 .AND. !ChkSubCta( cRuta, cCodEmp, cCtaAnticipo, , .F., .F. )
      oTree:Select( oTree:Add( "Factura rectificativa de cliente : " + rtrim( pFactura ) + " subcuenta de anticipo " + cCtaAnticipo + " no encontada.", 0 ) )
      lErrorFound := .T.
   end

   if lSimula .OR. !lErrorFound






      dFecha      := ( dbfFacRecT )->dFecFac
      ptaDebe     := nTotFacRec( ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac, dbfFacRecT, dbfFacRecL, dbfIva, dbfDiv, nil, nil, .F., lExcCnt  )
      cConcepto   := "N/Rect. N." + ( dbfFacRecT )->cSerie + "/" + AllTrim( Str( ( dbfFacRecT )->nNumFac ) + "/" + ( dbfFacRecT )->cSufFac )






      if OpenDiario( , cCodEmp )
         nAsiento := RetLastAsi()
      else
         oTree:Select( oTree:Add( "Factura rectificativa de cliente : " + rtrim( pFactura ) + " imposible abrir ficheros.", 0 ) )
         return .F.
      end

























      aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha, cCtaCli, , Round( ptaDebe, nRouDiv ), cConcepto, , cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )






      for n := 1 to Len( aVentas )

         if lIvaInc

         nCalculo    := Round( aVentas[ n, 3 ], nRouDiv )

         if aVentas[ n, 2 ] <> 0
            nCalculo -= Round( aVentas[ n, 3 ] / ( 100 / aVentas[ n, 2 ] + 1 ), nRouDiv )
         end





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aVentas[ n, 1 ], , , cConcepto, nCalculo, cFactura, , , , , cProyecto, cClave, .T., , , lSimula, cTerNif, cTerNom ) )

         else





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aVentas[ n, 1 ], , , cConcepto, Round( aVentas[ n, 3 ], nRouDiv ), cFactura, , , , , cProyecto, cClave, .T., , , lSimula, cTerNif, cTerNom ) )

         end

      next






      if nTotAnt <> 0





















      aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaAnticipo, , nAcuAnt, cConcepto, , cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      end






      for n := 1 to Len( aTrn )





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aTrn[ n, 1 ], , , cConcepto, Round( aTrn[ n, 2 ], nRouDiv ), cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next






      for n := 1 to len( aIva )

         nBase          := Round( aIva[ n, 4 ], nRouDiv ) + Round( aIva[ n, 7 ], nRouDiv )

         if lIvaInc

            if aIva[ n, 1 ] <> 0
               nCalculo := Round( aIva[ n, 4 ] / ( 100 / aIva[ n, 1 ] + 1 ), nRouDiv )
               nCalculo += Round( aIva[ n, 7 ] / ( 100 / aIva[ n, 1 ] + 1 ), nRouDiv )
            else
               nCalculo := 0
            end

            if aIva[ n, 1 ] <> 0 .OR. uFieldEmpresa( "lConIva" )





















               aAdd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIva[ n, 2 ], if( lIvaCEE, aIva[ n, 3 ], cCtaCli ), , cConcepto, nCalculo, cFactura, nBase - nCalculo, Round( aIva[ n, 1 ], nRouDiv ), If( lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), ), , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

            end

         else

            nCalculo    := Round( aIva[ n, 4 ] * aIva[ n, 1 ] / 100, nRouDiv )
            nCalculo    += Round( aIva[ n, 7 ] * aIva[ n, 1 ] / 100, nRouDiv )

            if aIva[ n, 1 ] <> 0 .OR. uFieldEmpresa( "lConIva" )





















               aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIva[ n, 2 ], if( lIvaCEE, aIva[ n, 3 ], cCtaCli ), , cConcepto, nCalculo, cFactura, nBase, Round( aIva[ n, 1 ], nRouDiv ), If( lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), ), , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

            end

         end

      next






      for n := 1 to Len( aIvm )



















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIvm[ n, 1 ], , , cConcepto, Round( aIvm[ n, 2 ], nRouDiv ), cFactura, , , , , cProyecto, cClave, , , , lSimula ) )

      next






      if lRecargo

         for n := 1 TO len( aIva )

            if Round( nPReq( dbfIva, aIva[ n, 1 ] ) * ( aIva[ n, 4 ] ) / 100, nRouDiv ) <> 0





















               aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, aIva[ n, 3 ], , , cConcepto, Round( nPReq( dbfIva, aIva[ n, 1 ] ) * ( aIva[ n, 4 ] ) / 100, nRouDiv ), cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )
            end

         next

      end

   end






   nOrdAnt  := ( dbfFacCliP )->( OrdSetFocus( "rNumFac" ) )

   if lPago .AND. ( dbfFacCliP )->( dbSeek( nFactura ) )

      while ( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac == nFactura ) .AND. !( dbfFacCliP )->( eof() )

         lReturn  := ContabilizaReciboCliente( oBrw, oTree, lSimula, aSimula, dbfFacRecT, dbfFacCliP, dbfDiv, .T., nAsiento )

         if IsFalse( lReturn )
            exit
         end

         ( dbfFacCliP )->( dbSkip() )

      end

   end

   ( dbfFacCliP )->( OrdSetFocus( nOrdAnt ) )






   if !lSimula .AND. !lErrorFound

      lReturn     := lCntFacRec( nFactura, pFactura, nAsiento, lPago, oTree, dbfFacRecT )

   else

      if lMessage
         lReturn  := msgTblCon( aSimula, cCodDiv, dbfDiv, !lErrorFound, pFactura, {|| aWriteAsiento( aSimula, cCodDiv, lMessage, oTree, pFactura, nAsiento ), lCntFacRec( nFactura, pFactura, nAsiento, lPago, oTree, dbfFacRecT, dbfFacCliP ) } )
      end

   end





   CloseDiario()

   if !Empty( oBrw )
      oBrw:Refresh()
   end

RETURN ( lReturn )



Static Function lCntFacRec( nFactura, pFactura, nAsiento, lPago, oTree, dbfFacRecT, dbfFacCliP )






   if ( dbfFacRecT )->( dbRLock() )
      ( dbfFacRecT )->lContab := .T.
      ( dbfFacRecT )->( dbUnLock() )
   end

   oTree:Select( oTree:Add( "Factura rectificativa : " + rtrim( pFactura ) + " asiento generado num. " + Alltrim( Str( nAsiento ) ), 1 ) )

   if !Empty( dbfFacCliP )

      if lPago .AND. ( dbfFacCliP )->( dbSeek( nFactura ) )

         while ( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac == nFactura ) .AND. !( dbfFacCliP )->( eof() )

            lContabilizaReciboCliente( nil, nil, .T., oTree, dbfFacCliP )

            ( dbfFacCliP )->( dbSkip() )

         end

      end

   end

Return ( .T. )







FUNCTION CntFacPrv( lSimula, lPago, lMessage, oTree, nAsiento, aSimula, dbfFacPrvT, dbfFacPrvL, dbfFacPrvP, dbfPrv, dbfDiv, dbfArticulo, dbfFPago, dbfIva, oBrw )

    local n
   local nOrd
    local cCtaVent
    local nPosicion
    local nPosIva
    local dFecha
   local aTotFac
   local nTotFac
   local nTotRet
   local aTotIva
    local cConcepto
   local cConCompr
    local cSubCtaIva
    local cSubCtaReq
   local cRuta
   local cCodEmp
   local nImpDeta
   local nDinDiv     := nDinDiv( ( dbfFacPrvT )->cDivFac, dbfDiv )
   local nRinDiv     := nRinDiv( ( dbfFacPrvT )->cDivFac, dbfDiv )
    local aIva            := {}
    local aVentas        := {}
   local cCodDiv     := ( dbfFacPrvT )->cDivFac
   local cCtaPrv     := cPrvCta( ( dbfFacPrvT )->cCodPrv, dbfPrv )
   local cCtaPrvVta  := cPrvCtaVta( ( dbfFacPrvT )->cCodPrv, dbfPrv )
   local nFactura    := ( dbfFacPrvT )->cSerFac + Str( ( dbfFacPrvT )->nNumFac ) + ( dbfFacPrvT )->cSufFac
   local cFactura    := ( dbfFacPrvT )->cSerFac + "/" + Ltrim( Str( ( dbfFacPrvT )->nNumFac ) ) + "/" + ( dbfFacPrvT )->cSufFac
   local nNumFac     := ( dbfFacPrvT )->nNumFac
   local cCodPro     := Left( ( dbfFacPrvT )->cCodPro, 3 )
   local cClave      := Right( ( dbfFacPrvT )->cCodPro, 6 )
   local lErrorFound := .F.
   local cTerNif     := ( dbfFacPrvT )->cDniPrv
   local cTerNom     := ( dbfFacPrvT )->cNomPrv
   local lReturn

   IIF( aSimula == nil, aSimula := {}, ) ;





   if ( dbfFacPrvT )->lContab
      oTree:Select( oTree:Add( "Factura proveedor : " + Rtrim( cFactura ) + ", ya contabilizada.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkRuta( cRutCnt() )
      oTree:Select( oTree:Add( "Factura proveedor : " + rtrim( cFactura ) + ", ruta no valida.", 0 ) )
      lErrorFound    := .T.
   end





   cRuta             := cRutCnt()
   cCodEmp           := cCodEmpCnt( ( dbfFacPrvT )->cSerFac )

   if Empty( cCtaPrvVta )
      cCtaPrvVta     := cCtaPrv()
   end

   if !ChkSubCta( cRutCnt(), cCodEmp, cCtaPrv, , .F., .F. )
      oTree:Select( oTree:Add( "Factura proveedor : " + rtrim( cFactura ) + " subcuenta de proveedor " + Rtrim( cCtaPrv ) + ", no encontada.", 0 ) )
      lErrorFound    := .T.
   end





   aTotFac           := aTotFacPrv( nFactura, dbfFacPrvT, dbfFacPrvL, dbfIva, dbfDiv, dbfFacPrvP )
   nTotFac           := aTotFac[ 4 ]
   aTotIva           := aTotFac[ 5 ]
   nTotRet           := aTotFac[ 6 ]





   if ( dbfFacPrvT )->lFacGas

      aAdd( aVentas, { ( dbfFacPrvT )->SubCta, aTotFac[ 1 ] } )





      for n := 1 to Len( aTotIva )

         if ( dbfFacPrvT )->nRegIva == 2
            cSubCtaIva  := uFieldEmpresa( "cCtaCeeRpt" )
            cSubCtaReq  := uFieldEmpresa( "cCtaCeeSpt" )
         else
            cSubCtaIva  := cSubCuentaIva(       aTotIva[ n, 3 ], ( dbfFacPrvT )->lRecargo, cRuta, cCodEmp, dbfIva, .F. )
            cSubCtaReq  := cSubCuentaRecargo(   aTotIva[ n, 3 ], ( dbfFacPrvT )->lRecargo, cRuta, cCodEmp, dbfIva )
         end

         nPosIva        := aScan( aIva, {|x| x[ 1 ] == aTotIva[ n, 3 ] } )
         if nPosIva == 0
            aAdd( aIva, { aTotIva[ n, 3 ], cSubCtaIva, cSubCtaReq, aTotIva[ n, 1 ] } )
         else
            aIva[ nPosIva, 4 ]   += aTotIva[ n, 1 ]
         end

      next

   else





      if ( dbfFacPrvL )->( dbSeek( nFactura ) )

         while ( ( dbfFacPrvL )->cSerFac + Str( ( dbfFacPrvL )->nNumFac ) + ( dbfFacPrvL )->cSufFac == nFactura .AND. !( dbfFacPrvL )->( eof() ) )

            nImpDeta       := nTotLFacPrv( dbfFacPrvL, nDinDiv, nRinDiv )

            if nImpDeta <> 0

               cCtaVent    := RetCtaCom( ( dbfFacPrvL )->cRef, dbfArticulo )
               if Empty( cCtaVent )
                  cCtaVent := cCtaPrvVta + RetGrpVta( ( dbfFacPrvL )->cRef, cRuta, cCodEmp, dbfArticulo, ( dbfFacPrvL )->nIva )
               end

               nPosicion   := aScan( aVentas, {|x| x[1] == cCtaVent } )

               if nPosicion == 0
                  aadd( aVentas, { cCtaVent, nImpDeta } )
               else
                  aVentas[ nPosicion, 2 ] += nImpDeta
               end





               if ( dbfFacPrvT )->nRegIva == 2
                  cSubCtaIva  := uFieldEmpresa( "cCtaCeeRpt" )
                  cSubCtaReq  := uFieldEmpresa( "cCtaCeeSpt" )
               else
                  cSubCtaIva  := cSubCuentaIva( ( dbfFacPrvL )->nIva, ( dbfFacPrvT )->lRecargo, cRuta, cCodEmp, dbfIva, .F. )
                  cSubCtaReq  := cSubCuentaRecargo( ( dbfFacPrvL )->nIva, ( dbfFacPrvT )->lRecargo, cRuta, cCodEmp, dbfIva )
               end

               nPosIva        := aScan( aIva, {|x| x[1] == ( dbfFacPrvL )->nIva } )
               if nPosIva == 0
                  aadd( aIva, { ( dbfFacPrvL )->nIva, cSubCtaIva, cSubCtaReq, nImpDeta } )
               else
                  aIva[ nPosIva, 4 ]   += nImpDeta
               end

            end

            ( dbfFacPrvL )->( dbSkip() )

         end

      else

         oTree:Select( oTree:Add( "Factura proveedor : " + Rtrim( cFactura ) + " factura sin artículos.", 0 ) )

         lErrorFound    := .T.

      end

   end





   for n := 1 TO Len( aVentas )

      if ( dbfFacPrvT )->nDtoEsp <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfFacPrvT )->nDtoEsp / 100, nRinDiv )
      end

      if ( dbfFacPrvT )->nDpp <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfFacPrvT )->nDpp / 100, nRinDiv )
      end

      if ( dbfFacPrvT )->nDtoUno <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfFacPrvT )->nDtoUno / 100, nRinDiv )
      end

      if ( dbfFacPrvT )->nDtoDos <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfFacPrvT )->nDtoDos / 100, nRinDiv )
      end

   next





   for n := 1 to Len( aIva )

      if ( dbfFacPrvT )->nDtoEsp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfFacPrvT )->nDtoEsp / 100, nRinDiv )
      end

      if ( dbfFacPrvT )->nDpp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfFacPrvT )->nDpp / 100, nRinDiv )
      end

      if ( dbfFacPrvT )->nDtoUno <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfFacPrvT )->nDtoUno / 100, nRinDiv )
      end

      if ( dbfFacPrvT )->nDtoDos <> 0
         aIva[ n, 2 ] -= Round( aIva[ n, 4 ] * ( dbfFacPrvT )->nDtoDos / 100, nRinDiv )
      end

   next





   for n := 1 TO len( aVentas )
      if !ChkSubCta( cRutCnt(), cCodEmp, aVentas[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura proveedor : " + rtrim( cFactura ) + " subcuenta de ventas " + aVentas[ n, 1 ] + " no encontada.", 0 ) )
         lErrorFound    := .T.
      end
   next





   for n := 1 to len( aIva )

      if !ChkSubCta( cRuta, cCodEmp, aIva[ n, 2 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura proveedor : " + Rtrim( cFactura ) + " subcuenta de " + cImp() + " " + aIva[ n, 2 ] + ", no encontada.", 0 ) )
         lErrorFound    := .T.
      end

      if !ChkSubCta( cRuta, cCodEmp, aIva[ n, 3 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura proveedor : " + Rtrim( cFactura ) + " subcuenta de " + cImp() + " " + aIva[ n, 3 ] + ", no encontada.", 0 ) )
         lErrorFound    := .T.
      end

   next

   if nTotRet <> 0

      if !ChkSubCta( cRuta, cCodEmp, cCtaRet(), , .F., .F. )
         oTree:Select( oTree:Add( "Factura proveedor : " + Rtrim( cFactura ) + " subcuenta de retenciones " + cCtaRet() + ", no encontada.", 0 ) )
         lErrorFound    := .T.
      end

   end





   if !ChkFecha( cRuta, cCodEmp, ( dbfFacPrvT )->dFecFac, .F. )
      oTree:Select( oTree:Add(  "Factura proveedor : " + Rtrim( cFactura ) + " asiento fuera de fechas.", 0 ) )
      lErrorFound    := .T.
   end





   if lSimula .OR. !lErrorFound

      if Empty( ( dbfFacPrvT )->dFecEnt )
         dFecha      := ( dbfFacPrvT )->dFecFac
      else
         dFecha      := ( dbfFacPrvT )->dFecEnt
      end

      cConCompr      := "S/Fcta."
      if !Empty( ( dbfFacPrvT )->cSuPed )
         nNumFac     := Val( ( dbfFacPrvT )->cSuPed )
         cConCompr   += " N." + Rtrim( ( dbfFacPrvT )->cSuPed )
      elseif !Empty( ( dbfFacPrvT )->cNumDoc )
         cConCompr   += " Doc. " + Rtrim( ( dbfFacPrvT )->cNumDoc )
      else
         cConCompr   += " N." + Rtrim( cFactura )
      end
      cConcepto      := cConCompr + Space( 1 ) + DtoC( ( dbfFacPrvT )->dFecFac )
      cConCompr      += Space( 1 ) + Rtrim( ( dbfFacPrvT )->cNomPrv )





      if OpenDiario( , cCodEmp )
         nAsiento    := RetLastAsi()
      else
         oTree:Select( oTree:Add( "Factura proveedor : " + Rtrim( cFactura ) + " imposible abrir ficheros de contaplus.", 0 ) )
         return .F.
      end

























      aAdd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaPrv, , , cConcepto, nTotFac, nNumFac, , , , ( dbfFacPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )





      for n := 1 TO len( aVentas )





















         aAdd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, aVentas[ n, 1 ], , aVentas[ n, 2 ], cConCompr, , nNumFac, , , , ( dbfFacPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next





      if ( dbfFacPrvT )->nRegIva == 2

         for n := 1 to len( aIva )

            if aIva[ n, 1 ] <> 0 .OR. uFieldEmpresa( "lConIva" )





















               aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha,  aIva[ n, 3 ], aIva[ n, 2 ], Round( aIva[ n, 1 ] * aIva[ n, 4 ] / 100, nRinDiv ), cConCompr, Round( aIva[ n, 1 ] * aIva[ n, 4 ] / 100, nRinDiv ), nNumFac, aIva[ n, 4 ], aIva[ n, 1 ], If( ( dbfFacPrvT )->lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), 0 ), ( dbfFacPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

            end

         next

      else

         for n := 1 to len( aIva )

            if aIva[ n, 1 ] <> 0 .OR. uFieldEmpresa( "lConIva" )





















               aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha,  aIva[ n, 2 ], cCtaPrv, Round( aIva[ n, 1 ] * aIva[ n, 4 ] / 100, nRinDiv ), cConCompr, , nNumFac, aIva[ n, 4 ], aIva[ n, 1 ], If( ( dbfFacPrvT )->lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), 0 ), ( dbfFacPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

            end

         next





         if ( dbfFacPrvT )->lRecargo

            for n := 1 to len( aIva )

               if aIva[ n, 1 ] <> 0 .OR. uFieldEmpresa( "lConIva" )





















                  aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, aIva[ n, 3 ], , Round( nPReq( dbfIva, aIva[ n, 1 ] ) * aIva[ n, 4 ] / 100, nRinDiv ), cConCompr, , nNumFac, , , , ( dbfFacPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

               end

            next

         end

      end





      if nTotRet <> 0





















         aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaRet(), , , cConCompr, nTotRet, nNumFac, , , , ( dbfFacPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

      end






      if lPago

         nOrd           := ( dbfFacPrvP )->( ordSetFocus( "nNumFac" ) )

         if ( dbfFacPrvP )->( dbSeek( nFactura ) )

            while ( ( dbfFacPrvP )->cSerFac + Str( ( dbfFacPrvP )->nNumFac ) + ( dbfFacPrvP )->cSufFac = nFactura ) .AND. !( dbfFacPrvP )->( eof() )

               lReturn  := CntRecPrv( lSimula, oTree, nAsiento, aSimula, .T., dbfFacPrvT, dbfFacPrvP, dbfPrv, dbfFPago, dbfDiv )

               if IsFalse( lReturn )
                  exit
               end

               ( dbfFacPrvP )->( dbSkip() )

            end

         end

         ( dbfFacPrvP )->( ordSetFocus( nOrd ) )

      end





      if lSimula

         if lMessage
            lReturn  := msgTblCon( aSimula, cCodDiv, dbfDiv, !lErrorFound, cFactura, {|| aWriteAsiento( aSimula, cCodDiv, .T., oTree, cFactura, nAsiento ), lCntFacPrv( .T., dbfFacPrvT ) } )
         end

      else

         if !lErrorFound

            lReturn  := lCntFacPrv( .T., dbfFacPrvT )

            if lReturn .AND. !Empty( oTree )
               oTree:Select( oTree:Add( "Factura proveedor : " + Rtrim( cFactura ) + " asiento generado num. " + Alltrim( Str( nAsiento ) ), 1 ) )
            end

         end

      end

      CloseDiario()

   end

Return ( lReturn )



Function lCntFacPrv( lContabilizado, dbfFacPrvT )

   local lReturn              := .T.

   if dbLock( dbfFacPrvT )
      ( dbfFacPrvT )->lContab := lContabilizado
      ( dbfFacPrvT )->( dbUnlock() )
   else
      lReturn                 := .F.
   end

Return ( lReturn )



FUNCTION CntRctPrv( lSimula, lPago, lMessage, oTree, nAsiento, aSimula, dbfRctPrvT, dbfRctPrvL, dbfFacPrvP, dbfPrv, dbfDiv, dbfArticulo, dbfFPago, dbfIva, oBrw )

    local n
    local cCtaVent
    local nPosicion
    local nPosIva
    local dFecha
   local aTotFac
   local nTotFac
   local nTotRet
    local cConcepto
   local cConCompr
    local cSubCtaIva
    local cSubCtaReq
   local cRuta
   local cCodEmp
   local nImpDeta
   local nDinDiv     := nDinDiv( ( dbfRctPrvT )->cDivFac, dbfDiv )
   local nRinDiv     := nRinDiv( ( dbfRctPrvT )->cDivFac, dbfDiv )
   local aIva        := {}
    local aVentas        := {}
   local cCodDiv     := ( dbfRctPrvT )->cDivFac
   local cCtaPrv     := cPrvCta( ( dbfRctPrvT )->cCodPrv, dbfPrv )
   local cCtaPrvVta  := cPrvCtaVta( ( dbfRctPrvT )->cCodPrv, dbfPrv )
   local nFactura    := ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac
   local cFactura    := ( dbfRctPrvT )->cSerFac + "/" + Ltrim( Str( ( dbfRctPrvT )->nNumFac ) ) + "/" + ( dbfRctPrvT )->cSufFac
   local nNumFac     := ( dbfRctPrvT )->nNumFac
   local cCodPro     := Left( ( dbfRctPrvT )->cCodPro, 3 )
   local cClave      := Right( ( dbfRctPrvT )->cCodPro, 6 )
   local lErrorFound := .F.
   local cTerNif     := ( dbfRctPrvT )->cDniPrv
   local cTerNom     := ( dbfRctPrvT )->cNomPrv
   local lReturn

   IIF( aSimula == nil, aSimula := {}, ) ;





   IF ( dbfRctPrvT )->lContab
      oTree:Add( "Factura rectificativa proveedor : " + Rtrim( cFactura ) + " ya contabilizada.", 0 )
      lErrorFound    := .T.
   end

   IF !ChkRuta( cRutCnt() )
      oTree:Add( "Factura rectificativa proveedor : " + rtrim( cFactura ) + " ruta no valida.", 0 )
      lErrorFound    := .T.
   end





   cRuta             := cRutCnt()
   cCodEmp           := cCodEmpCnt( ( dbfRctPrvT )->cSerFac )

   if Empty( cCtaPrvVta )
      cCtaPrvVta     := cCtaPrv()
   end

   if !ChkSubCta( cRutCnt(), cCodEmp, cCtaPrv, , .F., .F. )
      oTree:Add( "Factura rectificativa proveedor : " + rtrim( cFactura ) + " subcuenta " + cCtaPrv + " no encontada.", 0 )
      lErrorFound    := .T.
   end





   aTotFac           := aTotRctPrv( nFactura, dbfRctPrvT, dbfRctPrvL, dbfIva, dbfDiv, dbfFacPrvP )
   nTotFac           := aTotFac[ 4 ]
   nTotRet           := aTotFac[ 6 ]





   if ( dbfRctPrvL )->( dbSeek( nFactura ) )

      while ( ( dbfRctPrvL )->cSerFac + Str( ( dbfRctPrvL )->nNumFac ) + ( dbfRctPrvL )->cSufFac == nFactura .AND. !( dbfRctPrvL )->( eof() ) )

         nImpDeta    := nTotLRctPrv( dbfRctPrvL, nDinDiv, nRinDiv, ( dbfRctPrvT )->nVdvFac )

         if nImpDeta <> 0

            cCtaVent := RetCtaCom( ( dbfRctPrvL )->cRef, dbfArticulo )
            if Empty( cCtaVent )
               cCtaVent := cCtaPrvVta + RetGrpVta( ( dbfRctPrvL )->cRef, cRuta, cCodEmp, dbfArticulo, ( dbfRctPrvL )->nIva )
            end

            nPosicion   := aScan( aVentas, {|x| x[1] == cCtaVent } )
            if nPosicion == 0
               aadd( aVentas, { cCtaVent, nImpDeta } )
            else
               aVentas[ nPosicion, 2 ] += nImpDeta
            end





            if ( dbfRctPrvT )->nRegIva == 2
               cSubCtaIva  := uFieldEmpresa( "cCtaCeeRpt" )
               cSubCtaReq  := uFieldEmpresa( "cCtaCeeSpt" )
            else
               cSubCtaIva  := cSubCuentaIva( ( dbfRctPrvL )->nIva, ( dbfRctPrvT )->lRecargo, cRuta, cCodEmp, dbfIva, .F. )
               cSubCtaReq  := cSubCuentaRecargo( ( dbfRctPrvL )->nIva, ( dbfRctPrvT )->lRecargo, cRuta, cCodEmp, dbfIva )
            end

            nPosIva     := aScan( aIva, {|x| x[1] == ( dbfRctPrvL )->nIva } )
            if nPosIva == 0
               aadd( aIva, { ( dbfRctPrvL )->nIva, cSubCtaIva, cSubCtaReq, nImpDeta } )
            else
               aIva[ nPosIva, 4 ]   += nImpDeta
            end

         end

         ( dbfRctPrvL )->( dbSkip() )

      end

   else

      oTree:Add( "Factura rectificativa proveedor : " + rtrim( cFactura ) + " factura sin artículos.", 0 )
      lErrorFound    := .T.

   end





   for n := 1 to Len( aVentas )

      if ( dbfRctPrvT )->nDtoEsp <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfRctPrvT )->nDtoEsp / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDpp <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfRctPrvT )->nDpp / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDtoUno <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfRctPrvT )->nDtoUno / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDtoDos <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfRctPrvT )->nDtoDos / 100, nRinDiv )
      end

   next





   for n := 1 to Len( aIva )

      if ( dbfRctPrvT )->nDtoEsp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfRctPrvT )->nDtoEsp / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDpp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfRctPrvT )->nDpp / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDtoUno <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfRctPrvT )->nDtoUno / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDtoDos <> 0
         aIva[ n, 2 ] -= Round( aIva[ n, 4 ] * ( dbfRctPrvT )->nDtoDos / 100, nRinDiv )
      end

   next





   for n := 1 to len( aVentas )

      if !ChkSubCta( cRutCnt(), cCodEmp, aVentas[ n, 1 ], , .F., .F. )

         oTree:Add( "Factura rectificativa proveedor : " + rtrim( cFactura ) + " subcuenta " + aVentas[ n, 1 ] + " no encontada.", 0 )
         lErrorFound    := .T.

      end

   next





   for n := 1 to len( aIva )

      if !ChkSubCta( cRuta, cCodEmp, aIva[ n, 2 ], , .F., .F. )
         oTree:Add( "Factura rectificativa proveedor : " + Rtrim( cFactura ) + " subcuenta " + aIva[ n, 2 ] + " no encontada.", 0 )
         lErrorFound    := .T.
      end

      if !ChkSubCta( cRuta, cCodEmp, aIva[ n, 3 ], , .F., .F. )
         oTree:Add( "Factura rectificativa proveedor : " + Rtrim( cFactura ) + " subcuenta " + aIva[ n, 3 ] + " no encontada.", 0 )
         lErrorFound    := .T.
      end

   next

   if nTotRet <> 0

      if !ChkSubCta( cRuta, cCodEmp, cCtaRet(), , .F., .F. )
         oTree:Add( "Factura rectificativa proveedor : " + Rtrim( cFactura ) + " subcuenta " + cCtaRet() + " no encontada.", 0 )
         lErrorFound    := .T.
      end

   end





   if !ChkFecha( , , ( dbfRctPrvT )->dFecFac, .F., oTree )
      lErrorFound    := .T.
   end





   if lSimula .OR. !lErrorFound

      if Empty( ( dbfRctPrvT )->dFecEnt )
         dFecha      := ( dbfRctPrvT )->dFecFac
      else
         dFecha      := ( dbfRctPrvT )->dFecEnt
      end

      cConCompr      := "S/Rect."
      if !Empty( ( dbfRctPrvT )->cSuPed )
         nNumFac     := Val( ( dbfRctPrvT )->cSuPed )
         cConCompr   += " N." + Rtrim( ( dbfRctPrvT )->cSuPed )
      elseif !Empty( ( dbfRctPrvT )->cNumDoc )
         cConCompr   += " Doc. " + Rtrim( ( dbfRctPrvT )->cNumDoc )
      else
         cConCompr   += " N." + Rtrim( cFactura )
      end
      cConcepto      := cConCompr + Space( 1 ) + DtoC( ( dbfRctPrvT )->dFecFac )
      cConCompr      += Space( 1 ) + Rtrim( ( dbfRctPrvT )->cNomPrv )





      if OpenDiario( , cCodEmp )
         nAsiento    := RetLastAsi()
      else
         oTree:Add( "Factura rectificativa proveedor : " + Rtrim( cFactura ) + " imposible abrir ficheros de contaplus.", 0 )
         return .F.
      end

























      aAdd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaPrv, , , cConcepto, nTotFac, nNumFac, , , , ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )





      for n := 1 TO len( aVentas )





















         aAdd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, aVentas[ n, 1 ], , aVentas[ n, 2 ], cConCompr, , nNumFac, , , , ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next

      if ( dbfRctPrvT )->nRegIva == 2

      for n := 1 to len( aIva )





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha,  aIva[ n, 3 ], aIva[ n, 2 ], Round( aIva[ n, 1 ] * aIva[ n, 4 ] / 100, nRinDiv ), cConCompr, Round( aIva[ n, 1 ] * aIva[ n, 4 ] / 100, nRinDiv ), nNumFac, aIva[ n, 4 ], aIva[ n, 1 ], If( ( dbfRctPrvT )->lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), 0 ), ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next

      else





      for n := 1 TO len( aIva )





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha,  aIva[ n, 2 ], cCtaPrv, Round( aIva[ n, 1 ] * aIva[ n, 4 ] / 100, nRinDiv ), cConCompr, , nNumFac, aIva[ n, 4 ], aIva[ n, 1 ], If( ( dbfRctPrvT )->lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), 0 ), ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next





      if ( dbfRctPrvT )->lRecargo

         for n := 1 TO len( aIva )





















            aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, aIva[ n, 3 ], , Round( nPReq( dbfIva, aIva[ n, 1 ] ) * aIva[ n, 4 ] / 100, nRinDiv ), cConCompr, , nNumFac, , , , ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

         next

      end

      end





      if nTotRet <> 0





















         aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaRet(), , , cConCompr, nTotRet, nNumFac, , , , ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

      end






      if lPago .AND. ( dbfFacPrvP )->( dbSeek( nFactura ) )


         while ( ( dbfFacPrvP )->cSerFac + Str( ( dbfFacPrvP )->nNumFac ) + ( dbfFacPrvP )->cSufFac == nFactura ) .AND. !( dbfFacPrvP )->( eof() )

            lReturn  := CntRecPrv( lSimula, oTree, nAsiento, aSimula, .T., dbfRctPrvT, dbfFacPrvP, dbfPrv, dbfFPago, dbfDiv )

            if IsFalse( lReturn )
               exit
            end

            ( dbfFacPrvP )->( dbSkip() )

         end

      end





      if lSimula

         if lMessage
            lReturn  := msgTblCon( aSimula, cCodDiv, dbfDiv, !lErrorFound, cFactura, {|| aWriteAsiento( aSimula, cCodDiv, .T., oTree, cFactura, nAsiento ), lCntRctPrv( .T., dbfRctPrvT ) } )
         end

      else

         if !lErrorFound

            lReturn  := lCntRctPrv( .T., dbfRctPrvT )

            if lReturn .AND. !Empty( oTree )
               oTree:Add( "Factura rectificativa proveedor : " + Rtrim( cFactura ) + " asiento generado num. " + Alltrim( Str( nAsiento ) ), 1 )
            end

         end

      end

      CloseDiario()

   end

Return ( lReturn )



Function lCntRctPrv( lContabilizado, dbfRctPrvT )

   local lReturn              := .T.

   if dbLock( dbfRctPrvT )
      ( dbfRctPrvT )->lContab := lContabilizado
      ( dbfRctPrvT )->( dbUnlock() )
   else
      lReturn                 := .F.
   end

Return ( lReturn )



Function CntRecPrv( lSimula, oTree, nAsiento, aSimula, lFromFactura, dbfFacPrvT, dbfFacPrvP, dbfPrv, dbfFPago, dbfDiv, oBrw )

   local cCodEmp
   local cRuta
   local cConcepto
   local cPagoPrv
   local cCtaPgo
   local dFecha
   local nRecno      := ( dbfFacPrvP )->( Recno() )
   local cCodDiv     := ( dbfFacPrvP )->cDivPgo
   local cCodPgo     := ( dbfFacPrvP )->cCodPgo
   local lConFac     := lConFacPrv( ( dbfFacPrvP )->cSerFac + Str( ( dbfFacPrvP )->nNumFac, 9 ) + ( dbfFacPrvP )->cSufFac, dbfFacPrvT )
   local cCodPrv     := dPrvFacPrv( ( dbfFacPrvP )->cSerFac + Str( ( dbfFacPrvP )->nNumFac, 9 ) + ( dbfFacPrvP )->cSufFac, dbfFacPrvT )
   local cCodPro     := cProFacPrv( ( dbfFacPrvP )->cSerFac + Str( ( dbfFacPrvP )->nNumFac, 9 ) + ( dbfFacPrvP )->cSufFac, dbfFacPrvT )
   local cCtaPrv     := cPrvCta( cCodPrv, dbfPrv )
   local cFactura    := ( dbfFacPrvP )->cSerFac + "/" + Ltrim( Str( ( dbfFacPrvP )->nNumFac ) ) + "/" + ( dbfFacPrvP )->cSufFac
   local nRecibo     := ( dbfFacPrvP )->cSerFac + Str( ( dbfFacPrvP )->nNumFac, 9 ) + ( dbfFacPrvP )->cSufFac + Str( ( dbfFacPrvP )->nNumRec )
   local cRecibo     := ( dbfFacPrvP )->cSerFac + "/" + Ltrim( Str( ( dbfFacPrvP )->nNumFac, 9 ) ) + "/" + ( dbfFacPrvP )->cSufFac + "-" + Str( ( dbfFacPrvP )->nNumRec )
   local cTerNif     := RetFld( ( dbfFacPrvP )->cSerFac + Str( ( dbfFacPrvP )->nNumFac, 9 ) + ( dbfFacPrvP )->cSufFac, dbfFacPrvT, "cDniPrv" )
   local cTerNom     := ( dbfFacPrvP )->cNomPrv
   local lRectif     := !Empty( ( dbfFacPrvP )->cTipRec )
   local lErrorFound := .F.
   local lReturn     := .T.






   cRuta             := cRutCnt()
   cCodEmp           := cCodEmpCnt( ( dbfFacPrvP )->cSerFac )

   if !lFromFactura

      if OpenDiario( , cCodEmp )
         nAsiento          := RetLastAsi()
      else
         oTree:Select( oTree:Add( "Recibo : " + Rtrim( cRecibo ) + " imposible abrir ficheros de contaplus.", 0 ) )
         Return .F.
      end

   end






   if ( dbfFacPrvP )->lConPgo
      oTree:Select( oTree:Add( "Recibo proveedor : " + rtrim( cRecibo ) + " ya contabilizado.", 0 ) )
      lErrorFound    := .T.
   end

   if !( dbfFacPrvP )->lCobrado
      oTree:Select( oTree:Add( "Recibo proveedor : " + rtrim( cRecibo ) + " no cobrado.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkRuta( cRutCnt() )
      oTree:Select( oTree:Add( "Recibo proveedor : " + rtrim( cRecibo ) + " ruta no valida.", 0 ) )
      lErrorFound    := .T.
   end

   if !lConFac .AND. !lFromFactura
      oTree:Select( oTree:Add( "Factura de Recibo proveedor : " + rtrim( cRecibo ) + " no contabilizada.", 0 ) )
      lErrorFound    := .T.
   end

   if Empty( cCodEmp )
      oTree:Select( oTree:Add( "Recibo proveedor : " + rtrim( cRecibo ) + " no se definieron empresas asociadas.", 0 ) )
      lErrorFound    := .T.
   end






   if !ChkSubCta( cRuta, cCodEmp, cCtaPrv, , .F., .F. )
      oTree:Select( oTree:Add( "Recibo proveedor : " + rtrim( cRecibo ) + " subcuenta " + cCtaPrv + " no encontada.", 0 ) )
      lErrorFound    := .T.
   end






   if Empty( cCodPgo )
      cCodPgo        := cPgoFacPrv( ( dbfFacPrvP )->cSerFac + Str( ( dbfFacPrvP )->nNumFac, 9 ) + ( dbfFacPrvP )->cSufFac, dbfFacPrvT )
   end

   cCtaPgo           := ( dbfFacPrvP )->cCtaRec

   if Empty( cCtaPgo )
      cCtaPgo        := cCtaFPago( cCodPgo, dbfFPago )
   end

   if Empty( cCtaPgo )
      oTree:Select( oTree:Add( "Recibo proveedor : " + rtrim( cRecibo ) + " no existe cuenta de pago.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkSubCta( cRutCnt(), cCodEmp, cCtaPgo, , .F., .F. )
      oTree:Select( oTree:Add( "Recibo proveedor : " + rtrim( cRecibo ) + " subcuenta " + rtrim( cCtaPgo ) + " no encontada.", 0 ) )
      lErrorFound    := .T.
   end






   if Empty( ( dbfFacPrvP )->dEntrada )
      if dbLock( dbfFacPrvP )
         ( dbfFacPrvP )->dEntrada := date()
         ( dbfFacPrvP )->( dbUnLock() )
      end
   end

   if !ChkFecha( , , ( dbfFacPrvP )->dEntrada, .F., oTree )
      lErrorFound    := .T.
   end






   dFecha            := ( dbfFacPrvP )->dEntrada

   cConcepto         := "P/Recibo N." + Alltrim( Str( ( dbfFacPrvP )->nNumRec ) ) + Space( 1 )

   if !Empty( ( dbfFacPrvT )->cSuPed )

      cConcepto      += "S/Fcta. N." + Rtrim( ( dbfFacPrvT )->cSuPed )

   elseif !Empty( ( dbfFacPrvT )->cNumDoc )

      cConcepto      += "Doc. N." + Rtrim( ( dbfFacPrvT )->cNumDoc )

   else

      cConcepto      += "N/Fcta. N." + Rtrim( cFactura )

   end

   cConcepto         += Space( 1 ) + Rtrim( ( dbfFacPrvT )->cNomPrv )








   if !lFromFactura
      nAsiento    := RetLastAsi()
   end






   if ( dbfFacPrvP )->( dbSeek( nRecibo ) )





















      aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha,  cCtaPgo, , , cConcepto, ( dbfFacPrvP )->nImporte, , , , , , cCodPro, , , , , lSimula, cTerNif, cTerNom ) )

























      aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha,  cCtaPrv, , ( dbfFacPrvP )->nImporte, cConcepto, , , , , , , cCodPro, , , , , lSimula, cTerNif, cTerNom ) )

      if ( !lSimula .AND. !lErrorFound )
         lReturn     := lCntRecPrv( cRecibo, nAsiento, lFromFactura, oTree, dbfFacPrvP )
      end

      if ( lSimula .AND. !lFromFactura )
         lReturn     := msgTblCon( aSimula, cCodDiv, dbfDiv, !lErrorFound, cRecibo, {|| aWriteAsiento( aSimula, cCodDiv, .T., oTree, cRecibo, nAsiento ), lCntRecPrv( cRecibo, nAsiento, lFromFactura, oTree, dbfFacPrvP ) } )
      end

   end

   if !lFromFactura
      CloseDiario()
   end

   if !Empty( oBrw )
      oBrw:Refresh()
   end

   ( dbfFacPrvP )->( dbGoTo( nRecno ) )

Return ( lReturn )



Function lCntRecPrv( cRecibo, nAsiento, lFromFactura, oTree, dbfFacPrvP )

   local lReturn  := .F.

   if dbLock( dbfFacPrvP )
      ( dbfFacPrvP )->lConPgo  := .T.
      ( dbfFacPrvP )->( dbUnLock() )

      lReturn     := .T.
   end

   if !lFromFactura
      oTree:Select( oTree:Add( "Recibo proveedor : " + Rtrim( cRecibo ) + " asiento generado num. " + Alltrim( Str( nAsiento ) ), 1 ) )
   end

RETURN ( lReturn )
