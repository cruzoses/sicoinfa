#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 123 ".\Prg\Xbrowse.prg"
static lExcelInstl, lCalcInstl
static nxlLangID, cxlTrue := "=(1=1)", cxlFalse := "=(1=0)", cxlSum, cxlSubTotal, lxlEnglish := .F., hLib

static bXBrowse



_HB_CLASS TXBrowse ; UTILITY FUNCTION TXBrowse(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TXBrowse" , {TControl():classh} ) ) ; ;





   _HB_MEMBER { oVScroll, oHScroll, oCapCol, oSeek, oDbf} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oVScroll" , "oHScroll" , "oCapCol" , "oSeek" , "oDbf" }, .F., .F. ), )




   _HB_MEMBER { aCols, aDisplay, aSelected, aArrayData} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aCols" , "aDisplay" , "aSelected" , "aArrayData" }, .F., .F. ), )

   _HB_MEMBER { aSortBmp} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aSortBmp" }, .F., .F. ), )




















   _HB_MEMBER { bGoTop, bGoBottom, bSkip,  bBof, bEof, bKeyNo,    bKeyCount, bBookMark,    bSeek,  bPastEof} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bGoTop" , "bGoBottom" , "bSkip" , "bBof" , "bEof" , "bKeyNo" , "bKeyCount" , "bBookMark" , "bSeek" , "bPastEof" }, .F., .F. ), )
   _HB_MEMBER { bPopUp} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bPopUp" }, .F., .F. ), )









   _HB_MEMBER { bClrHeader, bClrFooter, bClrGrad,   bClrStd, bClrSel, bClrSelFocus, bClrRowFocus} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bClrHeader" , "bClrFooter" , "bClrGrad" , "bClrStd" , "bClrSel" , "bClrSelFocus" , "bClrRowFocus" }, .F., .F. ), )

   _HB_MEMBER { bColClass} ; IIF( !.F., s_oClass:AddMultiData(, { || TxBrwColumn() }, nScope + IIF( .F., 32, 0 ), { "bColClass" }, .F., .F. ), )



   _HB_MEMBER {AS CHARACTER cAlias, cSeek} ; IIF( !.F., s_oClass:AddMultiData( "CHARACTER",, nScope + IIF( .F., 32, 0 ), { "cAlias" , "cSeek" }, .F., .F. ), )





   _HB_MEMBER {AS NUMERIC nRowSel, nColSel, nFreeze, nColOffset} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nRowSel" , "nColSel" , "nFreeze" , "nColOffset" }, .F., .F. ), )




   _HB_MEMBER {AS NUMERIC nHeaderLines, nFooterLines, nDataLines} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nHeaderLines" , "nFooterLines" , "nDataLines" }, .F., .F. ), )


   _HB_MEMBER {AS NUMERIC nDataType} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nDataType" }, .F., .F. ), )





   _HB_MEMBER { nHeaderHeight, nFooterHeight, nRowHeight, nRecSelColor} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nHeaderHeight" , "nFooterHeight" , "nRowHeight" , "nRecSelColor" }, .F., .F. ), )



   _HB_MEMBER {AS NUMERIC nRowDividerStyle, nColDividerStyle} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nRowDividerStyle" , "nColDividerStyle" }, .F., .F. ), )








   _HB_MEMBER {AS NUMERIC nMarqueeStyle} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nMarqueeStyle" }, .F., .F. ), )








   _HB_MEMBER {AS NUMERIC nMoveType} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nMoveType" }, .F., .F. ), )











   _HB_MEMBER {AS NUMERIC nLen, nDataRows, nCaptured, nArrayAt, nLastEditCol} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nLen" , "nDataRows" , "nCaptured" , "nArrayAt" , "nLastEditCol" }, .F., .F. ), )


   _HB_MEMBER {AS NUMERIC nVScrollPos} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nVScrollPos" }, .F., .F. ), )

   _HB_MEMBER {AS NUMERIC nRecSelWidth} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 25, nScope + IIF( .F., 32, 0 ), { "nRecSelWidth" }, .F., .F. ), )






   _HB_MEMBER { hBtnShadowPen, hWhitePen, hColPen, hRowPen, hBmpRecSel, hBrushRecSel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "hBtnShadowPen" , "hWhitePen" , "hColPen" , "hRowPen" , "hBmpRecSel" , "hBrushRecSel" }, .F., .F. ), )

















   _HB_MEMBER {AS LOGICAL lCreated, lAdjusted, lRecordSelector, lHScroll, lVScroll, lAllowRowSizing, lAllowColSwapping, lAllowColHiding, lColDividerComplete,  lFastEdit,   lEditMode, lEdit, lRefreshOnlyData, l2007} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL",, nScope + IIF( .F., 32, 0 ), { "lCreated" , "lAdjusted" , "lRecordSelector" , "lHScroll" , "lVScroll" , "lAllowRowSizing" , "lAllowColSwapping" , "lAllowColHiding" , "lColDividerComplete" , "lFastEdit" , "lEditMode" , "lEdit" , "lRefreshOnlyData" , "l2007" }, .F., .F. ), )


   _HB_MEMBER { hMultiSelect} ; IIF( !.F., s_oClass:AddMultiData(,, 4 + IIF( .F., 32, 0 ), { "hMultiSelect" }, .F., .F. ), )

   _HB_MEMBER lMultiSelect(); IIF( .F., s_oClass:ModInline( "lMultiSelect", {|Self | Self, IfNil( ::hMultiSelect, ( ::nMarqueeStyle == 6 .OR.  ::nMarqueeStyle == 7 ) ) }, 1, .F. ), s_oClass:AddInline( "lMultiSelect", {|Self | Self, IfNil( ::hMultiSelect, ( ::nMarqueeStyle == 6 .OR.  ::nMarqueeStyle == 7 ) ) }, 1, .F. ) )
   _HB_MEMBER _lMultiSelect(lSet); IIF( .F., s_oClass:ModInline( "_lMultiSelect", {|Self,lSet | Self, ( ::hMultiSelect := lSet ) }, 1 ), s_oClass:AddInline( "_lMultiSelect", {|Self,lSet | Self, ( ::hMultiSelect := lSet ) }, 1 ) )


   _HB_MEMBER {AS LOGICAL lFormulaEdit} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lFormulaEdit" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lEnterKey2Edit} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .T., nScope + IIF( .F., 32, 0 ), { "lEnterKey2Edit" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lF2KeyToEdit} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lF2KeyToEdit" }, .F., .F. ), )


   _HB_MEMBER {AS LOGICAL lSeekWild} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lSeekWild" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lIncrFilter} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lIncrFilter" }, .F., .F. ), )
   _HB_MEMBER { bFilterExp} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bFilterExp" }, .F., .F. ), )
   _HB_MEMBER { cFilterFld} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cFilterFld" }, .F., .F. ), )


   _HB_MEMBER {AS LOGICAL lVThumbTrack} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lVThumbTrack" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lColChangeNotify} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lColChangeNotify" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lAutoSort} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lAutoSort" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lAllowCopy} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .T., nScope + IIF( .F., 32, 0 ), { "lAllowCopy" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lCanPaste} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lCanPaste" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lExcelCellWise} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lExcelCellWise" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lMergeVert} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lMergeVert" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lExitGetOnTypeOut} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lExitGetOnTypeOut" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lOemAnsi} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lOemAnsi" }, .F., .F. ), )

   _HB_MEMBER {AS LOGICAL lAutoAppend} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .T., nScope + IIF( .F., 32, 0 ), { "lAutoAppend" }, .F., .F. ), )



   _HB_MEMBER { lHeader, lFooter, lGrpHeader} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lHeader" , "lFooter" , "lGrpHeader" }, .F., .F. ), )
   _HB_MEMBER { lAllowColReGroup} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lAllowColReGroup" }, .F., .F. ), )
   _HB_MEMBER { lDisplayZeros} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lDisplayZeros" }, .F., .F. ), )

   _HB_MEMBER { nSaveMarq} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nSaveMarq" }, .F., .F. ), )
   _HB_MEMBER { oRS} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oRS" }, .F., .F. ), )
   _HB_MEMBER { oMysql} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oMysql" }, .F., .F. ), )
   _HB_MEMBER { oTree, oTreeItem} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oTree" , "oTreeItem" }, .F., .F. ), )
   _HB_MEMBER { oColToolTip} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oColToolTip" }, .F., .F. ), )
   _HB_MEMBER { bOnRowLeave} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnRowLeave" }, .F., .F. ), )
   _HB_MEMBER { bOnSkip} ; IIF( !.F., s_oClass:AddMultiData(, { || nil }, nScope + IIF( .F., 32, 0 ), { "bOnSkip" }, .F., .F. ), )
   _HB_MEMBER { lEdited} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lEdited" }, .F., .F. ), )
   _HB_MEMBER { bLock} ; IIF( !.F., s_oClass:AddMultiData(, { || .T. }, nScope + IIF( .F., 32, 0 ), { "bLock" }, .F., .F. ), )
   _HB_MEMBER { bUnLock} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bUnLock" }, .F., .F. ), )
   _HB_MEMBER { aStretchInfo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aStretchInfo" }, .F., .F. ), )
   _HB_MEMBER { nStretchCol} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nStretchCol" }, .F., .F. ), )
   _HB_MEMBER { bOnSwapCol} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnSwapCol" }, .F., .F. ), )
   _HB_MEMBER { nRightMargin} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nRightMargin" }, .F., .F. ), )
   _HB_MEMBER { nBottomMargin} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nBottomMargin" }, .F., .F. ), )



   _HB_MEMBER { aHeaderTop, nHeader} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aHeaderTop" , "nHeader" }, .F., .F. ), )

   _HB_MEMBER { lContrastClr} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lContrastClr" }, .F., .F. ), )







   _HB_MEMBER { nStartMRow, nEndMRow, nRowAdvance, nColAdvance, nStartTime, nEllapsed} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nStartMRow" , "nEndMRow" , "nRowAdvance" , "nColAdvance" , "nStartTime" , "nEllapsed" }, .F., .F. ), )

   _HB_MEMBER { lDown} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lDown" }, .F., .F. ), )
   _HB_MEMBER { lPressed} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lPressed" }, .F., .F. ), )
   _HB_MEMBER { lMoved} ; IIF( !.F., s_oClass:AddMultiData(, .F., 4 + IIF( .F., 32, 0 ), { "lMoved" }, .F., .F. ), )


   _HB_MEMBER { aBitmaps} ; IIF( !.F., s_oClass:AddMultiData(, Array( 0 ), nScope + IIF( .F., 32, 0 ), { "aBitmaps" }, .F., .F. ), )

   _HB_MEMBER {AS NUMERIC nStopRatio} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 4, nScope + IIF( .F., 32, 0 ), { "nStopRatio" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nMaxRowToAdvance} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 40, nScope + IIF( .F., 32, 0 ), { "nMaxRowToAdvance" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nMinVelocity} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 50, nScope + IIF( .F., 32, 0 ), { "nMinVelocity" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lDrawSelected} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .T., nScope + IIF( .F., 32, 0 ), { "lDrawSelected" }, .F., .F. ), )
   _HB_MEMBER { hCursorHand} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "hCursorHand" }, .F., .F. ), )

   _HB_MEMBER {AS LOGICAL lKineticBrw} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .T., nScope + IIF( .F., 32, 0 ), { "lKineticBrw" }, .F., .F. ), )

   _HB_MEMBER { nSizePen} ; IIF( !.F., s_oClass:AddMultiData(, 1, nScope + IIF( .F., 32, 0 ), { "nSizePen" }, .F., .F. ), )
   _HB_MEMBER { nColorPen} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nColorPen" }, .F., .F. ), )

   _HB_MEMBER {AS LOGICAL lKinetic} ; IIF( !.F., s_oClass:AddMultiClsData("LOGICAL", SetKinetic(), nScope + IIF( .F., 32, 0 ) + 64, { "lKinetic" }, .F. ), )

   _HB_MEMBER {AS LOGICAL lRegistered} ; IIF( !.F., s_oClass:AddMultiClsData("LOGICAL",, nScope + IIF( .F., 32, 0 ) + 64, { "lRegistered" }, .F. ), )

   _HB_MEMBER New( oWnd); IIF( .F., s_oClass:ModMethod( "New", @TXBrowse_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TXBrowse_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Destroy(); IIF( .F., s_oClass:ModMethod( "Destroy", @TXBrowse_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Destroy", @TXBrowse_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nAt(); IIF( .F., s_oClass:ModInline( "nAt", {|Self | Self, ::colpos( ::SelectedCol() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "nAt", {|Self | Self, ::colpos( ::SelectedCol() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER EraseBkGnd(hDC); IIF( .F., s_oClass:ModInline( "EraseBkGnd", {|Self,hDC | Self, 1 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "EraseBkGnd", {|Self,hDC | Self, 1 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetRDD( lAddColumns, lAutoSort, aFldNames, aRows); IIF( .F., s_oClass:ModMethod( "SetRDD", @TXBrowse_SetRDD(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetRDD", @TXBrowse_SetRDD(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetArray( aData, lAutoSort, nColOrder, aCols, bOnSkip); IIF( .F., s_oClass:ModMethod( "SetArray", @TXBrowse_SetArray(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetArray", @TXBrowse_SetArray(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetoDbf( oDbf, aCols, lAutoSort, lAutoCols, aRows); IIF( .F., s_oClass:ModMethod( "SetoDbf", @TXBrowse_SetoDbf(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetoDbf", @TXBrowse_SetoDbf(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetExcelRange( oRange, lHeaders, aCols); IIF( .F., s_oClass:ModMethod( "SetExcelRange", @TXBrowse_SetExcelRange(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetExcelRange", @TXBrowse_SetExcelRange(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetAdo( oRs, lAddCols, lAutoOrder, aFldNames); IIF( .F., s_oClass:ModMethod( "SetAdo", @TXBrowse_SetAdo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetAdo", @TXBrowse_SetAdo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetTree( oTree, aResource, bOnSkip); IIF( .F., s_oClass:ModMethod( "SetTree", @TXBrowse_SetTree(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetTree", @TXBrowse_SetTree(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GetColsData( cData, lByCreationOrder); IIF( .F., s_oClass:ModMethod( "GetColsData", @TXBrowse_GetColsData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetColsData", @TXBrowse_GetColsData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetColsData( cData, aValues, lByCreationOrder); IIF( .F., s_oClass:ModMethod( "SetColsData", @TXBrowse_SetColsData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetColsData", @TXBrowse_SetColsData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetGroupHeader( cGrpHdr, nFrom, nUpto, oFont); IIF( .F., s_oClass:ModMethod( "SetGroupHeader", @TXBrowse_SetGroupHeader(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetGroupHeader", @TXBrowse_SetGroupHeader(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetGroupTotal( aCols, cHead, nType, oFont); IIF( .F., s_oClass:ModMethod( "SetGroupTotal", @TXBrowse_SetGroupTotal(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetGroupTotal", @TXBrowse_SetGroupTotal(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ClearBlocks(); IIF( .F., s_oClass:ModMethod( "ClearBlocks", @TXBrowse_ClearBlocks(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ClearBlocks", @TXBrowse_ClearBlocks(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetColFromADO( cnCol, lAutoOrder); IIF( .F., s_oClass:ModMethod( "SetColFromADO", @TXBrowse_SetColFromADO(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetColFromADO", @TXBrowse_SetColFromADO(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ArrCell( nRow, nCol, cFmt); IIF( .F., s_oClass:ModMethod( "ArrCell", @TXBrowse_ArrCell(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ArrCell", @TXBrowse_ArrCell(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ArrCellSet( nRow, nCol, uNewVal); IIF( .F., s_oClass:ModMethod( "ArrCellSet", @TXBrowse_ArrCellSet(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ArrCellSet", @TXBrowse_ArrCellSet(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetDolphin( oMysql, lAddCols, lAutoOrder, aFldNames); IIF( .F., s_oClass:ModMethod( "SetDolphin", @TXBrowse_SetDolphin(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetDolphin", @TXBrowse_SetDolphin(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetMySql( oMysql, lAddCols, lAutoOrder, aFldNames); IIF( .F., s_oClass:ModMethod( "SetMySql", @TXBrowse_SetMySql(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetMySql", @TXBrowse_SetMySql(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetColFromMySQL( cnCol, cHeader); IIF( .F., s_oClass:ModMethod( "SetColFromMySQL", @TXBrowse_SetColFromMySQL(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetColFromMySQL", @TXBrowse_SetColFromMySQL(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER aJustify(aJust); _HB_MEMBER _aJustify(aJust); IIF( .F., s_oClass:ModMethod( "aJustify", @TXBrowse_aJustify(), 1 + 32, .F. ), s_oClass:AddMethod( "aJustify", @TXBrowse_aJustify(), 1 + 32, .F. ) ) ; IIF( .F., s_oClass:ModMethod( "_aJustify", @TXBrowse_aJustify() ), s_oClass:AddMethod( "_aJustify", @TXBrowse_aJustify() ) ) ;

   _HB_MEMBER AddCol(); IIF( .F., s_oClass:ModMethod( "AddCol", @TXBrowse_AddCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AddCol", @TXBrowse_AddCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER InsCol( nPos); IIF( .F., s_oClass:ModMethod( "InsCol", @TXBrowse_InsCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "InsCol", @TXBrowse_InsCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DelCol( nPos); IIF( .F., s_oClass:ModMethod( "DelCol", @TXBrowse_DelCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DelCol", @TXBrowse_DelCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER AddColumn(); IIF( .F., s_oClass:ModMethod( "AddColumn", @TXBrowse_AddColumn(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AddColumn", @TXBrowse_AddColumn(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SwapCols( xCol1, xCol2, lRefresh); IIF( .F., s_oClass:ModMethod( "SwapCols", @TXBrowse_SwapCols(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SwapCols", @TXBrowse_SwapCols(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER MoveCol( xFrom, xTo, lRefresh, lUser); IIF( .F., s_oClass:ModMethod( "MoveCol", @TXBrowse_MoveCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MoveCol", @TXBrowse_MoveCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ReArrangeCols( aSeq, lRetainRest); IIF( .F., s_oClass:ModMethod( "ReArrangeCols", @TXBrowse_ReArrangeCols(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReArrangeCols", @TXBrowse_ReArrangeCols(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CreateFromCode(); IIF( .F., s_oClass:ModMethod( "CreateFromCode", @TXBrowse_CreateFromCode(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateFromCode", @TXBrowse_CreateFromCode(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER CreateFromResource( nId); IIF( .F., s_oClass:ModMethod( "CreateFromResource", @TXBrowse_CreateFromResource(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateFromResource", @TXBrowse_CreateFromResource(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SelectCol( nCol, lOffSet); IIF( .F., s_oClass:ModMethod( "SelectCol", @TXBrowse_SelectCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SelectCol", @TXBrowse_SelectCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GoLeft( lOffset, lRefresh); IIF( .F., s_oClass:ModMethod( "GoLeft", @TXBrowse_GoLeft(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoLeft", @TXBrowse_GoLeft(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GoRight( lOffset, lRefresh); IIF( .F., s_oClass:ModMethod( "GoRight", @TXBrowse_GoRight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoRight", @TXBrowse_GoRight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GoLeftMost(); IIF( .F., s_oClass:ModMethod( "GoLeftMost", @TXBrowse_GoLeftMost(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoLeftMost", @TXBrowse_GoLeftMost(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GoRightMost(); IIF( .F., s_oClass:ModMethod( "GoRightMost", @TXBrowse_GoRightMost(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoRightMost", @TXBrowse_GoRightMost(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GoUp( nLines); IIF( .F., s_oClass:ModMethod( "GoUp", @TXBrowse_GoUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoUp", @TXBrowse_GoUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GoDown( nLines); IIF( .F., s_oClass:ModMethod( "GoDown", @TXBrowse_GoDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoDown", @TXBrowse_GoDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER PageUp( nLines); IIF( .F., s_oClass:ModMethod( "PageUp", @TXBrowse_PageUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PageUp", @TXBrowse_PageUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER PageDown( nLines); IIF( .F., s_oClass:ModMethod( "PageDown", @TXBrowse_PageDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PageDown", @TXBrowse_PageDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GoTop(); IIF( .F., s_oClass:ModMethod( "GoTop", @TXBrowse_GoTop(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoTop", @TXBrowse_GoTop(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GoBottom(); IIF( .F., s_oClass:ModMethod( "GoBottom", @TXBrowse_GoBottom(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoBottom", @TXBrowse_GoBottom(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER HandleEvent( nMsg, nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "HandleEvent", @TXBrowse_HandleEvent(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HandleEvent", @TXBrowse_HandleEvent(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));




   _HB_MEMBER KeyCount(); IIF( .F., s_oClass:ModInline( "KeyCount", {|Self | Self, ( ::nLen := Eval( ::bKeyCount ), iif(::oVScroll <> nil , ( ::VSetRange( 1, ::nLen ), ::VUpdatePos() ), ), ::nLen ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "KeyCount", {|Self | Self, ( ::nLen := Eval( ::bKeyCount ), iif(::oVScroll <> nil , ( ::VSetRange( 1, ::nLen ), ::VUpdatePos() ), ), ::nLen ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER KeyNo(n); _HB_MEMBER _KeyNo(n); IIF( .F., s_oClass:ModMethod( "KeyNo", @TXBrowse_KeyNo(), 1 + 32, .F. ), s_oClass:AddMethod( "KeyNo", @TXBrowse_KeyNo(), 1 + 32, .F. ) ) ; IIF( .F., s_oClass:ModMethod( "_KeyNo", @TXBrowse_KeyNo() ), s_oClass:AddMethod( "_KeyNo", @TXBrowse_KeyNo() ) ) ;
   _HB_MEMBER BookMark(uBm); _HB_MEMBER _BookMark(uBm); IIF( .F., s_oClass:ModMethod( "BookMark", @TXBrowse_BookMark(), 1 + 32, .F. ), s_oClass:AddMethod( "BookMark", @TXBrowse_BookMark(), 1 + 32, .F. ) ) ; IIF( .F., s_oClass:ModMethod( "_BookMark", @TXBrowse_BookMark() ), s_oClass:AddMethod( "_BookMark", @TXBrowse_BookMark() ) ) ;
   _HB_MEMBER Skip(n); IIF( .F., s_oClass:ModInline( "Skip", {|Self,n | Self, Eval( ::bSkip, n ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Skip", {|Self,n | Self, Eval( ::bSkip, n ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER Bof(); IIF( .F., s_oClass:ModInline( "Bof", {|Self | Self, Eval( ::bBof ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Bof", {|Self | Self, Eval( ::bBof ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER Eof(); IIF( .F., s_oClass:ModInline( "Eof", {|Self | Self, Eval( ::bEof ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Eof", {|Self | Self, Eval( ::bEof ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SaveState( aData); IIF( .F., s_oClass:ModMethod( "SaveState", @TXBrowse_SaveState(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SaveState", @TXBrowse_SaveState(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER RestoreState( cInfo); IIF( .F., s_oClass:ModMethod( "RestoreState", @TXBrowse_RestoreState(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RestoreState", @TXBrowse_RestoreState(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER OldRestoreState( cInfo); IIF( .F., s_oClass:ModMethod( "OldRestoreState", @TXBrowse_OldRestoreState(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "OldRestoreState", @TXBrowse_OldRestoreState(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Seek( cSeek); IIF( .F., s_oClass:ModMethod( "Seek", @TXBrowse_Seek(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Seek", @TXBrowse_Seek(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER RddIncrSeek( cseek, uSeek); IIF( .F., s_oClass:ModMethod( "RddIncrSeek", @TXBrowse_RddIncrSeek(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RddIncrSeek", @TXBrowse_RddIncrSeek(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER RddIncrFilter( cExpr, uSeek); IIF( .F., s_oClass:ModMethod( "RddIncrFilter", @TXBrowse_RddIncrFilter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RddIncrFilter", @TXBrowse_RddIncrFilter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ArrayIncrSeek( cSeek); IIF( .F., s_oClass:ModMethod( "ArrayIncrSeek", @TXBrowse_ArrayIncrSeek(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ArrayIncrSeek", @TXBrowse_ArrayIncrSeek(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ArrayIncrFilter( cSeek, nGoTo); IIF( .F., s_oClass:ModMethod( "ArrayIncrFilter", @TXBrowse_ArrayIncrFilter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ArrayIncrFilter", @TXBrowse_ArrayIncrFilter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER AdoIncrSeek( cSeek); IIF( .F., s_oClass:ModMethod( "AdoIncrSeek", @TXBrowse_AdoIncrSeek(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AdoIncrSeek", @TXBrowse_AdoIncrSeek(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Select( nOperation); IIF( .F., s_oClass:ModMethod( "Select", @TXBrowse_Select(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Select", @TXBrowse_Select(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));





   _HB_MEMBER SelectAll(); IIF( .F., s_oClass:ModInline( "SelectAll", {|Self | Self, ::Select( 4 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SelectAll", {|Self | Self, ::Select( 4 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER SelectNone(); IIF( .F., s_oClass:ModInline( "SelectNone", {|Self | Self, ::Select( 0 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SelectNone", {|Self | Self, ::Select( 0 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER SelectOne(); IIF( .F., s_oClass:ModInline( "SelectOne", {|Self | Self, ( ::Select( 0 ), ::Select( 1 ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SelectOne", {|Self | Self, ( ::Select( 0 ), ::Select( 1 ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Adjust(); IIF( .F., s_oClass:ModMethod( "Adjust", @TXBrowse_Adjust(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Adjust", @TXBrowse_Adjust(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER CheckSize(); IIF( .F., s_oClass:ModMethod( "CheckSize", @TXBrowse_CheckSize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CheckSize", @TXBrowse_CheckSize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Resize(nSizeType, nWidth, nHeight); IIF( .F., s_oClass:ModInline( "Resize", {|Self,nSizeType, nWidth, nHeight | Self, ( ::MakeBrush(), ::ColStretch(), ::TControl:ReSize( nSizeType, nWidth, nHeight ), ::Refresh() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Resize", {|Self,nSizeType, nWidth, nHeight | Self, ( ::MakeBrush(), ::ColStretch(), ::TControl:ReSize( nSizeType, nWidth, nHeight ), ::Refresh() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER Change( lRow); IIF( .F., s_oClass:ModMethod( "Change", @TXBrowse_Change(), 4 + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Change", @TXBrowse_Change(), 4 + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER MakeTotals( aCols); IIF( .F., s_oClass:ModMethod( "MakeTotals", @TXBrowse_MakeTotals(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MakeTotals", @TXBrowse_MakeTotals(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Eval( bBlock, bFor, bWhile, nNext, nRec, lRest); IIF( .F., s_oClass:ModMethod( "Eval", @TXBrowse_Eval(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Eval", @TXBrowse_Eval(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Report( cTitle, lPreview, lModal, bSetUp, aGroupBy); IIF( .F., s_oClass:ModMethod( "Report", @TXBrowse_Report(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Report", @TXBrowse_Report(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ToExcel( bProgress, nGroupBy, aCols); IIF( .F., s_oClass:ModMethod( "ToExcel", @TXBrowse_ToExcel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ToExcel", @TXBrowse_ToExcel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ToCalc( bProgress, nGroupBy, nPasteMode, aSaveAs); IIF( .F., s_oClass:ModMethod( "ToCalc", @TXBrowse_ToCalc(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ToCalc", @TXBrowse_ToCalc(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ToDbf( cFile, bProgress, aCols, lPrompt); IIF( .F., s_oClass:ModMethod( "ToDbf", @TXBrowse_ToDbf(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ToDbf", @TXBrowse_ToDbf(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER CurrentRow(); IIF( .F., s_oClass:ModMethod( "CurrentRow", @TXBrowse_CurrentRow(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CurrentRow", @TXBrowse_CurrentRow(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AddBitmap(uBmp); IIF( .F., s_oClass:ModInline( "AddBitmap", {|Self,uBmp | Self, fnAddBitmap( Self, uBmp ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "AddBitmap", {|Self,uBmp | Self, fnAddBitmap( Self, uBmp ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER aBitmap(n); IIF( .F., s_oClass:ModInline( "aBitmap", {|Self,n | Self, ( n := Abs( IfNil( n, 0  ) ), If( n > 0 .AND. n <= Len( ::aBitmaps ), ::aBitmaps[ n ], nil ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "aBitmap", {|Self,n | Self, ( n := Abs( IfNil( n, 0  ) ), If( n > 0 .AND. n <= Len( ::aBitmaps ), ::aBitmaps[ n ], nil ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )



   _HB_MEMBER Initiate( hDlg); IIF( .F., s_oClass:ModMethod( "Initiate", @TXBrowse_Initiate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Initiate", @TXBrowse_Initiate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Display(); IIF( .F., s_oClass:ModMethod( "Display", @TXBrowse_Display(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Display", @TXBrowse_Display(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Paint(); IIF( .F., s_oClass:ModMethod( "Paint", @TXBrowse_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Paint", @TXBrowse_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER PaintHeader( hDC, aCols, nLast, hWhitePen, hGrayPen, hColPen); IIF( .F., s_oClass:ModMethod( "PaintHeader", @TXBrowse_PaintHeader(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PaintHeader", @TXBrowse_PaintHeader(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER PaintFooter( hDC, nBrwWidth, nBrwHeight, hWhitePen, hGrayPen); IIF( .F., s_oClass:ModMethod( "PaintFooter", @TXBrowse_PaintFooter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PaintFooter", @TXBrowse_PaintFooter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Refresh( lComplete); IIF( .F., s_oClass:ModMethod( "Refresh", @TXBrowse_Refresh(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Refresh", @TXBrowse_Refresh(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DelRePos(); IIF( .F., s_oClass:ModMethod( "DelRePos", @TXBrowse_DelRePos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DelRePos", @TXBrowse_DelRePos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DrawLine( lSelected, nRowLine); IIF( .F., s_oClass:ModMethod( "DrawLine", @TXBrowse_DrawLine(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DrawLine", @TXBrowse_DrawLine(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER FullPaint(); IIF( .F., s_oClass:ModInline( "FullPaint", {|Self | Self, ( ::lTransparent .OR. ::lMergeVert .OR.  ::nMarqueeStyle == 7 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "FullPaint", {|Self | Self, ( ::lTransparent .OR. ::lMergeVert .OR.  ::nMarqueeStyle == 7 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER GotFocus(hCtlFocus); IIF( .F., s_oClass:ModInline( "GotFocus", {|Self,hCtlFocus | Self, ( ::TControl:GotFocus( hCtlFocus ), If( GetParent( hCtlFocus ) <> ::hWnd, ::TControl:Refresh( .F. ),) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GotFocus", {|Self,hCtlFocus | Self, ( ::TControl:GotFocus( hCtlFocus ), If( GetParent( hCtlFocus ) <> ::hWnd, ::TControl:Refresh( .F. ),) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER LostFocus(hCtlFocus); IIF( .F., s_oClass:ModInline( "LostFocus", {|Self,hCtlFocus | Self, ( ::TControl:LostFocus( hCtlFocus ), If( GetParent( hCtlFocus ) <> ::hWnd, ::TControl:Refresh( .F. ), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "LostFocus", {|Self,hCtlFocus | Self, ( ::TControl:LostFocus( hCtlFocus ), If( GetParent( hCtlFocus ) <> ::hWnd, ::TControl:Refresh( .F. ), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER GetDlgCode( nLastKey); IIF( .F., s_oClass:ModMethod( "GetDlgCode", @TXBrowse_GetDlgCode(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetDlgCode", @TXBrowse_GetDlgCode(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER HasBorder(lEx); IIF( .F., s_oClass:ModInline( "HasBorder", {|Self,lEx | Self, If( lEx == .T.,  lAnd( GetWindowLong( ::hWnd, -20 ), 0X200 ),  lAnd( GetWindowLong( ::hWnd, -16 ), 8388608 ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "HasBorder", {|Self,lEx | Self, If( lEx == .T.,  lAnd( GetWindowLong( ::hWnd, -20 ), 0X200 ),  lAnd( GetWindowLong( ::hWnd, -16 ), 8388608 ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER LButtonDown( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "LButtonDown", @TXBrowse_LButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LButtonDown", @TXBrowse_LButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER LButtonUp( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "LButtonUp", @TXBrowse_LButtonUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LButtonUp", @TXBrowse_LButtonUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER MouseMove( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "MouseMove", @TXBrowse_MouseMove(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MouseMove", @TXBrowse_MouseMove(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER LDblClick( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "LDblClick", @TXBrowse_LDblClick(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LDblClick", @TXBrowse_LDblClick(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER RButtonDown( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "RButtonDown", @TXBrowse_RButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RButtonDown", @TXBrowse_RButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER MouseWheel( nKeys, nDelta, nXPos, nYPos); IIF( .F., s_oClass:ModMethod( "MouseWheel", @TXBrowse_MouseWheel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MouseWheel", @TXBrowse_MouseWheel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER HorzLine( nRow, nOperation); IIF( .F., s_oClass:ModMethod( "HorzLine", @TXBrowse_HorzLine(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HorzLine", @TXBrowse_HorzLine(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER MouseAtHeader( nRow, nCol); IIF( .F., s_oClass:ModMethod( "MouseAtHeader", @TXBrowse_MouseAtHeader(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MouseAtHeader", @TXBrowse_MouseAtHeader(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER MouseAtFooter( nRow, nCol); IIF( .F., s_oClass:ModMethod( "MouseAtFooter", @TXBrowse_MouseAtFooter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MouseAtFooter", @TXBrowse_MouseAtFooter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER MouseColPos( nCol); IIF( .F., s_oClass:ModMethod( "MouseColPos", @TXBrowse_MouseColPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MouseColPos", @TXBrowse_MouseColPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER MouseRowPos( nRow); IIF( .F., s_oClass:ModMethod( "MouseRowPos", @TXBrowse_MouseRowPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MouseRowPos", @TXBrowse_MouseRowPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER EraseData( nRow); IIF( .F., s_oClass:ModMethod( "EraseData", @TXBrowse_EraseData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "EraseData", @TXBrowse_EraseData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER KeyDown( nKey, nFlags); IIF( .F., s_oClass:ModMethod( "KeyDown", @TXBrowse_KeyDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "KeyDown", @TXBrowse_KeyDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER KeyChar( nKey, nFlags); IIF( .F., s_oClass:ModMethod( "KeyChar", @TXBrowse_KeyChar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "KeyChar", @TXBrowse_KeyChar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER HScroll( nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "HScroll", @TXBrowse_HScroll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HScroll", @TXBrowse_HScroll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER VScroll( nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "VScroll", @TXBrowse_VScroll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "VScroll", @TXBrowse_VScroll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER VUpdatePos(); IIF( .F., s_oClass:ModInline( "VUpdatePos", {|Self | Self, ::VSetPos( ::KeyNo() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "VUpdatePos", {|Self | Self, ::VSetPos( ::KeyNo() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER VUpdateAll(); IIF( .F., s_oClass:ModInline( "VUpdateAll", {|Self | Self, ::KeyCount() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "VUpdateAll", {|Self | Self, ::KeyCount() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )




   _HB_MEMBER VSetPos(nPos); IIF( .F., s_oClass:ModInline( "VSetPos", {|Self,nPos | Self, ::nVScrollPos := nPos, ::oVScroll:SetPos( iif( ::nLen <= 10000, nPos, Int( nPos * 10000 / ::nLen ) ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "VSetPos", {|Self,nPos | Self, ::nVScrollPos := nPos, ::oVScroll:SetPos( iif( ::nLen <= 10000, nPos, Int( nPos * 10000 / ::nLen ) ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER VThumbPos(nPos); IIF( .F., s_oClass:ModInline( "VThumbPos", {|Self,nPos | Self, ::nVScrollPos := ::VGetThumbPos( nPos ), ::oVScroll:SetPos( nPos ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "VThumbPos", {|Self,nPos | Self, ::nVScrollPos := ::VGetThumbPos( nPos ), ::oVScroll:SetPos( nPos ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER VGetPos(); IIF( .F., s_oClass:ModInline( "VGetPos", {|Self | Self, ::nVScrollPos }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "VGetPos", {|Self | Self, ::nVScrollPos }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER VSetRange(nMin, nMax); IIF( .F., s_oClass:ModInline( "VSetRange", {|Self,nMin, nMax | Self, ::oVScroll:SetRange( Min( 1, nMin ), Max( Min( 10000, nMax ), 2 ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "VSetRange", {|Self,nMin, nMax | Self, ::oVScroll:SetRange( Min( 1, nMin ), Max( Min( 10000, nMax ), 2 ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )



   _HB_MEMBER VGetMax(); IIF( .F., s_oClass:ModInline( "VGetMax", {|Self | Self, ::oVScroll:nMax * iif( ::nLen <= 10000, 1, ::nLen / 10000 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "VGetMax", {|Self | Self, ::oVScroll:nMax * iif( ::nLen <= 10000, 1, ::nLen / 10000 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER VGoDown(); IIF( .F., s_oClass:ModInline( "VGoDown", {|Self | Self, ::VSetPos( ::nVScrollPos + 1 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "VGoDown", {|Self | Self, ::VSetPos( ::nVScrollPos + 1 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER VGoUp(); IIF( .F., s_oClass:ModInline( "VGoUp", {|Self | Self, ::VSetPos( ::nVScrollPos - 1 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "VGoUp", {|Self | Self, ::VSetPos( ::nVScrollPos - 1 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )



   _HB_MEMBER VGetThumbPos(nPos); IIF( .F., s_oClass:ModInline( "VGetThumbPos", {|Self,nPos | Self, iif( ::nLen <= 10000, nPos, Int( nPos * ::nLen / 10000 ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "VGetThumbPos", {|Self,nPos | Self, iif( ::nLen <= 10000, nPos, Int( nPos * ::nLen / 10000 ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER VGoBottom(); IIF( .F., s_oClass:ModInline( "VGoBottom", {|Self | Self, ::VSetPos( ::nLen ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "VGoBottom", {|Self | Self, ::VSetPos( ::nLen ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER VGoTop(); IIF( .F., s_oClass:ModInline( "VGoTop", {|Self | Self, ::VSetPos( 1 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "VGoTop", {|Self | Self, ::VSetPos( 1 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER GetDisplayCols(); IIF( .F., s_oClass:ModMethod( "GetDisplayCols", @TXBrowse_GetDisplayCols(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetDisplayCols", @TXBrowse_GetDisplayCols(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GetVisibleCols(); IIF( .F., s_oClass:ModMethod( "GetVisibleCols", @TXBrowse_GetVisibleCols(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetVisibleCols", @TXBrowse_GetVisibleCols(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GetDisplayColsWidth( aOptionalReturnedSizes); IIF( .F., s_oClass:ModMethod( "GetDisplayColsWidth", @TXBrowse_GetDisplayColsWidth(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetDisplayColsWidth", @TXBrowse_GetDisplayColsWidth(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ColAtPos(nPos); IIF( .F., s_oClass:ModInline( "ColAtPos", {|Self,nPos | Self, ::aCols[ ::aDisplay[ Min( Max( If( nPos == nil .OR. nPos == 0, 1, nPos ), 1 ), Len( ::aDisplay ) ) ] ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ColAtPos", {|Self,nPos | Self, ::aCols[ ::aDisplay[ Min( Max( If( nPos == nil .OR. nPos == 0, 1, nPos ), 1 ), Len( ::aDisplay ) ) ] ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER ColPos( oCol); IIF( .F., s_oClass:ModMethod( "ColPos", @TXBrowse_ColPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ColPos", @TXBrowse_ColPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SelectedCol(); IIF( .F., s_oClass:ModInline( "SelectedCol", {|Self | Self, ::ColAtPos( ::nColSel ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SelectedCol", {|Self | Self, ::ColAtPos( ::nColSel ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER IsDisplayPosVisible( nPos, lComplete); IIF( .F., s_oClass:ModMethod( "IsDisplayPosVisible", @TXBrowse_IsDisplayPosVisible(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "IsDisplayPosVisible", @TXBrowse_IsDisplayPosVisible(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER LastDisplayPos(); IIF( .F., s_oClass:ModMethod( "LastDisplayPos", @TXBrowse_LastDisplayPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LastDisplayPos", @TXBrowse_LastDisplayPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));








   _HB_MEMBER BrwWidth(); IIF( .F., s_oClass:ModInline( "BrwWidth", {|Self | Self, GetClientRect( ::hWnd )[ 4 ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "BrwWidth", {|Self | Self, GetClientRect( ::hWnd )[ 4 ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER BrwHeight(); IIF( .F., s_oClass:ModInline( "BrwHeight", {|Self | Self, GetClientRect( ::hWnd )[ 3 ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "BrwHeight", {|Self | Self, GetClientRect( ::hWnd )[ 3 ] }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER HeaderHeight(); IIF( .F., s_oClass:ModInline( "HeaderHeight", {|Self | Self, If( ::nHeaderHeight == nil, 0, ::nHeaderHeight ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "HeaderHeight", {|Self | Self, If( ::nHeaderHeight == nil, 0, ::nHeaderHeight ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER FooterHeight(); IIF( .F., s_oClass:ModInline( "FooterHeight", {|Self | Self, If( ::nFooterHeight == nil, 0, ::nFooterHeight ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "FooterHeight", {|Self | Self, If( ::nFooterHeight == nil, 0, ::nFooterHeight ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER CalcHdrHeight(); IIF( .F., s_oClass:ModMethod( "CalcHdrHeight", @TXBrowse_CalcHdrHeight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CalcHdrHeight", @TXBrowse_CalcHdrHeight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER RowCount(); IIF( .F., s_oClass:ModInline( "RowCount", {|Self | Self, ( If( ::nRowHeight == nil, ::Adjust(),), Int( ( ::BrwHeight() - ::HeaderHeight() - ::FooterHeight() ) / ::nRowHeight ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "RowCount", {|Self | Self, ( If( ::nRowHeight == nil, ::Adjust(),), Int( ( ::BrwHeight() - ::HeaderHeight() - ::FooterHeight() ) / ::nRowHeight ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER FirstRow(); IIF( .F., s_oClass:ModInline( "FirstRow", {|Self | Self, ::HeaderHeight() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "FirstRow", {|Self | Self, ::HeaderHeight() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER LastRow(); IIF( .F., s_oClass:ModInline( "LastRow", {|Self | Self, ::BrwHeight() - ::FooterHeight() - ::nRowHeight + 1 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "LastRow", {|Self | Self, ::BrwHeight() - ::FooterHeight() - ::nRowHeight + 1 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER FooterRow(); IIF( .F., s_oClass:ModInline( "FooterRow", {|Self | Self, ::BrwHeight() - ::FooterHeight() + 1 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "FooterRow", {|Self | Self, ::BrwHeight() - ::FooterHeight() + 1 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER DataHeight(); IIF( .F., s_oClass:ModInline( "DataHeight", {|Self | Self, ::nRowHeight - iif(::nRowDividerStyle > 0, 1, 0) -  If(::nRowDividerStyle >= 5, 1, 0) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "DataHeight", {|Self | Self, ::nRowHeight - iif(::nRowDividerStyle > 0, 1, 0) -  If(::nRowDividerStyle >= 5, 1, 0) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER BrwFitSize( lReSize); IIF( .F., s_oClass:ModMethod( "BrwFitSize", @TXBrowse_BrwFitSize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "BrwFitSize", @TXBrowse_BrwFitSize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER CancelEdit(); IIF( .F., s_oClass:ModMethod( "CancelEdit", @TXBrowse_CancelEdit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CancelEdit", @TXBrowse_CancelEdit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetColumns(); IIF( .F., s_oClass:ModMethod( "SetColumns", @TXBrowse_SetColumns(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetColumns", @TXBrowse_SetColumns(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GoNextCtrl(); IIF( .F., s_oClass:ModMethod( "GoNextCtrl", @TXBrowse_GoNextCtrl(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoNextCtrl", @TXBrowse_GoNextCtrl(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GoPrevCtrl( ); IIF( !.F., s_oClass:AddVirtual( "GoPrevCtrl" ), )

   _HB_MEMBER SelFont(); IIF( .F., s_oClass:ModMethod( "SelFont", @TXBrowse_SelFont(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SelFont", @TXBrowse_SelFont(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER FontSize( nPlus); IIF( .F., s_oClass:ModMethod( "FontSize", @TXBrowse_FontSize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FontSize", @TXBrowse_FontSize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DrawSelect(); IIF( .F., s_oClass:ModInline( "DrawSelect", {|Self | Self, ::DrawLine( .T. ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "DrawSelect", {|Self | Self, ::DrawLine( .T. ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER RefreshCurrent(); IIF( .F., s_oClass:ModInline( "RefreshCurrent", {|Self | Self, ::DrawLine( .T. ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "RefreshCurrent", {|Self | Self, ::DrawLine( .T. ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER aRow(); IIF( .F., s_oClass:ModInline( "aRow", {|Self | Self, ( ::aArrayData[ ::nArrayAt ] ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "aRow", {|Self | Self, ( ::aArrayData[ ::nArrayAt ] ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER oCol( cHeader); IIF( .F., s_oClass:ModMethod( "oCol", @TXBrowse_oCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "oCol", @TXBrowse_oCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER RefreshFooters(); IIF( .F., s_oClass:ModInline( "RefreshFooters", {|Self | Self, If( Empty( ::nFooterHeight ),,AEval( ::aCols, { | oCol | oCol:RefreshFooter() } ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "RefreshFooters", {|Self | Self, If( Empty( ::nFooterHeight ),,AEval( ::aCols, { | oCol | oCol:RefreshFooter() } ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER ClpRow(); IIF( .F., s_oClass:ModMethod( "ClpRow", @TXBrowse_ClpRow(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ClpRow", @TXBrowse_ClpRow(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Copy(); IIF( .F., s_oClass:ModMethod( "Copy", @TXBrowse_Copy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Copy", @TXBrowse_Copy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Paste( cText); IIF( .F., s_oClass:ModMethod( "Paste", @TXBrowse_Paste(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Paste", @TXBrowse_Paste(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER aCellCoor( nRow, nCol); IIF( .F., s_oClass:ModMethod( "aCellCoor", @TXBrowse_aCellCoor(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "aCellCoor", @TXBrowse_aCellCoor(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetPos( nRow, nCol, lPixel); IIF( .F., s_oClass:ModMethod( "SetPos", @TXBrowse_SetPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetPos", @TXBrowse_SetPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetBackGround( uBack, nBckMode); IIF( .F., s_oClass:ModMethod( "SetBackGround", @TXBrowse_SetBackGround(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetBackGround", @TXBrowse_SetBackGround(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER MakeBrush(); IIF( .F., s_oClass:ModMethod( "MakeBrush", @TXBrowse_MakeBrush(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MakeBrush", @TXBrowse_MakeBrush(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DataRect(); IIF( .F., s_oClass:ModMethod( "DataRect", @TXBrowse_DataRect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DataRect", @TXBrowse_DataRect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER cBmpAdjBrush(cImage); _HB_MEMBER _cBmpAdjBrush(cImage); IIF( .F., s_oClass:ModMethod( "cBmpAdjBrush", @TXBrowse_cBmpAdjBrush(), 1 + 32, .F. ), s_oClass:AddMethod( "cBmpAdjBrush", @TXBrowse_cBmpAdjBrush(), 1 + 32, .F. ) ) ; IIF( .F., s_oClass:ModMethod( "_cBmpAdjBrush", @TXBrowse_cBmpAdjBrush() ), s_oClass:AddMethod( "_cBmpAdjBrush", @TXBrowse_cBmpAdjBrush() ) ) ;
   _HB_MEMBER ColStretch( nStretchCol); IIF( .F., s_oClass:ModMethod( "ColStretch", @TXBrowse_ColStretch(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ColStretch", @TXBrowse_ColStretch(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DestroyToolTip(); IIF( .F., s_oClass:ModMethod( "DestroyToolTip", @TXBrowse_DestroyToolTip(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DestroyToolTip", @TXBrowse_DestroyToolTip(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER NcMouseMove( nHitTestCode, nRow, nCol); IIF( .F., s_oClass:ModMethod( "NcMouseMove", @TXBrowse_NcMouseMove(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "NcMouseMove", @TXBrowse_NcMouseMove(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER MouseLeave(); IIF( .F., s_oClass:ModMethod( "MouseLeave", @TXBrowse_MouseLeave(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MouseLeave", @TXBrowse_MouseLeave(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER OnError(); s_oClass:SetOnError( @TXBrowse_OnError() ) ;

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TXBrowse ;



UTILITY STATIC function TXBrowse_New( oWnd) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local hBmp

   IIF( oWnd == nil, oWnd := GetWndDefault(), ) ;

   ::oWnd  := oWnd

   if oWnd <> nil
      if oWnd:oFont == nil
         oWnd:GetFont()
      endif
      ::oFont := oWnd:oFont
   endif

   ::l2007        := .F.
   ::aCols        := {}
   ::aSelected    := {}







   ::bClrHeader   :=  ::bClrFooter   := {|| { GetSysColor( 18 ), If( ::l2007, nRGB( 231, 242, 255 ), GetSysColor( 15 ) ),  nRGB( 125, 165, 224 ), nRGB( 203, 225, 252 ) } }
   ::bClrStd      := {|| { 0, GetSysColor( 5 )} }
   ::bClrSel      := {|| { 0, GetSysColor( 19 )} }
   ::bClrSelFocus := {|| { 16777215, GetSysColor( 13 )} }






   ::cCaption := ""
   ::cAlias   := ""
   ::cSeek    := ""

   ::nDataType := 0

   ::nTop     := 0
   ::nLeft    := 0
   ::nBottom  := 100
   ::nRight   := 100

   ::nStyle := nOr( 1073741824, 8388608, 268435456, 65536 )

   ::SetColor( 0, GetSysColor( 5 ) )

   ::lDrag     := .F.
   ::lFocused  := .F.
   ::lHScroll  := .T.
   ::lVScroll  := .T.

   ::lRecordSelector     := .T.
   ::lAllowRowSizing     := .T.
   ::lColDividerComplete := .F.
   ::lAllowColSwapping   := .T.
   ::lAllowColHiding     := .T.
   ::lFastEdit           := .F.
   ::lTransparent        := .F.

   ::nRowSel      := 1
   ::nColSel      := 1
   ::nColOffset   := 1
   ::nFreeze      := 0
   ::nCaptured    := 0
   ::nLastEditCol := 0

   ::nRowDividerStyle := 0
   ::nColDividerStyle := 0
   ::nMarqueeStyle    := 2

   ::nMoveType := 6

   ::nHeaderLines := 1
   ::nFooterLines := 1
   ::nDataLines   := 1

   ::hBmpRecSel := FwRArrow()

   ::lHeader          := .T.
   ::lFooter          := .F.
   ::lRefreshOnlyData := .F.

   ::aSortBmp    := {}
   hBmp        := FWBmpAsc()
   AAdd( ::aSortBmp, { hBmp, 0, nBmpWidth( hBmp ), nBmpHeight( hBmp ), nil, .F. } )
   hBmp        := FWBmpDes()
   AAdd( ::aSortBmp, { hBmp, 0, nBmpWidth( hBmp ), nBmpHeight( hBmp ), nil, .F. } )







   ::bClrGrad := { | lInvert | If( lInvert,  { { 1/3, nRGB( 255, 253, 222 ), nRGB( 255, 231, 151 ) },  { 2/3, nRGB( 255, 215,  84 ), nRGB( 255, 233, 162 ) }   },  { { 1/3, nRGB( 219, 230, 244 ), nRGB( 207, 221, 239 ) },  { 2/3, nRGB( 201, 217, 237 ), nRGB( 231, 242, 255 ) }   } ) }

   ::nHeader          := 0
   ::aHeaderTop       := {}

   ::hCursorHand      := CursorOpenHand()
   ::lKineticBrw      := ::lKinetic
   ::lAdjusted        := .F.

return Self



UTILITY STATIC function TXBrowse_Destroy() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nFor

   ::lMoved = .F.


   if ::oBrush:hBitmap <> 0 .AND. ValType( ::oBrush:Cargo ) == "N" .AND.  ::oBrush:hBrush <> ::oBrush:Cargo

      DeleteObject( ::oBrush:Cargo )
   endif

   for nFor := 1 to Len( ::aCols )
      ::aCols[ nFor ]:End()
   next

   for nFor := 1 to Len( ::aBitmaps )
      PalBmpFree( ::aBitmaps[ nFor, 1 ], ::aBitmaps[ nFor, 2 ] )
   next

   DeleteObject( ::hBmpRecSel )
   DeleteObject( ::hBrushRecSel )

   DeleteObject( ::aSortBmp[ 1 ][ 1 ] )
   DeleteObject( ::aSortBmp[ 2 ][ 1 ] )

   if ::hBtnShadowPen <> nil
      DeleteObject( ::hBtnShadowPen )
      ::hBtnShadowPen := nil
   endif

   if ::hWhitePen <> nil
      DeleteObject( ::hWhitePen )
      ::hWhitePen := nil
   endif

   if ::hColPen <> nil
      DeleteObject( ::hColPen )
      ::hColPen := nil
   endif

   if ::hRowPen <> nil
      DeleteObject( ::hRowPen )
      ::hRowPen := nil
   endif

return ::TControl:Destroy()



UTILITY STATIC function TXBrowse_CreateFromCode() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   if ::lCreated
      return Self
   endif

   ::nId := ::GetNewId()

   ::Register( nOr( 1, 2, 8 ) )

   if ::lDesign
      ::nStyle := nOr( ::nStyle, 67108864 )
   endif

   if ::lVScroll
      ::nStyle := nOr( ::nStyle, 2097152 )
   endif

   if ::lHScroll
      ::nStyle := nOr( ::nStyle, 1048576 )
   endif

   if ! Empty( ::oWnd:hWnd )
      ::Create()
      if ::oFont <> nil
         ::SetFont( ::oFont )
      endif
      ::Initiate()
      ::lVisible := .T.
      ::oWnd:AddControl( Self )
   else
      ::lVisible := .F.
      ::oWnd:DefControl( Self )
   endif

return Self



UTILITY STATIC function TXBrowse_CreateFromResource( nId) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   if ::lCreated
      return Self
   endif





   ::nId := nId

   ::Register( nOr( 1, 2, 8 ) )

   ::oWnd:DefControl( Self )

return Self



UTILITY STATIC function TXBrowse_Initiate( hDlg) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oBrush

   if ::oBrush <> nil
      oBrush := ::oBrush
      ::oBrush := nil
   endif

   if hDlg <> nil
      ::TControl:Initiate( hDlg )

   endif

   if ::lVScroll .OR. lAnd( GetWindowLong( ::hWnd, -16 ), 2097152 )
      ::oVScroll := TScrollBar():WinNew(,,, (!.F.) .OR. .T., Self,,,,,,,,, .F.,, )
   endif

   if ::lHScroll .OR. lAnd( GetWindowLong( ::hWnd, -16 ), 1048576 )
      ::oHScroll := TScrollBar():WinNew(,,, (!.T.), Self,,,,,,,,, .F.,, )
   endif

   if Empty( ::nDataType ) .OR. Empty( ::aCols )

      if ! Empty( ::aArrayData )
         if lAnd( ::nDataType, 1 )
            ::SetRDD( .T., nil, nil, ::aArrayData )
         elseif lAnd( ::nDataType, 16 ) .AND. !Empty( ::oDbf )
            ::SetODbf( ::oDbf, nil, nil, .T., ::aArrayData )
         else
            ::SetArray( ::aArrayData )
         endif
      elseif ! Empty( ::oRs )
         ::SetADO( ::oRs )
      elseif ! Empty( ::oMysql ) .AND. ::oMysql:IsKindOf( "TMYSQLQUERY" )
         ::SetMysql( ::oMysql )
      elseif ! Empty( ::oMysql ) .AND. ::oMysql:IsKindOf( "TDOLPHINQRY" )
         ::SetDolphin( ::oMysql )
      elseif ! Empty ( ::oDbf )
         ::SetoDbf( ::oDbf,,, Empty( ::aCols ) )
      elseif ! Empty( ::cAlias ) .OR. ! Empty( Alias() )
         ::SetRDD()
      endif
      if Empty( ::nDataType )

         ::bBof   := ::bEof := { || .T. }
         ::bKeyCount := ::bKeyNo := ::bBookMark := { || 0 }
      endif

   endif

   if ( ! Empty( ::cAlias ) ) .AND. ( Empty( ::bKeyCount ) .OR. Empty( ::bKeyNo ) )
      ::SetRdd()
   endif

   if Empty( ::aCols )
      ::AddCol():bStrData     := { || "" }
      ::aCols[ 1 ]:cHeader    := "A"
      ::nStretchCol := 1
   endif

   ::lCreated := .T.

   if oBrush <> nil
      if ::oBrush <> nil
         ::oBrush:End()
      endif
      ::oBrush = oBrush
   endif

   ::Adjust()
   ::MakeBrush()

return Self



UTILITY STATIC function TXBrowse_CheckSize() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aRect

   if ( ::nRightMargin <> nil .OR. ::nBottomMargin <> nil ) .AND. !( ::oWnd:oClient == Self )
      aRect    := GetClientRect( ::oWnd:hWnd )
      if ::nRightMargin <> nil
         ::nWidth       := aRect[ 4 ] - ::nRightMargin - ::nLeft
      endif
      if ::nBottomMargin <> nil
         ::nHeight      := aRect[ 3 ] - ::nBottomMargin - ::nTop
      endif

   endif

return Self



UTILITY STATIC function TXBrowse_BrwFitSize( lReSize) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oRect, nX, nY
   local nWidth      := ::nWidth
   local nHeight     := ::nHeight

   if ::lAdjusted

      IIF( lReSize == nil, lReSize := .F., ) ;

      oRect    := ::GetCliRect()
      nX             := nWidth  - oRect:nWidth
      nY             := nHeight - oRect:nHeight

      nWidth         := ::GetDisplayColsWidth() + 1 + nX


      nHeight        := Max( 3, Min( ::RowCount(), ::KeyCount() ) ) * ::nRowHeight +  If( ::lHeader, ::nHeaderHeight, 0 ) +  If( ::lFooter, ::nFooterHeight, 0 ) + 1 + nY

      if lReSize
         oRect := ::oWnd:GetCliRect()
         ::nWidth    := Min( nWidth, oRect:nWidth - IfNil( ::nRightMargin, 0 ) * 2 )
         ::nHeight   := nHeight
         if ! Empty( ::nRightMargin )
            ::nLeft  := oRect:nRight - ::nRightMargin - nWidth + 1
         endif
         if ! Empty( ::nBottomMargin )
            ::nTop   := oRect:nBottom - ::nBottomMargin - nHeight + 1
         endif
      endif

   endif

return { nWidth, nHeight }



UTILITY STATIC function TXBrowse_Adjust() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nFor, nLen, nHeight, nStyle, nTemp, oCol, h

   if ::nMarqueeStyle == 7
      if ValType( Eval( ::bClrSelFocus )[ 2 ] ) <> "A"

         ::bClrSelFocus := { || { 0, { { 1, ( 220 + ( 235 * 256 ) + ( 252 * 65536 ) ),  ( 193 + ( 219 * 256 ) + ( 252 * 65536 ) ) } } } }
      endif
      if ValType( Eval( ::bClrSel )[ 2 ] ) <> "A"
         ::bClrSel := ::bClrSelFocus
      endif
   endif

   ::CheckSize()

   nLen    := Len( ::aCols )
   nHeight := 0

   if ! Empty( ::nHeader )
      nTemp      := 0
      for nFor := 1 to nLen
         WITH OBJECT ::aCols[ nFor ]
            if :nHeaderType > 0

               if :nHeaderType == 2 .OR. :nHeaderType == 4
                  nTemp++
               endif
               if nTemp <= Len( ::aHeaderTop )
                  :cGrpHdr   := ::aHeaderTop[ nTemp ]
               endif
            endif
         END
      next
   endif

   ::GetDC()

   for nFor := 1 to nLen
      ::aCols[ nFor ]:Adjust()
   next

   ::ReleaseDC()

   ::CalcHdrHeight()

   if ::lFooter .AND. ::nFooterHeight == nil
      nHeight := 0
      for nFor := 1 to nLen
         nHeight := Max( nHeight, ::aCols[ nFor ]:FooterHeight() )
      next
      ::nFooterHeight := ( nHeight * ::nFooterLines ) + 4 + 3
   endif

   if ::nRowHeight == nil
      nHeight := 0
      for nFor := 1 to nLen
         nHeight := Max( nHeight, ::aCols[ nFor ]:DataHeight() )
      next

      for each oCol in ::aCols
         if ! Empty( oCol:aRows )
            h  := 0

            AEval( oCol:aRows, { |o| h += o:nDataHeight,  oCol:nWidth := Max( oCol:nWidth, o:nWidth ) } )
            AEval( oCol:aRows, { |o| o:nWidth := oCol:nWidth } )
            nHeight  := Max( nHeight, Ceiling( h / ::nDataLines ) )
         endif
      next

      ::nRowHeight := ( nHeight * ::nDataLines ) + 4
      if ::nRowDividerStyle <> 0
         ::nRowHeight++
      endif
      if ::nRowDividerStyle >= 5
         ::nRowHeight++
      endif
   endif


   IIF( ::hBtnShadowPen == nil, ::hBtnShadowPen := CreatePen( 0, 1, GetSysColor( 16 ) ), ) ; IIF( ::hWhitePen == nil, ::hWhitePen := CreatePen( 0, 1, GetSysColor( 20 ) ), );

   if ::hColPen <> nil
      DeleteObject( ::hColPen )
      ::hColPen := nil
   endif

   nStyle := ::nColDividerStyle

   do case
   case nStyle == 1 .OR. nStyle == 6 .OR. nStyle == 5
      ::hColPen := CreatePen( 0, ::nSizePen, ::nColorPen )
   case nStyle == 2
      ::hColPen := CreatePen( 0, ::nSizePen, 8421504 )
   case nStyle == 3
      ::hColPen := CreatePen( 0, ::nSizePen, ::nClrText )
   case nStyle == 4
      ::hColPen := CreatePen( 0, ::nSizePen, 12632256 )

   end

   nStyle := ::nRowDividerStyle

   do case
   case nStyle == 1 .OR. nStyle == 6 .OR. nStyle == 5
      ::hRowPen := CreatePen( 0, ::nSizePen, ::nColorPen )
   case nStyle == 2
      ::hRowPen := CreatePen( 0, ::nSizePen, 8421504 )
   case nStyle == 3
      ::hRowPen := CreatePen( 0, ::nSizePen, ::nClrText )
   case nStyle == 4
      ::hRowPen := CreatePen( 0, ::nSizePen, 12632256 )

   end

   if ::nRecSelColor == nil
      ::nRecSelColor := If( ::l2007, nRGB( 231, 242, 255 ), Eval( ::bClrHeader )[ 2 ] )
   endif

   if ::hBrushRecSel <> nil
      DeleteObject( ::hBrushRecSel )
   endif
   ::hBrushRecSel = CreateSolidBrush( ::nRecSelColor )

   ::GetDisplayCols()

   ::KeyCount()

   if ::lMultiSelect
      ::Select(1)
   endif

   if ::oVScroll <> nil
      ::VSetRange( 1, ::nLen )
      ::VSetPos( ::KeyNo() )
   endif

   ::lAdjusted    := .T.
   ::ColStretch()

return nil



UTILITY STATIC function TXBrowse_CalcHdrHeight() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nFor, nLen, nGrp, nCol, oCol, nHeight
   local cGrpHdr
   local aGroup, aBitmap

   if ::lHeader

      nLen           := Len( ::aCols )
      nHeight        := 0
      ::aHeaderTop   := {}
      if ::lGrpHeader == nil
         ::lGrpHeader   := .F.
         for nFor := 1 to nLen
            if ! Empty( ::aCols[ nFor ]:cGrpHdr )
               ::lGrpHeader := .T.
            endif
         next
      endif
      if ::lGrpHeader .OR. ::nHeaderHeight == nil
         if ::lGrpHeader
            nHeight     := 0
            for nFor := 1 to nLen
               oCol     := ::aCols[ nFor ]
               if oCol:cGrpHdr <> cGrpHdr
                  if aGroup <> nil
                     AAdd( ::aHeaderTop, aGroup )
                     for nCol := aGroup[ 3 ] to aGroup[ 4 ]
                        ::aCols[ nCol ]:nGrpHeight := aGroup[ 5 ]
                     next
                     aGroup  := nil
                  endif
                  cGrpHdr     := oCol:cGrpHdr
                  if ! Empty( oCol:cGrpHdr )


                     aGroup      := { oCol:cGrpHdr, oCol, nFor, nFor, oCol:HeaderHeight( .T. ),  oCol:aBitmap( oCol:nGrpBmpNo ) }
                  endif
               else

                  if ! Empty( oCol:cGrpHdr )
                     aGroup[ 2 ]      := oCol
                     aGroup[ 4 ]      := nFor
                     aGroup[ 5 ]      := Max( aGroup[ 5 ], oCol:HeaderHeight( .T. ) )
                     if ! Empty( oCol:nGrpBmpNo )
                        aGroup[ 6 ]    := oCol:aBitmap( oCol:nGrpBmpNo )
                     endif
                  endif
               endif
            next
            if aGroup <> nil
               AAdd( ::aHeaderTop, aGroup )
               for nCol := aGroup[ 3 ] to aGroup[ 4 ]
                  ::aCols[ nCol ]:nGrpHeight := aGroup[ 5 ]
               next
               aGroup  := nil
            endif
         endif

         for nFor := 1 to nLen
            nHeight  := Max( nHeight, ::aCols[ nFor ]:HeaderHeight() )
         next
         if ::nHeaderLines > 1
            nHeight  := Max( nHeight, FontHeight( Self, ::oWnd:oFont ) * ::nHeaderLines )
         endif
         ::nHeaderHeight := nHeight + 4 + 3
      endif
   endif

return ::nHeaderHeight



UTILITY STATIC function TXBrowse_Change( lRow) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   if ::bChange <> nil

      IIF( lRow == nil, lRow := .T., ) ;

      if lRow .OR. ::lColChangeNotify
         Eval( ::bChange, Self, lRow )
      endif

   endif

return nil



UTILITY STATIC function TXBrowse_Refresh( lComplete) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nKeyNo

   IIF( lComplete == nil, lComplete := .F., ) ;

   ::KeyCount()

   if lComplete

      ::nRowSel  = 1
      ::nArrayAt = Min( 1, ::nLen )

   else

      nKeyNo     = ::KeyNo()
      ::nArrayAt = Min( ::nArrayAt, ::nLen )
      ::nRowSel  = Max( 1, Min( ::nRowSel, ::nLen ) )
      ::nRowSel  = Max( 1, Min( ::nRowSel, nKeyNo ) )

      ::DelRepos()

      if nKeyNo >= ::nLen .AND. ::nLen > 1
         ::nRowSel   := Min( nKeyNo, ::RowCount() )
      endif





      if ::nArrayAt == 0 .AND. ::nLen > 0

         ::nArrayAt  := 1
      endif

   endif

   ::GetDisplayCols()

return ::TControl:Refresh( .T. )



UTILITY STATIC function TXBrowse_DelRePos() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local lRepos := .F.
   local cFilter, bFilter

   if ( ::nDataType == 1 ) .AND. ::nLen > 0
      if ( Set( 11 ) .AND. ( ::cAlias )->( Deleted() ) )









            ( ::cAlias )->( dbSkip( 1 ) )
            if ( ::cAlias )->( eof() )
               ( ::cAlias )->( DbGoBottom() )
            endif
            lRepos := .T.
      endif

   endif

return lRepos



UTILITY STATIC function TXBrowse_Display() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   if !::lCreated
      return nil
   endif

   ::BeginPaint()
   ::Paint()
   ::EndPaint()

return 0



UTILITY STATIC function TXBrowse_Paint() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aCols, aColors, oRect
   local oCol
   local nFor, nLen, nRow, nCol, nHeight, nLast, nTemp, nTemp2
   local nBrwWidth, nBrwHeight, nWidth
   local hBrush, hDC, hGrayPen, hWhitePen, hColPen, hRowPen, hSelBrush
   local nFirstRow, nLastRow, nMaxRows, nRowStyle, nColStyle, nRowPos, nRowHeight, nBookMark, nMarqStyle, nScan
   local lRecSel, lOnlyData, lHighLite
   local aInfo

   if ::nRecSelWidth < 25
      ::nRecSelWidth    := 25
   endif

   if ::SelectedCol():oEditLbx <> nil
      return nil
   endif

   aInfo := ::DispBegin()
   ::CheckSize()


   if ::lTransparent .AND. Empty( ::oBrush:hBitmap )
      if ! Empty( ::oWnd:oBrush:hBitmap )

         SetBrushOrgEx( ::hDC, nBmpWidth( ::oWnd:oBrush:hBitmap ) - ::nLeft,  nBmpHeight( ::oWnd:oBrush:hBitmap ) - ::nTop )
      endif
      FillRect( ::hDC, GetClientRect( ::hWnd ), ::oWnd:oBrush:hBrush )
   else
      oRect       := ::DataRect()
      SetBrushOrgEx( ::hDC, oRect:nLeft, oRect:nTop )
      FillRect( ::hDC, oRect:aRect, ::oBrush:hBrush )
   endif


   while ! ::IsDisplayPosVisible( ::nColSel ) .AND. ::nColSel > 1
      ::nColSel--
      ::nColOffSet++
      ::GetDisplayCols()
   end

   nLen       := Len( ::aDisplay )
   aCols      := Array( nLen + 1)
   nBrwWidth  := ::BrwWidth()
   nBrwHeight := ::BrwHeight()
   nRow       := 0
   nCol       := 0
   nFirstRow  := 0
   nLastRow   := nBrwHeight
   nLast      := ::LastDisplayPos()
   nMarqStyle := ::nMarqueeStyle
   nRowStyle  := ::nRowDividerStyle
   nColStyle  := ::nColDividerStyle
   hDC        := ::hDC
   hGrayPen   := ::hBtnShadowPen
   hWhitePen  := ::hWhitePen
   hColPen    := ::hColPen
   hRowPen    := ::hRowPen
   lRecSel    := ::lRecordSelector
   lOnlyData  := ::lRefreshOnlyData
   lHighLite  := .F.





   if lRecSel
      nCol += ::nRecSelWidth
      if !lOnlyData

         FillRect( hDC, {0, 0, nLastRow + 3, nCol }, ::hBrushRecSel )
         nHeight := ::HeaderHeight()
         nTemp   := nBrwHeight - ::FooterHeight() + 3
         DrawVert( hDC, nCol - 3, nHeight, nTemp,          hWhitePen )
         DrawVert( hDC, nCol - 2, nHeight, nTemp,          hGrayPen )
         DrawVert( hDC, 0,        0,       nBrwHeight + 3, hGrayPen )
         DrawVert( hDC, 1,        0,       nBrwHeight + 3, hWhitePen )
      endif


   endif

   for nFor := 1 to nLast
      aCols[ nFor ] := nCol
      oCol := ::ColAtPos( nFor )
      nCol += oCol:nWidth + 2
   next

   aCols[ nFor ] := nCol


   if ::lHeader
      if !lOnlyData
         ::PaintHeader( hDC, aCols, nLast, hWhitePen, hGrayPen, hColPen )
      endif
      nFirstRow += ::nHeaderHeight
   endif


   if ::lFooter
      if !lOnlyData
         ::PaintFooter( hDC, aCols, nLast, nBrwWidth, nBrwHeight, hWhitePen, hGrayPen )
      endif
      nLastRow -= ::nFooterHeight
   endif





      ::lRefreshOnlyData := .F.

      if ::nLen == 0
         ::EraseData( nFirstRow  )
         ::DispEnd( aInfo )
         return nil
      endif

      nRowHeight := ::nRowHeight
      nHeight    := ::DataHeight()
      nMaxRows   := ::RowCount()
      nRowPos    := 1
      nRow       := nFirstRow
      nBookMark  := Eval( ::bBookMark )


      ::Skip( 1 - Min( ::nRowSel, nMaxRows ) )

      if nMarqStyle > 3
         if ::hWnd == GetFocus()
            hSelBrush := CreateColorBrush( Eval( If( ::bClrRowFocus == nil, ::bClrSelFocus, ::bClrRowFocus ) )[ 2 ] )
         else
            hSelBrush := CreateColorBrush( Eval( ::bClrSel )[ 2 ] )
         endif
      endif

      while nRowPos <= nMaxRows



         if hSelBrush <> nil

            lHighLite := ::lMultiSelect .AND. ( Ascan( ::aSelected, Eval( ::bBookMark ) ) > 0 )




            if aCols[ nLast + 1 ] < nBrwWidth
               nTemp     := nRow + nHeight
               nTemp2    := aCols[nLast + 1]
               if nColStyle < 5
                  nTemp2--
               endif
               if lHighLite .AND. ::nMarqueeStyle <> 7
                  FillRect( hDC, {nRow, nTemp2, nTemp, nBrwWidth }, hSelBrush )
               elseif nMarqStyle == 6

                  if ! ::lTransparent
                     hBrush := CreateColorBrush( Eval( ::bClrStd )[ 2 ] )
                     FillRect( hDC, {nRow, nTemp2, nTemp, nBrwWidth }, hBrush )
                     DeleteObject( hBrush )
                  endif

               endif
            endif

         endif

         for nFor := 1 to nLast
            if aCols[ nFor ] > nBrwWidth
               exit
            endif
            oCol := ::ColAtPos( nFor )
            oCol:PaintData( nRow, aCols[ nFor ], nHeight, lHighLite, .F., nFor, nRowPos )
         next

         nRowPos++
         nRow += nRowHeight

         if ::Skip() == 0
            exit
         endif

      enddo

      if nMarqStyle <= 3 .AND. aCols[ nLast + 1 ] < nBrwWidth .AND. ! ::lTransparent
         hBrush := CreateColorBrush( ::nClrPane )
         nTemp  := aCols[nLast + 1] - 1
         FillRect( hDC, {nFirstRow, nTemp, ::BrwHeight() - ::FooterHeight(), nBrwWidth }, hBrush )
         DeleteObject( hBrush )
      endif

      if hSelBrush <> nil
         DeleteObject( hSelBrush )
      endif

      ::nDataRows := nRowPos - 1
      ::nRowSel := Max( Min( ::nRowSel, ::nDataRows ), 1)

      if nRow < nLastRow
         ::EraseData( nRow  )
      endif

      Eval( ::bBookMark, nBookMark )

      ::DrawLine( .T. )





      do case
      case nColStyle == 0
         nTemp := 2
      case nColStyle < 5
         nTemp := 1
      otherwise
         nTemp := 0
      end

      if nColStyle > 0
         if ::lColDividerComplete
            nHeight := nLastRow
         else
            nHeight := ( ::nRowHeight * ( nRowPos - 1 ) ) + nFirstRow
         endif
         for nFor := 2 to nLast + 1
            nCol := acols[ nFor ]
            if nColStyle <> 6
               DrawVert( hDC, nCol - 2, nFirstRow, nHeight, hColPen )
            else
               DrawVert( hDC, nCol - 2, nFirstRow, nHeight, hWhitePen )
               DrawVert( hDC, nCol - 1, nFirstRow, nHeight, hColPen )
            endif
            if nColStyle = 5
               DrawVert( hDC, nCol - 1, nFirstRow, nHeight, hWhitePen )
            endif
         next
      endif

      if nRowStyle > 0
         nRow   := ::HeaderHeight() - 1
         nTemp2 := ::nDataRows
         while nTemp2-- > 0
            nRow += nRowHeight
            if lRecSel
               DrawHorz( hDC, nRow,     2, ::nRecSelWidth - 4, hGrayPen  )
               DrawHorz( hDC, nRow + 1, 2, ::nRecSelWidth - 4, hWhitePen )
            endif
            for nFor := 1 to nLast
               if ::aCols[ nFor ]:HasBorder( ::nDataRows - nTemp2 )
                  nCol   := acols[ nFor ] - If( nFor <> 1, nTemp, 0 )
                  nWidth := nCol + ::ColAtPos( nFor ):nWidth + If( nFor <> 1, nTemp, 0 )
                  if nRowStyle <> 6
                     DrawHorz( hDC, nRow, nCol, nWidth, hRowPen )
                  else
                     DrawHorz( hDC, nRow,     nCol, nWidth, hWhitePen )
                     DrawHorz( hDC, nRow - 1, nCol, nWidth, hRowPen   )
                  endif
                  if nRowStyle = 5
                     DrawHorz( hDC, nRow - 1, nCol, nWidth, hWhitePen )
                  endif
               endif
            next
            if nMarqStyle >= 4 .AND. nLast == Len( ::aDisplay )
               nCol   := acols[ nFor ] - nTemp
               nWidth := ::BrwWidth() - 4
               if nRowStyle <> 6
                  DrawHorz( hDC, nRow, nCol, nWidth, hRowPen )
               else
                  DrawHorz( hDC, nRow,     nCol, nWidth, hWhitePen )
                  DrawHorz( hDC, nRow - 1, nCol, nWidth, hRowPen   )
               endif
               if nRowStyle = 5
                  DrawHorz( hDC, nRow - 1, nCol, nWidth, hWhitePen )
               endif
            endif
         enddo
      endif

   ::DispEnd( aInfo )

return 0



UTILITY STATIC function TXBrowse_PaintHeader( hDC, aCols, nLast, hWhitePen, hGrayPen, hColPen) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nRow, nCol, oCol, nHeight, nBrwWidth, aGroup
   local hHeaderPen, aColors, hBrush
   local nFor, nAt
   local cGrpHdr, nGrpHt, nGrpFrom := 0

   nBrwWidth   := ::BrwWidth()
   aColors     := Eval( ::bClrHeader )
   hBrush      := CreateColorBrush( aColors[ 2 ] )
   hHeaderPen  := CreatePen( 0, 1, aColors[ Min( 3, Len( aColors ) ) ] )

   nRow    := 0
   nHeight := ::nHeaderHeight - 3
   DrawHorz( hDC, nRow, 2, nBrwWidth, hGrayPen )
   nRow++
   DrawHorz( hDC, nRow, 2, nBrwWidth, hWhitePen )
   nRow++
   FillRect( hDC, { nRow, 2, nRow + nHeight, nBrwWidth}, hBrush )

   for nFor := 1 to nLast
      nCol     := aCols[ nFor ]
      oCol     := ::ColAtPos( nFor )

      DrawVert( hDC, nCol - 2, nRow + 1, nRow + nHeight - 2, hGrayPen  )
      DrawVert( hDC, nCol - 1, nRow + 1, nRow + nHeight - 2, hWhitePen )
      oCol:PaintHeader( nRow, nCol, nHeight, .F., hDC )

      if oCol:cGrpHdr <> cGrpHdr
         cGrpHdr     := oCol:cGrpHdr
         if Empty( oCol:cGrpHdr )
            nGrpFrom       := 0
            aGroup         := nil
         else
            nGrpFrom       := nCol
            nGrpHt         := oCol:nGrpHeight
            nAt            := AScan( ::aHeaderTop, { |a| a[ 3 ] == oCol:nPos } )
            aGroup         := If( nAt > 0, ::aHeaderTop[ nAt ], nil )
         endif
      endif

      if nFor == nLast .OR. oCol:cGrpHdr <> ::ColAtPos( nFor + 1 ):cGrpHdr
         if ! Empty( cGrpHdr )


            oCol:PaintHeader( nRow, nGrpFrom, nHeight, .F., hDC, aCols[ nFor + 1 ] - nGrpFrom,  If( aGroup == nil, nil, aGroup[ 6 ] ) )
            DrawHorz( hDC, nRow + nGrpHt, nGrpFrom - 2, aCols[ nFor + 1 ] - 2, hHeaderPen )
         endif
      endif
   next

   nCol     := aCols[ nFor ]
   DrawVert( hDC, nCol - 2,       nRow + 1, nRow + nHeight - 2, hGrayPen  )
   DrawVert( hDC, nCol - 1,       nRow + 1, nRow + nHeight - 2, hWhitePen )
   DrawHorz( hDC, nRow + nHeight, 0,        nBrwWidth - 2,      hGrayPen  )

   DeleteObject( hBrush )
   DeleteObject( hHeaderPen )

return nil



UTILITY STATIC function TXBrowse_PaintFooter( hDC, aCols, nLast, nBrwWidth, nBrwHeight, hWhitePen, hGrayPen) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nRow, nCol, nFor, oCol
   local nHeight, hBrush, aColors

   nHeight  := ::nFooterHeight - 3
   nRow     := nBrwHeight - ::nFooterHeight
   aColors := Eval( ::bClrFooter )
   DrawHorz( hDC, nRow, 0, nBrwWidth, hGrayPen )
   nRow++
   DrawHorz( hDC, nRow, 0, nBrwWidth, hWhitePen )
   nRow++
   DrawHorz( hDC, nRow + nHeight, 0, nBrwWidth, hGrayPen )
   hBrush  := CreateColorBrush( aColors[ 2 ] )
   FillRect( hDC, { nRow, 1, nRow + nHeight, nBrwWidth}, ::hBrushRecSel )
   DeleteObject( hBrush )
   for nFor := 1 to nLast
      nCol := aCols[ nFor ]
      oCol := ::ColAtPos( nFor )
      DrawVert( hDC, nCol - 2, nRow + 1, nRow + nHeight - 2, hGrayPen )
      DrawVert( hDC, nCol - 1, nRow + 1, nRow + nHeight - 2, hWhitePen )
      oCol:PaintFooter( nRow, nCol, nHeight )
   next
   nCol := aCols[ nFor ]

   DrawVert( hDC, nCol - 2, nRow + 1, nRow + nHeight - 2, hGrayPen )
   DrawVert( hDC, nCol - 1, nRow + 1, nRow + nHeight - 2, hWhitePen )

return nil



UTILITY STATIC function TXBrowse_DrawLine( lSelected, nRowSel) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol

   local nRow, nCol, nFor, nLast, nHeight, nStyle, nWidth, nColStyle, nTemp, nDataHeight, nRight
   local hDC, hBrush, hWhitePen, hColPen
   local lHighLite


   IIF( lSelected == nil, lSelected := .F., ) ; IIF( nRowSel == nil, nRowSel := ::nRowSel, );

   if ::nLen == 0
      return nil
   endif

   if ! ::lDrawSelected
      return  nil
   endif

   nHeight     := ::nRowHeight
   nDataHeight := ::DataHeight
   nRow        := ( ( nRowSel - 1 ) * nHeight ) + ::HeaderHeight()

   if nRow > ::LastRow()
      return nil
   endif

   hDC       := ::GetDC()
   nLast     := ::LastDisplayPos()
   nStyle    := ::nMarqueeStyle

   lHighLite := ( nStyle >= 4 .AND. lSelected )

   if ::lMultiSelect .AND. ( nStyle == 6 .OR. ::nMarqueeStyle == 7 )

      lHighLite := ( Ascan( ::aSelected, Eval( ::bBookMark ) ) > 0 )
   endif








   for nFor := 1 to nLast
      oCol := ::ColAtPos ( nFor )
      oCol:PaintData( nRow, nil, nDataHeight, lHighLite, lSelected, nFor, nRowSel )
   next

   if nStyle >= 4 .AND. nStyle <> 7
      nColStyle := ::nColDividerStyle
      nCol      := oCol:nDisplayCol + oCol:nWidth + 2
      nWidth    := ::BrwWidth() - 2
      if nColStyle < 5
         nCol--
         nWidth++
      endif
      nTemp := nRow + nDataHeight
      if nCol < nWidth
         if lHighLite
            if ::hWnd == GetFocus()
               hBrush := CreateColorBrush( Eval( If( ::bClrRowFocus == nil, ::bClrSelFocus, ::bClrRowFocus ) )[ 2 ] )
            else
               hBrush := CreateColorBrush( Eval( ::bClrSel )[ 2 ] )
            endif
         else
            hBrush := CreateColorBrush( Eval( ::bClrStd )[ 2 ] )
         endif
         if lHighLite .OR. ! ::lTransparent
            FillRect( hDC, {nRow, nCol, nTemp, nWidth }, hBrush )
         endif
         DeleteObject( hBrush )
      endif
      if nStyle == 6
         nCol := iif(::lRecordSelector, ::nRecSelWidth - 1, 0 )
         if lSelected
            FrameDot(hDC, nRow, nCol, nRow + nDataHeight - 1, nWidth - 1)
         elseif nColStyle > 0
            hColPen   := ::hColPen
            hWhitePen := ::hWhitePen
            for nFor := 1 to nLast
               oCol := ::ColAtPos ( nFor )
               nCol := oCol:nDisplayCol + oCol:nWidth
               if nColStyle <> 6
                  DrawVert( hDC, nCol, nRow, nRow + nDataHeight, hColPen )
               else
                  DrawVert( hDC, nCol,     nRow, nRow + nDataHeight, hWhitePen )
                  DrawVert( hDC, nCol + 1, nRow, nRow + nDataHeight, hColPen   )
               endif
               if nColStyle = 5
                  DrawVert( hDC, nCol + 1, nRow, nRow + nDataHeight, hWhitePen )
               endif
            next
         endif
      endif
   endif

   if ::lRecordSelector
      if lSelected

         PalBmpDraw( hDC, nRow + ( nHeight / 2 ) - 8, ::nRecSelWidth - 15, ::hBmpRecSel, 0, 9, 14,, .T., ::nRecSelColor )
      else





         FillRect( hDC, {nRow + 1, ::nRecSelWidth - 15, nRow + nDataHeight - 1 , ::nRecSelWidth - 3}, ::hBrushRecSel )
      endif

   endif

   if lSelected
      nHeight -= 2
      oCol := ::ColAtPos( ::nColSel )
      do case
      case nStyle == 1
         oCol:Box( nRow, nil, nDataHeight, 1 )
      case nStyle == 2
         oCol:Box( nRow, nil, nDataHeight, 2 )
      case nStyle == 3
         oCol:PaintData( nRow, nil, nDataHeight, .T., .T. , ::nColSel, nRowSel )
      case nStyle == 4
         oCol:Box( nRow, nil, nDataHeight, 3 )
      case nStyle == 7
         oCol     := ::ColAtPos( nLast )
         nLast    := Min( oCol:nDisplayCol + oCol:nWidth, ::BrwWidth() )







         RoundBox( hDC, 2, nRow - 1, nLast - 1, nRow + nDataHeight,     2, 2, ( 235 + ( 244 * 256 ) + ( 253 * 65536 ) ), 1 )

         RoundBox( hDC, 1, nRow - 2, nLast,     nRow + nDataHeight + 1, 2, 2, ( 125 + ( 162 * 256 ) + ( 206 * 65536 ) ), 1 )



      endcase
   endif

   ::ReleaseDC()

return nil



UTILITY STATIC function TXBrowse_EraseData( nRow) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nLast, nFor, nHeight, nCol
   local hDC, oBrush

   if ::lTransparent .AND. Empty( ::oBrush:hBitmap )
      oBrush      := ::oWnd:oBrush
   else
      oBrush      := ::oBrush
   endif

   hDC     := ::GetDC()
   nHeight := ::BrwHeight() - ::FooterHeight() - nRow

   if ! ::lColDividerComplete
      nCol := 0
      if ::lRecordSelector
         nCol += ::nRecSelWidth
      endif
      FillRect( hDC, { nRow, nCol, nRow + nHeight, ::BrwWidth() }, oBrush:hBrush )
   else
      nLast   := ::LastDisplayPos()

      if ! ::lTransparent
         for nFor := 1 to nLast
            oCol := ::ColAtPos( nFor )
            oCol:EraseData( nRow, , nHeight, ::oBrush:hBrush, .T. )
         next
         if ::nMarqueeStyle > 3 .AND. nLast == Len( ::aDisplay )
            nCol := oCol:nDisplayCol + oCol:nWidth + 1
            FillRect( hDC, { nRow, nCol, nRow + nHeight, ::BrwWidth() }, oBrush:hBrush )
         endif
      endif
   endif

   if ::lRecordSelector .AND. ::nRowDividerStyle > 0
      FillRect( hDC, { nRow, 2, nRow + nHeight, ::nRecSelWidth - 3 }, ::hBrushRecSel )
   endif

   ::ReleaseDC()

return nil


UTILITY STATIC function TXBrowse_oCol( u) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nAt   := AScan( ::aCols, { |o| o == u } )

return If( nAt > 0, ::aCols[ nAt ], nil )


UTILITY STATIC function TXBrowse_GetDisplayCols() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local aDisplay
   local nFor, nLen, nOffset, nFreeze, nCol, nCols

   nFreeze  := ::nFreeze
   nOffset  := ::nColOffset + nFreeze
   nLen     := Len( ::aCols )
   aDisplay := {}

   for nFor := 1 to nlen
      oCol := ::aCols[ nFor ]
      oCol:nPos := 0
      if oCol:oBtnList <> nil
         oCol:oBtnList:Hide()
      endif
      if oCol:oBtnElip <> nil
         oCol:oBtnElip:Hide()
      endif
   next

   nCol := 1

   while nFreeze > 0 .AND. nCol <= nLen
      oCol := ::aCols[ nCol ]
      if ! oCol:lHide
         AAdd( aDisplay, nCol )
         oCol:nPos := Len( aDisplay )
         nFreeze--
      endif
      nCol++
   enddo

   nCol := Max( nCol, nOffset )

   while nCol <= nLen
      oCol := ::aCols[ nCol ]
      if ! oCol:lHide
         AAdd( aDisplay, nCol )
         oCol:nPos := Len( aDisplay )
      endif
      nCol++
   enddo

   ::aDisplay := aDisplay

   ::nColSel  := Min( Len( ::aDisplay ), ::nColSel )

   if ::oHScroll <> nil
      nCols := 0
      for nFor := 1 to nlen
         oCol := ::aCols[ nFor ]
         if !oCol:lHide
            nCols++
         endif
      next
      ::oHScroll:SetRange( 1, Max( nCols, 2 ) )
   endif

return aDisplay



UTILITY STATIC function TXBrowse_GetVisibleCols() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local aVisible
   local nFor, nLen, nCol

   aVisible := {}
   nLen     := Len( ::aCols )

   For nCol := 1 to nLen
      oCol := ::aCols[ nCol ]
      if !oCol:lHide
         Aadd( aVisible, oCol )
      endif
   Next

return aVisible



UTILITY STATIC function TXBrowse_GetDisplayColsWidth( aSizes) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nWidth, nPos, nLen

   aSizes := {}
   nPos   := 1
   nLen   := Len( ::aDisplay )

   if ::lRecordSelector
      nWidth := ::nRecSelWidth
   else
      nWidth := 0
   endif

   for nPos := 1 to nLen
      nWidth += ::ColAtPos( nPos ):nWidth + 2
      Aadd(aSizes, ::ColAtPos( nPos ):nWidth )
   next

return nWidth



UTILITY STATIC function TXBrowse_IsDisplayPosVisible( nPos, lComplete) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nWidth, nFor

   IIF( lComplete == nil, lComplete := .F., ) ;

   if nPos < 1 .OR. nPos > Len( ::aDisplay )
      return .F.
   endif

   if ::lRecordSelector
      nWidth := ::nRecSelWidth
   else
      nWidth := 0
   endif

   for nFor := 1 to nPos - 1
      nWidth += ::ColAtPos( nFor ):nWidth + 2
   next

   if lcomplete
      nWidth += ::ColAtPos( nPos ):nWidth + 2






   endif

return ( nWidth  < ::BrwWidth() )



UTILITY STATIC function TXBrowse_LastDisplayPos( lComplete) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nWidth, nMaxWidth, nPos, nLen

   IIF( lComplete == nil, lComplete := .F., ) ;

   nPos      := 1
   nMaxWidth := ::BrwWidth()
   nLen      := Len( ::aDisplay )

   if ::lRecordSelector
      nWidth := ::nRecSelWidth
   else
      nWidth := 0
   endif

   while nPos <= nLen .AND. nWidth < nMaxWidth
      nWidth += ::ColAtPos( nPos++ ):nWidth + 2
   enddo

   nPos --

   if lComplete .AND. nWidth >= nMaxwidth
      nPos--
   endif

   nPos := Max( 1, nPos )










return nPos



UTILITY STATIC function TXBrowse_ColStretch( nStretchCol) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aSizes, nDispWidth, nBrwWidth, oCol, nLen, n, o
   local nMaxWidth   := 0

   if ! ::lAdjusted
      return nil
   endif

   if ::aStretchInfo <> nil
      for n := 1 to Len( ::aCols )
         if ::aCols[ n ]:nCreationOrder == ::aStretchInfo[ 1 ]
            ::aCols[ n ]:nWidth  := ::aStretchInfo[ 2 ]
            exit
         endif
      next
      ::aStretchInfo := nil
   endif

   IIF( nStretchCol == nil, nStretchCol := ::nStretchCol, ) ;

   if nStretchCol <> nil
      nDispWidth  := ::GetDisplayColsWidth( @aSizes )
      nBrwWidth   := ::BrwWidth()

      if nDispWidth < nBrwWidth
         nLen        := Len( ::aDisplay )
         do case
         case ::nStretchCol > 0
            if ( n  := AScan( ::aDisplay, { |nCol| ::aCols[ nCol ]:nCreationOrder == ::nStretchCol } ) ) > 0
               oCol     := ::aCols[ ::aDisplay[ n ] ]
            endif
         case ::nStretchCol == -1
            oCol        := ::aCols[ ::aDisplay[ nLen ] ]
         case ::nStretchCol == -2
            for n := nLen to 1 step -1
               o        := ::aCols[ ::aDisplay[ n ] ]
               if o:cDataType <> nil .AND. o:cDataType $ "FMP"
                  oCol  := o
                  exit
               elseif o:cDataType == "C" .OR. o:cDataType == nil
                  if o:nWidth > nMaxWidth
                     nMaxWidth   := o:nWidth
                     oCol        := o
                  endif
               endif
            next
            if oCol == nil
               oCol     := ::aCols[ ::aDisplay[ nLen ] ]
            endif
         endcase
      endif

      if oCol <> nil
         ::aStretchInfo    := { oCol:nCreationOrder, oCol:nWidth }
         oCol:nWidth       += ( nBrwWidth - nDispWidth - 1 )

         if ! Empty( oCol:aRows )
            AEval( oCol:aRows, { |o| o:nWidth := oCol:nWidth } )
         endif

         ::GetDisplayCols()
      endif
   endif

return nil



UTILITY STATIC function TXBrowse_KeyDown( nKey, nFlags) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol

   do case
   case nKey == 27
        if ::lEditMode
           oCol := ::SelectedCol()
           if oCol:oEditLbx <> nil
              oCol:oEditLbx:nLastKey = 27
           endif
           if oCol:oEditGet <> nil
              oCol:oEditGet:nLastKey := 27
           endif
           ::CancelEdit()
           return 0
        else
           return ::TControl:KeyDown( nKey, nFlags )
        endif


   case nKey == 37  .AND. GetKeyState( 16 ) .OR.  nKey == 39 .AND. GetKeyState( 16 )
        return ::TControl:KeyDown( nKey, nFlags )

     case nKey == 38 .AND. GetKeyState( 16 )
        ::Select( 5 )
        ::GoUp()
        ::Select( 5 )

     case nKey == 40 .AND. GetKeyState( 16 )
        ::Select( 5 )
        ::GoDown()
        ::Select( 5 )

   case nKey == 38
      ::Select( 0 )
      ::GoUp()
      ::Select( 1 )

   case nKey == 40
      ::Select( 0 )
      ::GoDown()
      ::Select( 1 )

   case nKey == 37

      if GetKeyState( 17 )
         ::GoLeftMost()
      else
         ::GoLeft()
      endif

   case nKey == 39

      if GetKeyState( 17 )
         ::GoRightMost()
      else
         ::GoRight()
      endif

   case nKey == 36
         ::Select( 0 )
         ::GoTop()
         ::Select( 1 )

   case nKey == 35
         ::Select( 0 )
         ::GoBottom()
         ::Select( 1 )

   case nKey == 33
         ::Select( 0 )
         if GetKeyState( 17 )
            ::GoTop()
         else
            ::PageUp()
         endif
         ::Select( 1 )

   case nKey == 34
         ::Select( 0 )
         if GetKeyState( 17 )
            ::GoBottom()
         else
            ::PageDown()
         endif
         ::Select( 1 )

   case nKey == 107 .AND. GetKeyState( 17 )
         ::FontSize( +1 )
         ::Refresh()

   case nKey == 109 .AND. GetKeyState( 17 )
         ::FontSize( -1 )
         ::Refresh()

   case ::lAllowCopy .AND. nKey == ASC( "C" ) .AND. GetKeyState( 17 )
         ::Copy()

   case nKey == 113 .AND. ::lF2KeyToEdit
        if ! ::lEditMode
            ::SelectedCol():Edit()
        endif

   otherwise

      return ::TControl:KeyDown( nKey, nFlags )

   endcase

return 0



UTILITY STATIC function TXBrowse_KeyChar( nKey, nFlags) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol, cKey, uRet
   local oClp, uClip

   oCol := ::SelectedCol()
   if oCol:lAutoSave
      if oCol:oEditGet <> nil
         oCol:oEditGet:SetFocus()
         return 0
      endif
   endif

   if ::bKeyChar <> nil
      uRet  := Eval( ::bKeyChar, @nKey, nFlags )
      if ::lEditMode
         return nil
      endif
      if ValType( uRet ) == "N" .AND. uRet == 0
         return 0
      endif
   endif

   do case















      case nKey == 13
         oCol := ::SelectedCol()
         if oCol:oEditGet <> nil
            PostMessage( oCol:oEditGet:hWnd, 256, nKey )
         elseif oCol:lEditable .AND. ! oCol:hChecked .AND. ::lEnterKey2Edit .AND. ! ( oCol:nEditType == 2 )
            return oCol:Edit()
         elseif oCol:nEditType == 2 .AND. oCol:lEditable

            PostMessage( oCol:oBtnList:hWnd, 513, 1, 1 )
            PostMessage( oCol:oBtnList:hWnd, 514, 1, 1 )
         elseif ::oTreeItem<>nil
            IIF( ::oTreeItem:oTree <> nil, ( ::oTreeItem:Toggle(), ::Refresh() ), )
         else
            ::GoRight()
         endif

      case nKey == 18
         ::oVScroll:PageUp()

      case nKey == 3
         ::oVScroll:PageDown()

      case ::lCanPaste .AND. nKey == 22

         if ::SelectedCol():cDataType == "P"
            oClp := TClipBoard():New( Upper("BITMAP"), ::oWnd )
            uClip     := oClp:GetBitmap()
            if uClip <> 0 .AND. ::SelectedCol():nEditType > 0
               ::SelectedCol():PostEdit( BmpToStr( uClip ) )
               oClp:Clear()
            endif
            oClp:End()
         endif

         oClp := TClipBoard():New( Upper("TEXT"), ::oWnd )
         uClip    := oClp:GetText()
         if ! Empty( uClip )
           oClp:Clear()
         endif
         oClp:End()
         if ! Empty( uClip )
            ::Paste( uClip )
         endif

      otherwise

         cKey := Chr( nKey )
         oCol := ::SelectedCol()

         if nKey == 32 .AND. ::nMarqueeStyle <= 3 .AND.  oCol:hChecked .AND. oCol:lEditable

            oCol:CheckToggle()



         elseif ( ::lFastEdit .OR. nKey == Asc( "=" ) ) .AND.  ( ::nMarqueeStyle <= 3 .OR. ::bClrRowFocus <> nil ) .AND.  oCol:lEditable .AND. oCol:IsEditKey( cKey )

            oCol:Edit( nKey )

         else
            If nKey == 8 .AND. !Empty( ::cSeek )
               ::Seek( Left( ::cSeek, Len( ::cSeek ) -1 ) )
            elseIf nKey > 31
               ::Seek( ::cSeek + cKey )
            Endif
         Endif
   endcase

return 0



UTILITY STATIC function TXBrowse_HScroll( nWParam, nLParam) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nScrHandle  := nLParam
   local nScrollCode := nLoWord( nWParam )
   local nPos        := nHiWord( nWParam )

   if GetFocus() <> ::hWnd
      SetFocus( ::hWnd )
   endif

   do case
   case nScrollCode == 0
      ::GoLeft()

   case nScrollCode == 1
      ::GoRight()

   case nScrollCode == 2
      ::GoLeft( .T. )

   case nScrollCode == 3
      ::GoRight( .T. )

   case nScrollCode == 6
      ::GoLeftMost()

   case nScrollCode == 7
      ::GoRightMost()

   case nScrollCode == 4




      ::SelectCol( Min( nPos, Len( ::aCols ) ), .T. )

   otherwise
      return nil

   endcase

return 0



UTILITY STATIC function TXBrowse_SelectCol( nCol, lOffset) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   IIF( lOffset == nil, lOffset := .F., ) ;

   if ::nMarqueeStyle == 0 .OR. ( ::nMarqueeStyle >= 5 .AND. ::bClrRowFocus == nil )
      lOffset := .T.
   endif

   ::CancelEdit()
   if ::oHScroll <> nil
      ::oHScroll:SetPos( nCol )
   endif

   If lOffset
      ::nColOffset := Max( nCol - ::nFreeze, 1 )
   else
      ::nColSel    := nCol
   Endif

   ::GetDisplayCols()
   ::nColSel := Min( ::nColSel, ::LastDisplayPos() )
   ::TControl:Refresh( .T. )

return nil



UTILITY STATIC function TXBrowse_GoLeft( lOffset, lRefresh) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   ::CancelEdit()

   if ::nMarqueeStyle == 0  .OR. ( ::nMarqueeStyle >= 5 .AND. ::bClrRowFocus == nil )
      lOffset := .T.
   endif


   IIF( lOffset == nil, lOffset := .F., ) ; IIF( lRefresh == nil, lRefresh := .T., );


   if ( !lOffset .AND. ::IsDisplayPosVisible( ::nColSel - 1 ) ) .OR.  ( ::nColOffset == 1 .AND. ::nColSel > 1 )
      ::nColSel--
      if lRefresh
         if ::FullPaint()
            ::TControl:Refresh( .T. )
         else
            ::DrawLine( .T. )
         endif
      endif
   elseif ::nColOffset > 1
      ::nColOffset--
      ::GetDisplayCols()
      if lRefresh
         ::TControl:Refresh( ::FullPaint() )
      endif
   endif

   if ::oHScroll <> nil
      ::oHScroll:GoUp()
   endif
   ::Change( .F. )

return nil



UTILITY STATIC function TXBrowse_GoRight( lOffset, lRefresh) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol, oLastCol, oNextCol
   local nLen

   ::CancelEdit()

   oLastcol    := ::aCols[ ATail( ::aDisplay ) ]
   if ::SelectedCol():nCreationOrder == oLastCol:nCreationOrder
      return nil
   endif

   if ::nMarqueeStyle == 0 .OR. ( ::nMarqueeStyle >= 5 .AND. ::bClrRowFocus == nil )

   endif


   IIF( lOffset == nil, lOffset := .F., ) ; IIF( lRefresh == nil, lRefresh := .T., );

   nLen := Len( ::aDisplay )

   if lOffSet
      if ::IsDisplayPosVisible( oLastCol:nPos, .T. )
         ::nColSel++
         if lRefresh
            ::TControl:Refresh( .T. )
         endif
      else
         if ::nColOffSet < ( nLen - ::nFreeze )
            ::nColOffSet++
            ::GetDisplayCols()
            if lRefresh
               ::TControl:Refresh( ::FullPaint() )
            endif
         endif
      endif

   else
      ::nColSel++
      ::GetDisplayCols()
      oCol     := ::SelectedCol()
      while ! ::IsDisplayPosVisible( oCol:nPos, .T. ) .AND. ::nColSel > ( ::nFreeze + 1 )
          ::nColOffSet++
         ::nColSel--
         ::GetDisplayCols()
      enddo

      if lRefresh
         ::TControl:Refresh( ::FullPaint() )
      endif

   endif


   if ::oHScroll <> nil
      ::oHScroll:GoDown()
   endif

   ::Change( .F. )

return nil





UTILITY STATIC function TXBrowse_GoLeftMost() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   ::CancelEdit()

   ::nColSel := 1
   ::nColOffset := 1
   ::GetDisplayCols()
   ::TControl:Refresh( ::FullPaint() )

   if ::oHScroll <> nil
      ::oHScroll:SetPos( 1 )
   endif

   ::Change( .F. )

return nil



UTILITY STATIC function TXBrowse_GoRightMost() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oLast, nLast

   ::CancelEdit()

   nLast    := ATail( ::aDisplay )
   oLast    := ::aCols[ nLast ]

   while ! ::IsDisplayPosvisible( oLast:nPos, .T. ) .AND. ( ::nFreeze + ::nColOffSet ) < Len( ::aDisplay )
      ::nColOffSet++
      ::GetDisplayCols()
   enddo
   ::nColSel   := ::aCols[ nLast ]:nPos
   ::TControl:Refresh( ::FullPaint() )

   if ::oHScroll <> nil
      ::oHScroll:SetPos( ::oHScroll:nMax )
   endif
   ::Change( .F. )

return nil



UTILITY STATIC function TXBrowse_VScroll( nWParam, nLParam) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nScrHandle  := nLParam
   local nScrollCode := nLoWord( nWParam )
   local nPos        := nHiWord( nWParam )
   local nRow, nBook

   if GetFocus() <> ::hWnd
      SetFocus( ::hWnd )
   endif

   if nScrHandle == 0 .AND. ::oVScroll <> nil
      do case
      case nScrollCode == 0
         ::GoUp()

      case nScrollCode == 1
         ::GoDown()

      case nScrollCode == 2
         ::PageUp()

      case nScrollCode == 3
         ::PageDown()

      case nScrollCode == 6
         ::GoTop()

      case nScrollCode == 7
         ::GoBottom()


      case nScrollCode == 4 .OR. ( ::lVThumbTrack .AND.  nScrollCode == 5 )
         if ::nLen < 1
            return nil
         endif
         do case
         case nPos == 1
            ::GoTop()
         case nPos == ::oVScroll:GetRange()[ 2 ]
            ::GoBottom()
         otherwise
            ::CancelEdit()
            nRow := ::nRowSel
            CursorWait()

            ::KeyNo( ::VGetThumbPos( nPos ) )
            CursorArrow()
            nBook := Eval( ::bBookMark )
            while nRow > 0 .AND. ::Skip( -1 ) == -1
               nRow--
            enddo
            ::nRowSel := ::nRowSel - nRow
            Eval( ::bBookMark, nBook )
            ::Change( .T. )
            ::VThumbPos( nPos )
            ::lRefreshOnlyData := .F.
            ::TControl:Refresh( .F. )
         endcase

      otherwise
         return nil
      endcase
   endif

return 0



UTILITY STATIC function TXBrowse_GoUp( nUp) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nHeight, n, oCol, nAt

   if ::nLen == 0 .OR. ::Bof()
      return nil
   endif

   ::CancelEdit()
   if !::FullPaint()
      ::DrawLine()
   endif
   ::Seek()

   IIF( nUp == nil, nUp := 1, ) ;

   if ( oCol := ::SelectedCol() ):lMergeVert
      nAt      := ::KeyNo()
      nUp      := oCol:aMerge[ nAt ][ 1 ] + 1
      if ( nAt - nUp ) > 0
         nUp   += oCol:aMerge[ nAt - nUp ][ 1 ]
      endif
   endif

   for n := 1 to nUp

      if ::Skip( -1 ) == -1

         if ::nRowSel > 1
            ::nRowSel--
         else
            if ! ::FullPaint()

               XBrwScrollRow( ::hWnd, -::nRowHeight, ::HeaderHeight(), ::RowCount() * ::nRowHeight )
               if n < nUp
                  ::DrawLine( .F. )
               endif

               nHeight := ::BrwHeight() - ::FooterHeight() - ::HeaderHeight()
               If nHeight % ::nRowHeight > 0

                  ::EraseData( ::HeaderHeight() + ::nRowHeight * ::RowCount() )
               Endif

            endif
            If ::nDataRows < ::RowCount()
               ::nDataRows++
            Endif

         endif
      else
         exit
      endif

   next

   if ! ::FullPaint()
      ::DrawLine( .T. )
   endif

   nUp   := n - 1

   if nUp > 0
      ::Change( .T. )
      if ::FullPaint()
         ::TControl:Refresh( .T. )
      endif

      if ::oVScroll <> nil
         for n := 1 to nUp
            ::VGoUp()
         next
      endif
   endif

return nil



UTILITY STATIC function TXBrowse_GoDown( nDown) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nLines, n, oCol, nAt

   if ::nLen == 0 .OR. ::Eof()
      if ::bPastEof <> nil
         Eval( ::bPastEof )
      endif
      return nil
   endif

   ::CancelEdit()
   ::Seek()

   IIF( nDown == nil, nDown := 1, ) ;

   if ( oCol := ::SelectedCol() ):lMergeVert
      nAt         := ::KeyNo()
      nDown       := oCol:aMerge[ nAt ][ 2 ] + 1
      if ( nAt + nDown ) < ::nLen
         nDown    += oCol:aMerge[ nAt + nDown ][ 2 ]
      endif
   endif

   nLines := ::RowCount()

   if ! ::FullPaint()
      ::DrawLine()
   endif

   for n := 1 to nDown

      if ::Skip( 1 ) == 1
         if ::nRowSel < nLines
            ::nRowSel++
         else

            if ! ::FullPaint()
               XBrwScrollRow( ::hWnd, ::nRowHeight, ::HeaderHeight(), nLines * ::nRowHeight )
               if n < nDown
                  ::DrawLine( .F. )
               endif
            endif

         endif
         if ::oVScroll <> nil
            ::VGoDown()
         endif
      else
         if ::bPastEof <> nil .AND. nDown == 1
            Eval( ::bPastEof )
         endif
         if ::oVScroll <> nil
            ::VGoBottom()
         endif
         exit
      endif

   next
   nDown    := n - 1

   if ! ::FullPaint()
      ::DrawLine( .T. )
   endif

   if nDown > 0
      ::Change( .T. )
      if ::FullPaint()
         ::TControl:Refresh( .T. )
      endif
   endif

return nil



UTILITY STATIC function TXBrowse_PageUp( nLines) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nSkipped

   if ::nLen < 1
      return nil
   endif

   IIF( nLines == nil, nLines := ::RowCount(), ) ;

   ::CancelEdit()
   ::Seek()


   nSkipped = ::Skip( -nLines )

   if nSkipped = 0

      return nil
   endif

   if -nSkipped < nLines
      ::nRowSel = 1
      ::Change( .T. )

      ::TControl:Refresh( ::FullPaint() )

      if ::oVScroll <> nil
         ::VGoTop()
      endif
   else
      if ::KeyNo() < ::nRowSel
         ::KeyNo( ::nRowSel )
      endif
      ::Change( .T. )

      ::TControl:Refresh( ::FullPaint() )

      if ::oVScroll <> nil
         ::VSetPos( ::VGetPos() + nSkipped )
      endif
   endif

return nil



UTILITY STATIC function TXBrowse_PageDown( nLines) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nSkipped

   if ::nLen < 1
      return nil
   endif

   IIF( nLines == nil, nLines := ::RowCount(), ) ;

   ::CancelEdit()
   ::Seek()

   nSkipped := ::Skip( nLines )
   if nSkipped > 0
      ::Change( .T. )
      if nSkipped < nLines
         ::Refresh()
         if ::oVScroll <> nil
            ::VGoBottom()
         endif
      else
         ::TControl:Refresh( ::FullPaint() )
         if ::oVScroll <> nil
            ::VSetPos( ::VGetPos() + nSkipped )
         endif
      endif
   endif

return nil



UTILITY STATIC function TXBrowse_KeyNo(nGoTo) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse
return Eval( ::bKeyNo, nGoTo, Self )



UTILITY STATIC function TXBrowse_BookMark(uBm) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse
return Eval( ::bBookMark, uBm )



UTILITY STATIC function TXBrowse_GoTop() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   if ::Bof() .OR. ::nLen < 1
      return nil
   endif

   ::CancelEdit()
   ::Seek()



   Eval( ::bGoTop )

   if ::oVScroll <> nil
      ::VGoTop()
   endif

   ::nRowSel := 1
   ::Change( .T. )


   ::TControl:Refresh( .F. )

return nil



UTILITY STATIC function TXBrowse_GoBottom( lNoRefresh) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nLines, nRow, nBook

   IIF( lNoRefresh == nil, lNoRefresh := .F., ) ;

   ::CancelEdit()
   ::Seek()
   ::DrawLine()

   if ::Eof() .OR. ::nLen < 1
      ::DrawLine( .T. )
      return nil
   endif

   nLines := ::RowCount()
   nRow   := nLines

   Eval( ::bGoBottom )

   nBook := Eval( ::bBookMark )

   while nRow-- > 0 .AND. ::Skip( -1 ) == -1
   enddo

   ::nRowSel := nLines - nRow

   Eval( ::bBookMark, nBook )

   if ::oVScroll <> nil
      ::VGoBottom()
   endif
   ::Change( .T. )
   If lNoRefresh
      ::KeyCount()
      ::lRefreshOnlyData := .T.
      ::TControl:Refresh( .T. )
   else
      ::TControl:Refresh( .F. )
   Endif

return nil



UTILITY STATIC function TXBrowse_ColPos( oCol) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nAt

   nAt := Ascan( ::aDisplay, {|v| ::ColAtPos( v ):nCreationOrder == oCol:nCreationOrder } )

return nAt



UTILITY STATIC function TXBrowse_MouseAtHeader( nRow, nCol) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

return ( ::MouseColPos( nCol ) > 0 .AND. nRow < ::HeaderHeight() )



UTILITY STATIC function TXBrowse_MouseAtFooter( nRow, nCol) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

return ( ::MouseColPos( nCol ) > 0 .AND. nRow > ( ::BrwHeight() - ::FooterHeight() ) )



UTILITY STATIC function TXBrowse_MouseRowPos( nRow) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nRowPos, nTmp

   if nRow <= ::HeaderHeight()
      return 0
   endif

   nTmp    := nRow - ::HeaderHeight()
   nRowPos := Int( nTmp / ::nRowHeight ) + 1

   if nRowPos > ::nDataRows
      nRowPos := 0
   endif

return nRowPos



UTILITY STATIC function TXBrowse_MouseColPos( nCol) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nWidth, nColPos, nLen, nFor

   nColPos   := 0
   nLen      := ::LastDisplayPos()

   if ::lRecordSelector
      nWidth := ::nRecSelWidth
   else
      nWidth := 0
   endif

   if nCol < nWidth
      return -1
   endif

   if nCol > nWidth
      for nFor := 1 to nLen
         nWidth += ::ColAtPos( nFor ):nWidth + 2
         if ( nWidth - 2 ) > nCol
            nColPos := nFor
            exit
         endif
      next
   endif

return nColPos



UTILITY STATIC function TXBrowse_SetPos( nRow, nCol, lPixel) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local lRepos   := .F.
   local bm, nSkip := 0

   IIF( lPixel == nil, lPixel := .F., ) ;

   if nRow == nil
      nRow        := ::nRowSel
   elseif lPixel
      nRow        := ::MouseRowPos( nRow )
   endif
   if nCol == nil
      nCol        := ::nColSel
   elseif lPixel
      ncol        := ::MouseColPos( nCol )
   endif


   if nCol > 0 .AND. nCol <= ::LastDisplayPos( .F. ) .AND.  nRow > 0 .AND. nRow <= ::RowCount()

      if ::nColSel <> nCol
         ::nColSel  := nCol
         lRepos      := .T.
      endif

      if nRow > 0 .AND. nRow <> ::nRowSel

         ::CancelEdit()
         ::Seek()

         if ::lMultiSelect
            ::Select(0)
         endif
         SysRefresh()
         ::DrawLine()

         bm          := Eval( ::bBookMark )
         nSkip     := nRow - ::nRowSel
         if ::Skip( nSkip ) == nSkip
            ::nRowSel := nRow
            ::Change( .T. )
            lRepos      := .T.
         else
            Eval( ::bBookMark, bm )
            nSkip := 0
         endif

         if ::lMultiSelect
            ::Select(1)
         endif

         if ::FullPaint()
            ::TControl:Refresh( .T. )
         else
            ::DrawLine( .T. )
         endif
         ::Change( .T. )
      endif

      if nSkip <> 0 .AND. ::oVScroll <> nil
         ::VSetPos( ::KeyNo() )
      endif

      if ::oHScroll <> nil
         ::oHScroll:SetPos( ::nColSel )
      endif

   endif

return lRepos



UTILITY STATIC function TXBrowse_LButtonDown( nRow, nCol, nFlags) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nRowPos, nColPos, nLen, nFor, nTmp, nPos
   local nRowPrev,nColPrev
   local nOldCol := ::nColSel

   ::nRowAdvance = ::MouseRowPos( nRow )
   ::nColAdvance = ::MouseColPos( nCol )
   ::nStartMRow  = ::nRowAdvance
   if ! ::lKinetic
      ::lKineticBrw  := .F.
   endif
   ::lPressed    = ::lKineticBrw .AND. ::bDragBegin == nil
   ::nStartTime  = GetTickCount()

   ::CancelEdit()
   ::Seek()

   ::SetFocus()

   if ::lDrag
      return ::TControl:LButtonDown( nRow, nCol, nFlags )
   endif

   nRowPrev  := ::nRowSel
   nColPrev  := ::nColSel
   nRowPos   := 0
   nColPos   := 0
   nLen      := ::LastDisplayPos()

   for nFor := 1 to nLen
      oCol := ::ColAtPos( nFor )



      if oCol:lAllowSizing .AND.  nCol >= ( oCol:nDisplayCol + oCol:nWidth - 1 ) .AND.  nCol <= ( oCol:nDisplayCol + oCol:nWidth + 1 ) .AND.  ( ::nColDividerStyle > 0 .OR. nRow < ::HeaderHeight() )
         oCol:ResizeBeg( nRow, nCol, nFlags )
         return nil
      endif
   next

   nLen := ::nDataRows


   if ::lAllowRowSizing .AND. ::nRowDividerStyle > 0 .AND.  ( ::MouseColPos( nCol ) > 0 .OR. ::nMarqueeStyle >= 4 )
      for nFor := 1 to nLen
         nPos := ( nFor * ::nRowHeight ) + ::HeaderHeight()
         if nRow >= ( nPos - 1 ) .AND. nRow <= ( nPos + 1 )
            ::HorzLine( nRow, 1, nFor )
            return 0
         endif
      next
   endif

   nColPos := ::MouseColPos( nCol )

   if nColPos == 0 .AND. ::nMarqueeStyle < 4
      ::TControl:LButtonDown( nRow, nCol, nFlags )
      return nil
   endif

   if nRow < ::HeaderHeight() .AND. nColPos > 0
      oCol := ::ColAtPos( nColPos )
      if oCol <> nil
         oCol:HeaderLButtonDown( nRow, nCol, nFlags )
      else
         ::TControl:LButtonDown( nRow, nCol, nFlags )
      endif
      return nil
   elseif nRow > ( ::BrwHeight() - ::FooterHeight() ) .AND. nColPos > 0
      oCol := ::ColAtPos( nColPos )
      if oCol <> nil
         oCol:FooterLButtonDown( nRow, nCol, nFlags )
      else
         ::TControl:LButtonDown( nRow, nCol, nFlags )
      endif
      return nil
   else
      nTmp    := nRow - ::HeaderHeight()
      nRowPos := Int( nTmp / ::nRowHeight ) + 1
      if nRowPos > ::nDataRows .OR. nRow < ::HeaderHeight()
         nRowPos := 0
      endif
      if nRowPos == 0
         ::TControl:LButtonDown( nRow, nCol, nFlags )
         return nil
      endif
   endif

   if nRowPos > 0 .OR. nColPos > 0

      if ::nMarqueeStyle == 3
         if GetKeyState( 16 )
            ::nMarqueeStyle := 6
            ::aSelected := { Eval( ::bBookMark ) }
            ::nSaveMarq := 3
         endif
      endif
      if ::lMultiSelect
         if !GetKeyState( 17 ) .AND. !GetKeyState( 16 )
            ::Select( 0 )
         endif
      endif


      ::DrawLine()

      if nRowPos > 0
         ::Skip( nRowPos - ::nRowSel )
         ::nRowSel := nRowPos

      endif

      if nColPos > 0
         ::nColSel := nColPos
      endif

      if ::nRowSel <> nRowPrev
         ::Change( .T. )
      elseif ::nColSel <> nColPrev
         ::Change( .F. )
      endif

      if ::lMultiSelect
         do case
         case GetKeyState( 17 )
            ::Select( 2 )
         case GetKeyState( 16 )
             ::Select( 3 )
         otherwise
            ::Select( 1 )
         endcase
      endif

      if ::FullPaint()
         ::TControl:Refresh( .T. )
      else
         ::DrawLine( .T. )
      endif

      if ::oVScroll <> nil
         ::VSetPos( ::KeyNo() )
      endif

      if ::oHScroll <> nil
         ::oHScroll:SetPos( ::nColSel )
      endif

   endif

   if ::MouseRowPos( nRow ) <> 0 .AND. ::MouseColPos( nCol ) <> 0
      ::TControl:LButtonDown( nRow, nCol, nFlags )
   endif

return 0



UTILITY STATIC function TXBrowse_LButtonUp( nRow, nCol, nFlags) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nCaptured
   local nRowAdvanced, nTimeScrolled, nVelocity, nRowToAdvance
   local nRatio, n, cMsg := ""

   if ::lDrag
      return ::TControl:LButtonUp( nRow, nCol, nFlags )
   endif

   if ::lPressed
      ::lPressed    = .F.
      ::nEndMRow    = ::MouseRowPos( nRow )
      ::nEllapsed   = GetTickCount()

      nRowAdvanced  = ::nEndMRow - ::nStartMRow
      nTimeScrolled = ( ::nEllapsed - ::nStartTime ) / 4000
      nTimeScrolled = If( nTimeScrolled == 0, 1, nTimeScrolled )

      nVelocity     =  int( abs( nRowAdvanced ) / nTimeScrolled )

      if nVelocity > ::nMinVelocity
         nRowToAdvance = min( ::nMaxRowToAdvance, nVelocity * 0.125 )

         nRatio   = ( ::nStopRatio * ::nMaxRowToAdvance / nRowToAdvance )
         ::lMoved = .T.
         if nRowAdvanced > 0
            ::Skip( 1 - ::nRowSel )
            ::nRowSel = 1
         elseif nRowAdvanced < 0
            ::Skip( ::nDataRows - ::nRowSel )
            ::nRowSel   = Min( ::nLen, ::Rowcount() )
         endif
         for n = 1 to nRowToAdvance
            if ! ::lMoved
               exit
            endif
            if nRowAdvanced > 0
               ::GoUp()
               if ::KeyNo() == 1
                  exit
               endif
            elseif nRowAdvanced < 0
               ::GoDown()
               if ::KeyNo() >= ::nLen
                  exit
               endif
            endif
            ::Refresh()
            Sleep( Min( 120, n * nRatio ) )
            if PeekMessage( @cMsg, ::hWnd, 0x201, 0x202, 0x0001 )
               ::lPressed = .F.
               exit
            endif
            SysRefresh()
         next

      endif
      ::lMoved = .F.

      ::Refresh()
      ::nStartTime      = 0
      ::nStartMRow      = 0

   endif

   if ::nCaptured > 0
      nCaptured   := ::nCaptured
      ::nCaptured := 0
      ReleaseCapture()
      do case
         case nCaptured == 1
              ::oCapCol:HeaderLButtonUp( nRow, nCol, nFlags )

         case nCaptured == 2
              if ::oCapCol <> nil
                 ::oCapCol:FooterLButtonUp( nRow, nCol, nFlags )
              endif

         case nCaptured == 3
              ::oCapCol:ResizeEnd( nRow, nCol, nFlags )

         case nCaptured == 4
              ::HorzLine( nRow, 2 )
      endcase
      ::oCapCol := nil
   endif

   ::TControl:LButtonUp( nRow, nCol, nFlags )

return nil



UTILITY STATIC function TXBrowse_MouseLeave( nRow, nCol, nFlags) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   ::lPressed = .F.

   ::Refresh()

return nil



UTILITY STATIC function TXBrowse_MouseMove( nRow, nCol, nKeyFlags) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nLen, nFor, nPos
   local cTxt
   local nVMove, nHMove, nOldRowPos,  nOldColPos
   local nMousePos := ::MouseRowPos( nRow )

   TrackMouseEvent( ::hWnd, 2 )

   if ::lDrag .OR. ::lEditMode
      return ::TControl:MouseMove( nRow, nCol, nKeyFlags )
   endif

   if ::oCapCol <> nil
      ::oCapCol:MouseMove( nRow, nCol, nKeyFlags )
      return 0
   endif

   if ::nCaptured == 4
      ::HorzLine( nRow, 3 )
      return 0
   endif

   if ::lPressed

      TrackMouseEvent( ::hWnd, 2 )

      if ::nStartTime == 0
         ::nStartTime := GetTickCount()
      endif
   else
      ::nStartTime := 0
      ::nEllapsed := 0
   endif

   if ::lPressed .AND. ! ::lCaptured

      WSetCursor( ::hCursorHand )

      nVMove        = ::nRowAdvance - ::MouseRowPos( nRow )
      ::nRowAdvance = nMousePos
      nHMove        = ::MouseColPos( nCol ) - ::nColAdvance

      if nHMove < 0
         ::nColSel := ::LastDisplayPos( .T. )
         ::GoRight()
         ::nColSel := ::MouseColPos( nCol )
      elseif nHMove > 0
         ::nColSel := 1
         ::GoLeft()
         ::nColSel := ::MouseColPos( nCol )
      endif

      ::nColAdvance = ::MouseColPos( nCol )

      if nVMove > 0

         if ::lDown
            ::nStartMRow = nMousePos
            ::nStartTime := GetTickCount()
         endif
         nOldRowPos = ::nRowSel

         if ::cAlias == "ARRAY"
            ::nArrayAt += ( ::RowCount() - ::nRowSel )
         endif

         ::nRowSel =  ::RowCount()
         if ::cAlias == "ARRAY"
            ::lDrawSelected = .F.
            ::GoDown()
         endif
         ::Refresh()
         ::nRowSel = Max( 1, nOldRowPos - 1 )

         if ::cAlias == "ARRAY"
            ::nArrayAt-= ( ::RowCount() - ::nRowSel )
         else
            if ( ::nLen - ::RowCount() + ::nRowSel + 1)  <= ::KeyNo()
               ::Skip( -1 )
            endif
         endif

         ::lDrawSelected = .T.
         ::Refresh()
         ::lDown = .F.
      elseif nVMove < 0
         if ! ::lDown
            ::nStartMRow = nMousePos
            ::nStartTime := GetTickCount()
         endif
         nOldRowPos = ::nRowSel

         if ::cAlias == "ARRAY"
            ::nArrayAt -= ( ::RowCount() - ::nRowSel )
         endif

         ::nRowSel = 1
         if ::cAlias == "ARRAY"
            ::lDrawSelected = .F.
            ::GoUp()
         endif
         ::Refresh()
         ::nRowSel = nOldRowPos + 1
         if ::cAlias == "ARRAY"
            ::nArrayAt+= ( ::RowCount() - ::nRowSel )
         else
            if ( ::KeyNo() == ::nRowSel - 1)
               ::Skip( )
               ::nRowSel = ::KeyNo()
            endif
         endif

         ::lDrawSelected = .T.
         ::Refresh()
         ::lDown = .T.
      endif

      if ::nRowSel <> nMousePos
         ::nRowSel = nMousePos
      endif
      return nil

   endif

   nLen := ::LastDisplayPos()

   for nFor := 1 to nLen
      oCol := ::ColAtPos( nFor )



      if oCol:lAllowSizing .AND.  nCol >= ( oCol:nDisplayCol + oCol:nWidth - 1 ) .AND.  nCol <= ( oCol:nDisplayCol + oCol:nWidth + 1 ) .AND.  ( ::nColDividerStyle > 0 .OR. nRow < ::HeaderHeight() )
         CursorWE()
         return 0
      endif
   next

   nFor     := If( nRow < ::HeaderHeight(), ::MouseColPos( nCol ), 0 )


   if nFor > 0 .AND. nFor <= nLen
      oCol  := ::ColAtPos( nFor )
      CursorArrow()
      if Empty( oCol:cToolTip )
         ::DestroyToolTip()
      else
         if ::oColToolTip == nil .OR. ::oColToolTip:nCreationOrder <> oCol:nCreationOrder
            ::DestroyToolTip()
            ::ShowToolTip( nRow,nCol, oCol:cToolTip )
            ::oColToolTip := oCol
         endif
      endif
      return 0

   elseif ::bDragBegin == nil .AND. ( nFor := If( nRow > ::HeaderHeight(), ::MouseColPos( nCol ), 0 ) ) > 0
       if nFor > 0 .AND. nFor <= nLen
         oCol  := ::ColAtPos( ::MouseColPos( nCol ) )
         CursorArrow()
         if  ::MouseColPos( nCol ) > 0
                  if Empty( oCol:bToolTip )
                     ::DestroyToolTip()
                  else
                  if ::oColToolTip == nil .OR. ::oColToolTip:nCreationOrder <> oCol:nCreationOrder
                       cTxt := eval( oCol:bToolTip, Self, nRow, nCol, nkeyFlags )
                        if !empty( cTxt )
                           ::DestroyToolTip()
                           ::ShowToolTip( nRow,nCol, cTxt )
                           ::oColToolTip := oCol
                        endif
                     endif
                  endif
            endif
            return 0
         endif
      else
      if ::oColToolTip <> nil
         ::DestroyToolTip()
      endif
      ::CheckToolTip()
   endif

   nLen := ::nDataRows


   if ::lAllowRowSizing .AND. ::nRowDividerStyle > 0 .AND.  ( ::MouseColPos( nCol ) > 0 .OR. ::nMarqueeStyle >= 4 )
      for nFor := 1 to nLen
         nPos := ( nFor * ::nRowHeight ) + ::HeaderHeight()
         if nRow >= ( nPos - 1 ) .AND. nRow <= ( nPos + 1 )
            CursorNS()
            return 0
         endif
      next
   endif

   ::TControl:MouseMove( nRow, nCol, nKeyFlags )

return 0



UTILITY STATIC function TXBrowse_LDblClick( nRow, nCol, nKeyFlags) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nColPos, nRowPos

   ::CancelEdit()
   ::Seek()

   nColPos := ::MouseColPos( nCol )
   nRowPos := ::MouseRowPos( nRow )

   if nColPos == ::nColSel .AND. nRowPos == ::nRowSel
      oCol := ::ColAtPos( nColPos )
      if oCol:lEditable .AND. oCol:bLDClickData == nil
         if oCol:hChecked .AND. oCol:bOnPostEdit <> nil

            oCol:CheckToggle()
            return 0
         else
            return oCol:Edit()
         endif
      elseif oCol:bLDClickData <> nil
         return Eval( oCol:bLDClickData, nRow, nCol, nKeyFlags, oCol )
      elseif ValType( oCol:Value ) $ "AHO"

         return XBrowse( oCol:Value, oCol:cHeader, nil, nil, nil, nil, nil,  oCol:nEditType > 0 )
      endif
   endif

   If nColPos <> 0 .AND. nRowPos <> 0
      return ::TControl:LDblClick( nRow, nCol, nKeyFlags )
   Endif

return 0



UTILITY STATIC function TXBrowse_RButtonDown( nRow, nCol, nKeyFlags) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nColPos, nRowPos
   local bPopUp

   ::CancelEdit()
   ::Seek()

   nRowPos := ::MouseRowPos( nRow )
   nColPos := ::MouseColPos( nCol )

   if nColPos <= 0
      if nRow >= ::FirstRow()
         ::TControl:RButtonDown( nRow, nCol, nKeyFlags )
         return nil
      else
         if ::lAllowColHiding
            ::SetColumns( nRow, nCol, nKeyFlags )
         endif
         return nil
      endif
   endif

   oCol     := ::ColAtPos( nColPos )
   bPopUp   := ifnil( oCol:bPopUp, ::bPopUp )

   if ::MouseAtHeader( nRow, nCol )
      if oCol:bRClickHeader <> nil
         return Eval( oCol:bRClickHeader, nRow, nCol, nKeyFlags, oCol )
      elseif ::lAllowColHiding
         return ::SetColumns( nRow, nCol, nKeyFlags )
      endif
   elseif ::MouseAtFooter( nRow, nCol )
      if oCol:bRClickFooter <> nil
         return Eval( oCol:bRClickFooter, nRow, nCol, nKeyFlags, oCol )
      endif
   elseif nRowPos > 0
      if nRowPos <> ::nRowSel
         if ! ::FullPaint()
            ::DrawLine()
         endif
         ::Skip( nRowPos - ::nRowSel )
         ::nRowSel := nRowPos
         if nColPos > 0
            ::nColSel   := nColPos
         endif
         ::Change( .T. )
      elseif nColPos > 0 .AND. ::nColSel <> nColPos
         ::nColSel := nColPos
         ::Change( .F. )
      endif
      if Len( ::aSelected ) > 0 .AND. AScan( ::aSelected, ::BookMark ) == 0
         ::Select( 0 )
         ::Select( 1 )
      endif
      if ::FullPaint()
         ::TControl:Refresh( .T. )
      else
         ::DrawLine( .T. )
      endif
      if ::oVScroll <> nil
         ::VSetPos( ::KeyNo() )
      endif
      if ::oHScroll <> nil
         ::oHScroll:SetPos( ::nColSel )
      endif
      if bPopUp <> nil
         Eval( bPopUp, oCol ):Activate( (::nRowSel * ::nRowHeight) + ::nHeaderHeight, oCol:nDisplayCol, Self )
         return 0
      elseif oCol:bRClickData <> nil
         return Eval( oCol:bRClickData, nRow, nCol, nKeyFlags, oCol )
      endif
   endif

   If nColPos <> 0 .AND. nRowPos <> 0
      return ::TControl:RButtonDown( nRow, nCol, nKeyFlags )
   endif

return 0



UTILITY STATIC function TXBrowse_MouseWheel( nKeys, nDelta, nXPos, nYPos) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aPoint := { nYPos, nXPos }

   ScreenToClient( ::hWnd, aPoint )


   if IsOverWnd( ::hWnd, aPoint[ 1 ], aPoint[ 2 ] ) .AND.  ::MouseRowPos( aPoint[ 1 ] ) > 0

      if lAnd( nKeys, 0x0010 )
         if nDelta > 0
            ::PageUp()
         else
            ::PageDown()
         endif
      else
         if nDelta > 0
            ::GoUp( WheelScroll() )
         else
            ::GoDown( WheelScroll() )
         endif
      endif

   endif

Return nil



UTILITY STATIC function TXBrowse_HorzLine( nRow, nOperation, nLine) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   static sLine := 0, sRow := 0

   local hDC, nTop

   if nLine <> nil
      sLine := nLine
   endif

   do case
   case nOperation == 1
      ::nCaptured = 4
      ::Capture()
      sRow := nRow
      InvertRect( ::GetDC(), { nRow - 1, 0 , nRow + 1, ::BrwWidth() } )
      ::ReleaseDC()

   case nOperation == 2
      nTop := ( sLine * ::nRowHeight ) + ::HeaderHeight()
      InvertRect( ::GetDC(), { sRow - 1, 0 , sRow + 1, ::BrwWidth() } )
      ::ReleaseDC()
      if Abs( nRow - nTop ) > 2
         nTop := ( ( sLine - 1 ) * ::nRowHeight ) + ::HeaderHeight()
         ::nRowHeight := Min( Max( nRow - nTop, 20 ), ::BrwHeight() - nTop - 20 )
         ::TControl:Refresh()
      endif

   case nOperation == 3
      nTop := ( ( sLine - 1 ) * ::nRowHeight ) + ::HeaderHeight() + 20
      CursorNS()
      if nRow > nTop .AND. nRow < (::BrwHeight() - 20 )
         hDC := ::GetDC()
         InvertRect( hDC, { sRow - 1, 0 , sRow + 1, ::BrwWidth() } )
         sRow := nRow
         InvertRect( hDC, { sRow - 1, 0 , sRow + 1, ::BrwWidth() } )
         ::ReleaseDC()
      endif

   endcase

return nil



UTILITY STATIC function TXBrowse_GetDlgCode( nLastKey) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse




   if ! ::oWnd:lValidating

      if nLastKey == 38 .OR. nLastKey == 40  .OR. nLastKey == 13 .OR. nLastKey == 9
         ::oWnd:nLastKey = nLastKey
      else
         ::oWnd:nLastKey = 0
      endif
   endif

return If( IsWindowEnabled( ::hWnd ), 4, 0 )



UTILITY STATIC function TXBrowse_SetRDD( lAddColumns, lAutoOrder, aFldNames, aRows) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol, aStruct
   local cAlias, cAdsKeyNo, cAdsKeyCount
   local nFields, nFor, n
   local bOnSkip

   if Empty( ::cAlias )
      ::cAlias := Alias()
      if Empty( ::cAlias )
         return nil
      endif
   endif

   if ::lCreated
      if ::nDataType == 1
         if SameDbfStruct( Self, Alias() )
            return nil
         endif
      endif
      ::cAlias := Alias()
      ::ClearBlocks()
      ::aCols  := {}
   endif

   IIF( lAddColumns == nil, lAddColumns := Empty( ::aCols ) .OR. ! Empty( aFldNames ), ) ;
   IIF( lAutoOrder == nil, lAutoOrder := ::lAutoSort, ) ;

   cAlias      := ::cAlias
   if ValType( aRows ) == "A" .AND. Len( aRows ) > 0

      if ValType( aRows[ 1 ] ) == "A"
         bOnSkip        := { | oBrw | ( oBrw:cAlias )->( DbGoTo( oBrw:aArrayData[ oBrw:nArrayAt ][ 1 ] ) ) }
      else
         bOnSkip        := { | oBrw | ( oBrw:cAlias )->( DbGoTo( oBrw:aArrayData[ oBrw:nArrayAt ] ) ) }
      endif
      ::SetArray( aRows, .F., 0, .F., bOnSkip )
      ::nDataType       := nOr( 1, 2 )
      lAutoOrder        := .F.
   else
      ::nDataType := 1
   endif









   IIF( ::bGoTop == nil, ::bGoTop := {|| ( ::cAlias )->( DbGoTop() ) }, ) ; IIF( ::bGoBottom == nil, ::bGoBottom := {|| ( ::cAlias )->( DbGoBottom() ) }, ); IIF( ::bSkip == nil, ::bSkip := {| n | iif( n == nil, n := 1, ), ( ::cAlias )->( DbSkipper( n ) ) }, ); IIF( ::bBof == nil, ::bBof := {|| ( ::cAlias )->( Bof() ) }, ); IIF( ::bEof == nil, ::bEof := {|| ( ::cAlias )->( Eof() ) }, ); IIF( ::bBookMark == nil, ::bBookMark := {| n | iif( n == nil, ( ::cAlias )->( RecNo() ), ( ::cAlias )->( DbGoto( n ) ) ) }, );


   If ( "ADS" $ ( ::cAlias )->( RddName() ) .OR. "ADT" $ ( ::cAlias )->( RddName() ) ) .AND.  ( ::cAlias )->( LastRec() ) > 200









      cAdsKeyNo    := "{| n, Self | iif( n == nil, " + "Round( " + cAlias + "->( ADSGetRelKeyPos() ) * Self:nLen, 0 ), "+ cAlias + "->( ADSSetRelKeyPos( n / Self:nLen ) ) ) }"

      cAdsKeyCount := "{|| " + cAlias + "->( ADSKeyCount(,,1) )}"


      IIF( ::bKeyNo == nil, ::bKeyNo := &cAdsKeyNo, ) ; IIF( ::bKeyCount == nil, ::bKeyCount := &cAdsKeyCount, );
   elseif ( ::cAlias )->( RddName() ) == "SQLRDD"

      IIF( ::bKeyNo == nil, ::bKeyNo := ::bBookMark, ) ; IIF( ::bKeyCount == nil, ::bKeyCount := { || ( ::cAlias )->( LastRec() ) }, );
   else




       IIF( ::bKeyNo == nil, ::bKeyNo := {| n | iif( n == nil, ( ::cAlias )->( OrdKeyNo() ), ( ::cAlias )->( OrdKeyGoto( n ) ) ) }, ) ; IIF( ::bKeyCount == nil, ::bKeyCount := {|| ( ::cAlias )->( OrdKeyCount() ) }, );
   Endif

   aStruct      := ( ::cAlias )->( dbstruct() )
   if lAddColumns
      if Empty( aFldNames )
         nFields      := ( ::cAlias )->( FCount() )
         nFields      := Len( aStruct )

         for nFor := 1 to nFields
            oCol    := ::AddCol()
            oCol:cExpr := aStruct[ nFor ][ 1 ]
            oCol    := SetColFromRDD( oCol, nFor, ::cAlias, aStruct )
         next
      else
         nFields    := Len( aFldNames )
         for nFor := 1 to nFields
            oCol    := ::AddCol
            if ValType( aFldNames[ nFor ] ) == "B"
               oCol:bEditValue   := aFldNames[ nFor ]
               oCol:cHeader      := MakeColAlphabet( nFor )
            elseif ValType( aFldNames[ nFor ] ) <> "C"
               oCol:cExpr        := cValToChar( aFldNames[ nFor ] )
               oCol:bEditValue   := MakeBlock( aFldNames[ nFor ] )
               oCol:cHeader      := MakeColAlphabet( nFor )
            elseif (::cAlias)->( FieldPos( aFldNames[ nFor ] ) ) == 0
               oCol:cExpr        := aFldNames[ nFor ]
               oCol:bEditValue   := &( "{ || " + ::cAlias + "->( " + aFldNames[nFor] + " ) }" )
               oCol:cHeader      := (::cAlias)->( FieldInExpr( aFldNames[ nFor ], aStruct ) )
            else
               oCol    := SetColFromRDD( oCol, aFldNames[nFor], ::cAlias, aStruct )
               oCol:cExpr  := oCol:cHeader
            endif
         next
      endif
   endif

   if lAutoOrder

      (::cAlias)->( OrderTagInfo( aStruct, 8 ) )

      for nFor := 1 to Len( ::aCols )
         if ( n := AScan( aStruct, { |a| a[ 1 ] == Upper( ::aCols[ nFor ]:cHeader ) } ) ) > 0
            ::aCols[ nFor ]:cSortOrder    := aStruct[ n ][ 8 ]
            ::aCols[ nFor ]:cOrdBag       := ( cAlias )->( OrdBagName( ::aCols[ nFor ]:cSortOrder ) )
         endif
      next

      ::bSeek  := { |c,u| ::RddIncrSeek( c, @u ) }

   endif

   ::bLock     := { || ( ::cAlias )->( DbrLock() ) }
   ::bUnlock   := { || ( ::cAlias )->( DbrUnlock() ) }

   if ( ::cAlias )->( RddName() ) == "SQLRDD"
      ::bSeek        := nil
      ::cSortOrders  := nil
      ::cOrdBags     := nil
   endif

   if ::lCreated
      ::Adjust()
      ::Refresh()
   endif

return nil



UTILITY STATIC function TXBrowse_SetArray( aData, lAutoOrder, nColOrder, aCols, bOnSkip) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nFor, lAddCols, aWidths
   local lReset   := .F.

   if aData == nil
      return nil
   endif

   if ::lCreated
      if ::nDataType == 2
         ::aArrayData   := aData
         lReset         := .T.
      else
         ::ClearBlocks()
         if !empty( ::aCols )
            ::bBof   := ::bEof := NIL
            ::bKeyCount := ::bKeyNo := ::bBookMark := NIL
            if valtype( ::aArrayData ) == "U"
               aCols := .F.
            endif
         else
            ::aCols  := {}
         endif
         lReset   := .T.
      endif
   endif

   IIF( lAutoOrder == nil, lAutoOrder := ::lAutosort, ) ;
   IIF( lAutoOrder == nil, lAutoOrder := .F., ) ;

   ::nRowSel    := 1
   ::nArrayAt   := 1
   ::aArrayData := aData
   if ValType( bOnSkip ) == "B"
      ::bOnSkip   := bOnSkip
   endif
   ::nDataType  := 2















   IIF( ::bGoTop == nil, ::bGoTop := { || ::nArrayAt := Min( 1, Eval( ::bKeyCount ) ), Eval( ::bOnSkip, Self ) }, ) ; IIF( ::bGoBottom == nil, ::bGoBottom := { || ::nArrayAt := Eval( ::bKeyCount ), Eval( ::bOnSkip, Self ) }, ); IIF( ::bSkip == nil, ::bSkip := { | nSkip, nOld |  If( nSkip == nil, nSkip := 1, ),  nOld       := ::nArrayAt,  ::nArrayAt += nSkip,  ::nArrayAt := Min( Max( ::nArrayAt, 1 ), Eval( ::bKeyCount ) ),  Eval( ::bOnSkip, Self ),  ::nArrayAt - nOld }, ); IIF( ::bBof == nil, ::bBof := { || ::nArrayAt < 1 }, ); IIF( ::bEof == nil, ::bEof := { || ::nArrayAt > Eval( ::bKeyCount ) }, ); IIF( ::bBookMark == nil, ::bBookMark := { | n | If( n == nil, ::nArrayAt,  ( ::nArrayAt := n, Eval( ::bOnSkip, Self ), n ) ) }, ); IIF( ::bKeyNo == nil, ::bKeyNo := ::bBookMark, ); IIF( ::bKeyCount == nil, ::bKeyCount := { || Len( ::aArrayData ) }, );

   lAddCols := Empty( ::aCols )
   if ValType( aCols ) == "L"
      lAddCols       := aCols
      aCols          := nil
   endif

   if ValType( ::aArrayData ) == "H" .AND. Empty( ::aCols ) .AND. lAddCols

      WITH OBJECT ::AddCol()
         :cHeader    := "Key"
         :bEditValue := { || HGETKEYAT(aData, ::nArrayAt) }
      END

      WITH OBJECT ::AddCol()
         :cHeader    := "Value"
         :bEditValue := { || HSETVALUEAT(aData, ::nArrayAt) }
      END
      ::bSeek        := nil
      lAddCols       := .F.

   else


      if Len( aData ) > 0 .AND. ValType( aData[ 1 ] ) == "H" .AND.  ValType( ATail( aData ) ) == "H" .AND. lAddCols

         AEval( aData, { |h| HGETCASEMATCH(h, .F.) } )

         if Empty( aCols )
            for nFor := 1 to Len( aData[ 1 ] )
               WITH OBJECT ::AddCol()
                  :cHeader    := HGETKEYAT(aData[ 1 ], nFor)
                  :bEditValue := HashEditBlock( Self, :cHeader )
               END
            next
         else
            for nFor := 1 to Len( aCols )
               WITH OBJECT ::AddCol()
                  :cHeader := aCols[ nFor ]
                  :bEditValue := HashEditBlock( Self, :cHeader )
               END
            next
         endif

         lAddCols := .F.
      endif

   endif

   if lAddCols
      ::aCols := {}
      if Empty( aData )
         IIF( aCols == nil, aCols := { 1 }, ) ;
      endif
      aWidths  := ArrCalcWidths( aData, aCols )
      if Empty( aCols )
         for nFor := 1 to Len( aWidths )
            oCol                 := ::AddCol()
            oCol:nArrayCol       := nFor
            oCol:nDataLen        := aWidths[ nFor ]
         next
      else
         for nFor := 1 to Len( aCols )
            oCol               := ::AddCol()
            if ValType( aCols[ nFor ] ) == "N"
               oCol:nArrayCol     := aCols[ nFor ]
               oCol:nDataLen      := aWidths[ oCol:nArrayCol ]
            else
               oCol:nArrayCol    := 0
               oCol:cSortOrder   := 1
               if ValType( aCols[ nFor ] ) == "B"
                  oCol:bEditValue   := aCols[ nFor ]
               elseif ValType( aCols[ nFor ] ) == "C"
                  TRY
                     (0)->( &( aCols[ nFor ] ) )
                     oCol:bEditValue   := &( "{ ||" + aCols[ nFor ] + "}" )
                  CATCH
                     oCol:bEditValue   := MakeBlock( aCols[ nFor ] )
                  END
               else
                  oCol:bEditValue   := MakeBlock( aCols[ nFor ] )
               endif

            endif
         next
      endif

      AEval( ::aCols, {| oCol, i | oCol:cHeader := MakeColAlphabet( i ),  oCol:nHeadStrAlign := 2 } )
      if lAutoOrder
         if Len( ::aCols ) > 1

            IIF( nColOrder == nil, nColOrder := ::aCols[ 1 ]:nArrayCol, ) ;
            if Empty( nColOrder )
               nColOrder      := 1
            endif




            AEval( ::aCols, {|oCol| oCol:cSortOrder := oCol:nArrayCol,  If( oCol:nArrayCol == nColOrder,  (oCol:cOrder := "D", oCol:SortArrayData() ),  nil )  } )
         else
            oCol:cOrder := "D"
            oCol:cSortOrder := 1
            oCol:SortArrayData()
         endif
         ::nArrayAt  := 1
      endif
   endif

   if lAutoOrder
      ::bSeek := { | c,u | ::ArrayIncrSeek( c, @u ) }
   endif

   if lReSet .AND. ::lCreated
      ::Adjust()
      ::Refresh()
   endif

   ::lExcelCellWise  := .T.

return Self



static function HashEditBlock( oBrw, c )
return { |x| If( x == nil, oBrw:aRow[ c ], oBrw:aRow[ c ] := x ) }



static function ArrCalcWidths( aData, aCols )

   local aSizes
   local nRow, nCol, nRows, cType, n, uVal, aRow, nCols := 1

   if ! Empty( aCols )
      AEval( aCols, { |n| If( ValType( n ) == "N", nCols := Max( nCols, n ), nil ) } )
   endif

   nRows       := Len( aData )
   aSizes      := Array( nCols )

   if nRows > 0
      for nRow := 1 to nRows
         aRow  := aData[ nRow ]
         if ValType( aRow ) <> "A"
            aRow  := { aRow }
         endif
         nCols   := Len( aRow )
         if nCols > Len( aSizes )
            ASize( aSizes, nCols )
         endif
         nCols   := Min( Len( aRow ), nCols )
         for nCol := 1 to nCols
            uVal  := aRow[ nCol ]
            cType := ValType( uVal )
            if cType == "C"
               if ( n := Len( Trim( uVal ) ) ) > IfNil( aSizes[ nCol ], 0 )
                  aSizes[ nCol ] := n
               endif
            else
               if ( n := Len( cValToStr( uVal ) ) ) > IfNil( aSizes[ nCol ], 0 )
                  aSizes[ nCol ] := n
               endif

            endif
         next
      next
   endif

   for n := 1 to Len( aSizes )
      if aSizes[ n ] == nil
         aSizes[ n ] := 10
      endif
   next

return aSizes



UTILITY STATIC function TXBrowse_ArrCell( nRow, nCol, cPic, lDispZeros) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local uVal






   if nRow > 0 .AND. nRow <= Len( ::aArrayData )
      uVal  := ::aArrayData[ nRow ]
   else
      uVal  := {}
   endif

   if nCol <> nil
      if ValType( uVal ) == "A"
         if nCol > 0 .AND. nCol <= Len( uVal )
            uVal  := uVal[ nCol ]
         else
            uVal  := nil
         endif
      elseif !( nCol == 1 )
         uVal  := nil
      endif
   endif
   if PCount() > 2
      if uVal == nil
         uVal  := ""
      else
         uVal  := cValToStr( uVal, cPic,, IfNil( lDispZeros, ::lDisplayZeros ) )
      endif
   endif

return uVal



UTILITY STATIC function TXBrowse_ArrCellSet( nRow, nCol, uNewVal) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local uRow

   if nRow > 0 .AND. nRow <= Len( ::aArrayData )
      uRow  := ::aArrayData[ nRow ]
      if ValType( uRow ) == "A"
         if nCol > 0
           if nCol > Len( uRow )
              ASize( uRow, nCol )
           endif
           ::aArrayData[ nRow, nCol ] := uNewVal
         endif
      elseif nCol > 1
         ::aArrayData[ nRow ] := ASize( { uRow }, nCol )
         ::aArrayData[ nRow, nCol ] := uNewVal
      else
         ::aArrayData[ nRow ] := uNewVal
      endif
   endif

return ::ArrCell( nRow, nCol )



UTILITY STATIC function TXBrowse_SetExcelRange( oRange, lHeaders, aCols) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oHead
   local nCols, n

   ::oRs       := oRange
   ::nArrayAt  := 1
   ::nDataType := 128
   nCols       := ::oRs:Columns:Count

   if Empty( aCols )
      aCols    := {}
      for n := 1 to nCols
         AAdd( aCols, n )
      next
   endif

   IIF( lHeaders == nil, lHeaders := .F., ) ;
   if lHeaders
      oHead    := ::oRs:Rows( 1 )
      ::oRs    := ::oRs:OffSet( 1, 0 ):Resize( ::oRs:Rows:Count - 1 )
   endif

   ::bKeyCount  := { || ::oRs:Rows:Count }
   ::bGoTop     := { || ::nArrayAt := 1 }
   ::bGoBottom  := { || ::nArrayAt := ::oRs:Rows:Count }



   ::bSkip      := { |nSkip,nOld| If( nSkip == nil, nSkip := 1, nil ),  nOld := ::nArrayAt, ::nArrayAt += nSkip,  ::nArrayAt := Min( Max( 1, ::nArrayAt ), ::oRs:Rows:Count ),  ::nArrayAt - nOld }
   ::bBof       := { || ::nArrayAt < 1 }
   ::bEof       := { || ::nArrayAt > ::oRs:Rows:Count }
   ::bBookMark  := { |n| If( n == nil, ::nArrayAt, ::nArrayAt := n ) }
   ::bKeyNo     := ::bBookMark

   for n := 1 to Len( aCols )
      WITH OBJECT ::AddCol()
         if oHead == nil
            :cHeader   := Chr( aCols[ n ] + 64 )
         else
            :cHeader   := cValToChar( oHead:Cells( 1, aCols[ n ] ):Value )
         endif
         :nArrayCol    := aCols[ n ]
         :bEditValue    := ExcelColBlock( Self, aCols[ n ] )
      END
   next

return Self



static function ExcelColBlock( oBrw, nCol )


return { |x| If( x == nil, oBrw:oRs:Cells( oBrw:nArrayAt, nCol ):Value,  oBrw:oRs:Cells( oBrw:nArrayAt, nCol ):Value := x ) }



UTILITY STATIC function TXBrowse_SetAdo( oRs, lAddCols, lAutoOrder, aFldNames) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   LOCAL nFields,nFor, oCol

   if ::lCreated
      if ::nDataType == 2
         if SameAdoStruct( Self, oRs )
            return nil
         else
            ::aCols  := {}
         endif
      else
         ::ClearBlocks()
         ::aCols  := {}
      endif
   endif

   ::oRs    := oRs












   IIF( ::bGoTop == nil, ::bGoTop := {|| If( ::oRs:RecordCount() > 0, ::oRs:MoveFirst(), nil ) }, ) ; IIF( ::bGoBottom == nil, ::bGoBottom := {|| If( ::oRs:RecordCount() > 0, ::oRs:MoveLast(), nil )  }, ); IIF( ::bSkip == nil, ::bSkip := {| n | AdoSkip( ::oRs, If( n==nil, 1, n ) ) }, ); IIF( ::bBof == nil, ::bBof := {|| ::oRs:Bof }, ); IIF( ::bEof == nil, ::bEof := {|| ::oRs:Eof }, ); IIF( ::bBookMark == nil, ::bBookMark := {| n | If( n == nil, If( ::oRs:RecordCount() > 0, ::oRs:BookMark, 0 ),  If( ::oRs:RecordCount() > 0, ( ::oRs:BookMark := n ), 0 ) ) }, ); IIF( ::bKeyNo == nil, ::bKeyNo := {| n | If( n == nil,  If( ::oRs:RecordCount() > 0, ::oRs:AbsolutePosition, 0 ),  If( ::oRs:RecordCount() > 0, ( ::oRs:AbsolutePosition := n ), 0 ) ) }, ); IIF( ::bKeyCount == nil, ::bKeyCount := {|| ::oRs:RecordCount() }, );

   IIF( lAddCols == nil, lAddCols := Empty( ::aCols ) .OR. ! Empty( aFldNames ), ) ;
   IIF( lAutoOrder == nil, lAutoOrder := ::lAutoSort, ) ;

   ::nDataType       := 4

   if lAddCols
      if aFldNames == nil
         nFields := oRs:Fields:Count - 1
         for nFor := 0 to nFields
            ::SetColFromADO( nFor, lAutoOrder )
         next
      else
         nFields := Len( aFldnames )
         for nFor := 1 to nFields
            oCol  := ::SetColFromADO( aFldNames[ nFor ], lAutoOrder )
            if Empty( oCol:cHeader )
               oCol:cHeader   := "Col-" + LTrim( Str( nFor ) )
            endif
         next
      endif
   endif

   if oRs:LockType == 4
      ::bOnRowLeave  := { || ::oRs:UpdateBatch() }
   elseif oRs:LockType > 1
      ::bOnRowLeave  := { || ::oRs:Update() }
   endif

   ::bSeek  := { |c| ::AdoIncrSeek( c ) }

   if ::lCreated
      ::Adjust()
      ::Refresh()
   endif

return Self



UTILITY STATIC function TXBrowse_SetMySql( oMysql, lAddCols, lAutoOrder, aFldNames) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse
   LOCAL xField    := NIL
   LOCAL cHeader   := ""
   LOCAL cCol      := ""

   IIF( oMysql == nil, oMysql := ::oMysql, ) ;
   IIF( aFldNames == nil, aFldNames := {}, ) ;
   IIF( lAddCols == nil, lAddCols := Empty( ::aCols ) .OR. ! Empty( aFldNames ), ) ;
   IIF( lAutoOrder == nil, lAutoOrder := ::lAutoSort, ) ;

   ::oMysql            := oMysql















   IIF( ::bGoTop == nil, ::bGoTop := {|| If( ::oMysql:RecCount() > 0, ::oMysql:GoTop(), NIL ) }, ) ; IIF( ::bGoBottom == nil, ::bGoBottom := {|| If( ::oMysql:RecCount() > 0, ::oMysql:GoBottom(), nil )  }, ); IIF( ::bSkip == nil, ::bSkip := { |n,x| If( ::oMySql:RecCount() > 0, ( x := ::oMySql:RecNo(),  ::oMySql:GoTo( Max( 1,  Min( ::oMySql:RecCount(), ::oMySql:RecNo() + IfNil( n, 1 ) ) ) ),  ::oMySql:RecNo() - x ), 0 ) }, ); IIF( ::bBof == nil, ::bBof := {|| ::oMysql:Bof() }, ); IIF( ::bEof == nil, ::bEof := {|| ::oMysql:Eof() }, ); IIF( ::bBookMark == nil, ::bBookMark := {| n | If( n == nil, If( ::oMysql:RecCount() > 0, ::oMysql:RecNo(), 0 ),  If( ::oMysql:RecCount() > 0, ::oMysql:goto( n ), 0 ) ) }, ); IIF( ::bKeyNo == nil, ::bKeyNo := {| n | If( n == nil,  If( ::oMysql:RecCount() > 0, ::oMysql:RecNo(), 0 ),  If( ::oMysql:RecCount() > 0, ::oMysql:Goto( n ), 0 ) ) }, ); IIF( ::bKeyCount == nil, ::bKeyCount := {|| ::oMysql:RecCount() }, );

   ::nDataType         := 64

   IF lAddCols

      IF Len(aFldNames) == 0
         aFldNames := ::oMysql:aFieldStruct
      ENDIF

      FOR EACH xField IN aFldNames
         IF Valtype( xField ) == "A" .AND. Len(xField) == 2
            cCol    := xField[1]
            cHeader := xField[2]
         ELSEIF Valtype( xField ) == "A" .AND. Len(xField) # 2
            cCol    := xField[1]
            cHeader := xField[1]
         ELSE
            cCol    := xField
            cHeader := xField
         ENDIF

         ::SetColFromMySQL( cCol, cHeader, lAutoOrder )
      NEXT

      if __ObjHasMethod( oMySql, "WSEEKPLUS" )
         ::bSeek  := { |c| MysqlSeek( ::oMysql, c, , ::lSeekWild ) }
      endif

   ENDIF

   if ::lCreated
      ::Adjust()
      ::Refresh()
   endif

   RETURN Self



UTILITY STATIC function TXBrowse_SetDolphin( oQry, lAddCols, lAutoOrder, aFldNames, bSeptup) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse
   LOCAL xField    := NIL
   LOCAL cHeader   := ""
   LOCAL cCol      := ""
   LOCAL oCol

   IIF( oQry == nil, oQry := ::oMysql, ) ;
   IIF( aFldNames == nil, aFldNames := {}, ) ;
   IIF( lAddCols == nil, lAddCols := Empty( ::aCols ) .OR. ! Empty( aFldNames ), ) ;
   IIF( lAutoOrder == nil, lAutoOrder := ::lAutoSort, ) ;

   ::oMysql = oQry












   IIF( ::bGoTop == nil, ::bGoTop := {|| If( ::oMysql:RecCount() > 0, ::oMysql:GoTop(), NIL ) }, ) ; IIF( ::bGoBottom == nil, ::bGoBottom := {|| If( ::oMysql:RecCount() > 0, ::oMysql:GoBottom(), nil )  }, ); IIF( ::bBof == nil, ::bBof := {|| ::oMysql:Bof() }, ); IIF( ::bEof == nil, ::bEof := {|| ::oMysql:Eof() }, ); IIF( ::bBookMark == nil, ::bBookMark := {| n | If( n == nil, If( ::oMysql:RecCount() > 0, ::oMysql:RecNo(), 0 ),  If( ::oMysql:RecCount() > 0, ::oMysql:goto( n ), 0 ) ) }, ); IIF( ::bKeyNo == nil, ::bKeyNo := {| n | If( n == nil,  If( ::oMysql:RecCount() > 0, ::oMysql:RecNo(), 0 ),  If( ::oMysql:RecCount() > 0, ::oMysql:Goto( n ), 0 ) ) }, ); IIF( ::bKeyCount == nil, ::bKeyCount := {|| ::oMysql:RecCount() }, );

    IF ::oMysql:lPagination



       IIF( ::bSkip == nil, ::bSkip := {| n | If ( n <> NIL, If( n + ::oMysql:nRecNo < 1 .AND. ::oMysql:nCurrentPage > 1, ( ::oMysql:PrevPage(, .T. ), 0 ),  If( n + ::oMysql:nRecNo > ::oMysql:nRecCount .AND. ::oMysql:nCurrentPage < ::oMysql:nTotalRows, ( ::oMysql:NextPage( , .T. ), 0 ), ::oMysql:Skip( n ) ) ), ::oMysql:Skip( n ) )  }, ) ;
    ELSE
       IIF( ::bSkip == nil, ::bSkip := { | n | ::oMysql:Skip( n ) }, ) ;
    ENDIF

   ::nDataType         := 64

   IF lAddCols

      IF Len(aFldNames) == 0
         aFldNames := ::oMysql:aStructure
      ENDIF

      FOR EACH xField IN aFldNames

         if bSeptup <> NIL
            Eval( bSeptup, xField, Self )
         else
            IF Valtype( xField ) == "A" .AND. Len(xField) == 2
               cCol    := xField[1]
               cHeader := xField[2]
            ELSEIF Valtype( xField ) == "A" .AND. Len(xField) # 2
               cCol    := xField[1]
               cHeader := xField[1]
            ELSE
               cCol    := xField
               cHeader := xField
            ENDIF
            ::SetColFromMySQL( cCol, cHeader, lAutoOrder )
         endif

      NEXT

      ::bSeek  := { | c | DolphinSeek( c, ::oMysql, Self ) }

   ENDIF

   if ::lCreated
      ::Adjust()
      ::Refresh()
   endif

   RETURN Self



UTILITY STATIC function TXBrowse_ClearBlocks() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse


   ::bGoTop := ::bGoBottom := ::bSkip := ::bBof := ::bEof :=  ::bBookMark := ::bKeyNo := ::bKeyCount := nil
   ::nStretchCol     := nil
   ::nHeaderHeight   := nil
   ::nFooterHeight   := nil

return Self



UTILITY STATIC function TXBrowse_aJustify(aNew) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aJust
   local n, nCols := Len( ::aCols )
   local oCol, j

   if aNew <> nil
      for n := 1 to nCols
         oCol     := ::aCols[ n ]
         if oCol:nCreationOrder <= Len( aNew )
            j     := aNew[ oCol:nCreationOrder ]
            if Valtype( j ) == "L"
               j  := If( j, 1, 0 )
            elseif ValType( j ) == "N"
               j  := Min( 3, Max( 0, j ) )
            endif
            if ValType( j ) == "N"
               oCol:nDataStrAlign  := j
            endif
         endif
      next
   endif

   aJust    := Array( nCols )
   for n := 1 to nCols
      oCol  := ::aCols[ n ]
      j     := oCol:nDataStrAlign
      j     := If( j == 1, .T., If( j == 0, .F. , 2 ) )
      aJust[ oCol:nCreationOrder ] := j
   next

return aJust



UTILITY STATIC function TXBrowse_SetColFromADO( cnCol, lAutoOrder) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   LOCAL   nType, cType, nLen, nDec, cName
   LOCAL   oCol, oField, bExpr

   oCol             := ::AddCol()
   TRY
      oField           := ::oRs:Fields( cnCol )
   CATCH
   END

   if oField == nil

      if ValType( cnCol ) == "B"
         oCol:bEditValue   := cnCol
      else
         if ValType( cnCol ) == "C"
            if !( "U" $ Type( cnCol ) )
               oCol:bEditValue   := &( "{||" + cnCol + "}" )
            else
               bExpr             := RsExprnBlock( ::oRs, cnCol )
               if bExpr <> nil
                  oCol:bEditValue   := { || Eval( bExpr, Self ) }
                  TRY
                     Eval( oCol:bEditValue )
                  CATCH
                     oCol:bEditValue   := nil
                  END
               endif
            endif
         endif
         if Empty( oCol:bEditValue )
            oCol:bEditValue   := { || cnCol }
         endif
         oCol:cHeader   := cValToChar( cnCol )
      endif
      return oCol
   endif

   oCol:cHeader     := If( ValType( cnCol ) == "C", cnCol, oField:Name )
   nType            := oField:Type

   DO CASE
   CASE ASCAN( { 2, 3, 16, 17, 18, 19, 20, 21 }, nType ) > 0
      cType         := "N"
      nLen          := oField:Precision
      nDec         := 0
   CASE ASCAN( { 14, 131, 139 }, nType ) > 0
      cType         := "N"
      nLen          := oField:Precision
      nDec          := oField:NumericScale
   CASE ASCAN( { 4, 5, 6 }, nType ) > 0
      cType         := "N"
      nLen          := oField:Precision
      nDec          := 2

   CASE ASCAN( { 7, 133, 135 }, nType ) > 0
      cType         := "D"
   CASE nType == 11
      cType         := "L"
   CASE ASCAN( { 8,128,129,130,200,201,202,203,204,205 }, nType ) > 0
      cType         := "C"
      nLen          := oField:DefinedSize
      if nLen == 0 .OR. nLen > 100
         cType      := "M"
         nLen       := 40
      else
         nLen       := Min( 100, nLen )
      endif
   ENDCASE

   if cType == nil
      if nType == 205
         oCol:cDataTye     := "P"
      elseif nType == 136
         oCol:bEditValue   := { || ::oRs:Fields( cnCol ):Value }
         oCol:bStrData     := { || "<Child>" }
      else
         oCol:bEditValue   := { || "..." }
      endif
   else

      oCol:bEditValue   := { | x | If( x == nil, ::oRs:Fields( cnCol ):Value,  ::oRs:Fields( cnCol ):Value := x ) }
   endif

   oCol:bOnPostEdit  := { |o,x,n| If( n <> 27, o:Value := x, ) }
   oCol:cDataType    := If( cType == nil, "C", cType )
   oCol:nDataLen     := nLen
   if nDec <> nil
      oCol:nDataDec  := Min( nDec, 2 )
   endif
   if oCol:cDataType == "D"
      oCol:cEditPicture := "@D"
   endif

   if lAutoOrder
      oCol:cSortOrder   := oCol:cHeader
   endif

return oCol



static function RsExprnBlock( oRs, cStr )

   local aFldNames   := {}
   local nAt, c, cCol, bExpr, cSave

   for nAt := 0 to oRs:Fields:Count() - 1
      AAdd( aFldNames, Upper( oRs:Fields( nAt ):Name ) )
   next

   ASort( aFldNames,,,{ |x,y| Len( x ) > Len( y ) } )

   cSave := cStr
   cStr  := Upper( cStr )

   for each cCol in aFldNames

      while ( nAt := At( cCol, cStr ) ) > 0
         c := Left( LTrim( SubStr( cStr, nAt + Len( cCol ) ) ), 1 )
         if c $ ")+-*/%^" .OR. Empty( c )

            cStr  := Stuff( cStr, nAt, Len( cCol ),  " ::oRs:Fields('" + lower( cCol ) + "'):Value "  )
         else
            cStr  := Stuff( cStr, nAt, Len( cCol ), Lower( cCol ) )
         endif
      enddo

   next
   TRY
      bExpr    := &( "{ |Self| " + cStr + "}" )
   CATCH
   END

return bExpr



UTILITY STATIC function TXBrowse_SetColFromMySQL( cnCol, cHeader, lAutoOrder) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   LOCAL nType, cType, nLen, nDec, cName
   LOCAL oCol, nCol

   IF ValType( cnCol ) == "C"
      nCol               := ::oMysql:FieldPos( cnCol )
   ENDIF

   cName                 := ::oMysql:FieldName( nCol )

   IIF( nCol == nil, nCol := cnCol, ) ;
   oCol                  := ::AddCol()
   oCol:cHeader          := cHeader
   cType                 := ::oMysql:FieldType( nCol )
   nLen                  := 0
   nDec                  := 0

   DO CASE
   CASE cType       == "N"
      nLen               := ::oMysql:FieldLen( nCol )
      nDec               := ::oMysql:FieldDec( nCol )
      oCol:cEditPicture  := NumPict( nLen, nDec, .F., .F. )

   CASE cType       == "C"
      nLen               := MIN( 100, ::oMysql:FieldLen( nCol ) )

   CASE cType       == "M"
      nLen               := MIN( 100, Len(AllTrim(::oMysql:FieldGet( nCol ))) )
      nLen               := IF(nLen < 30, 30, nLen )

   CASE cType       == "D"
      oCol:nHeadStrAlign := 2
      oCol:nDataStrAlign := 0

   CASE cType       == NIL



      oCol:bEditValue    := { || "..." }

   OTHERWISE

      oCol:bEditValue    := { || "..." }

   ENDCASE

   oCol:bEditValue       := { || ::oMysql:FieldGet( nCol ) }
   oCol:cDataType        := If( cType == nil, "C", cType )
   oCol:bOnPostEdit      := { |o,x,n| If( n == 13, ::onedit( o, x, n, cType, nCol ), NIL ) }

   if lAutoOrder
      oCol:cSortOrder   := cName
   endif

   RETURN oCol



UTILITY STATIC function TXBrowse_RddIncrSeek( cExpr, uSeek) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local lFound      := .F.
   local lSoft       := .T.
   local cTemp, uOrdKeyVal, cOrdKeyType

   if ::lIncrFilter
      return ::RDDIncrFilter( cExpr, @uSeek )
   endif

   if Empty( OrdSetFocus() )
      return .F.
   endif

   uOrdKeyVal  := OrdKeyVal()
   cOrdKeyType := ValType( uOrdKeyVal )

   if cOrdKeyType == "C"
      if ::lSeekWild
         if "UPPER" $ Upper( OrdKey() )
            cExpr := Upper( cExpr )
         endif
         lFound   := OrdWildSeek( StrTran( "*" + cExpr + "*", "**", "*" ) )
      else
         lFound   := DbSeek( Upper( cExpr ) ) .OR. DbSeek( cExpr )
      endif
   else
      do case
      case cOrdKeyType == "N"
         cExpr    := Val( cExpr )
      case cOrdKeyType $ "DT"
         cExpr    := CToD( cExpr + SubStr( DToC( uOrdKeyVal ), Len( cExpr ) + 1 ) )
      case cOrdKeyType == "L"
         cExpr    := Upper( Left( cExpr, 1 ) ) == "T"
      otherwise
         lSoft    := .F.
      endcase
      DbSeek( cExpr, lSoft )
      lFound      := !Eof()
   endif

return lFound



UTILITY STATIC function TXBrowse_RddIncrFilter( cExpr, uSeek) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oBrw     := Self
   local lFound   := .F.
   local cKey
   local cFilter

   if ::bFilterExp == nil
      IIF( ::cFilterFld == nil, ::cFilterFld := OrdKey(), ) ;
      cKey  := ::cFilterFld
      if ValType( &cKey ) == "C"
         if ! "UPPER" $ Upper( cKey )
            cKey  := "UPPER( " + cKey + " )"
         endif
      else
         cKey  := "CVALTOCHAR(" + cKey + ")"
      endif
      if Empty( cExpr )
         cFilter     := "!deleted()"
      elseif ::lSeekWild

         cFilter     := 'WildMatch("*' + Upper( Trim( cExpr ) ) + '*",' + cKey + ")"



      else
         cFilter     := cKey + '="' + Upper( Trim( cExpr ) ) + '"'
      endif
   else
      cFilter        := Eval( ::bFilterExp, cExpr )
   endif

   if &cFilter
      uSeek          := ::BookMark
   endif
   if ( Empty(cFilter) ) ; dbClearFilter() ; else ; dbSetFilter( {|| &cFilter}, cFilter ) ; end
   dbGoTop()
   lFound      := ::KeyCount() > 0

return lFound



UTILITY STATIC function TXBrowse_AdoIncrSeek( uSeek) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local lFound   := .F.
   local cCol     := StrToken( ::oRs:Sort, 1 )
   local cExpr    := ""
   local cType, d, uVal, lSoft

   if ::lIncrFilter
      if ::bFilterExp == nil
         IIF( ::cFilterFld == nil, ::cFilterFld := cCol, ) ;
         cCol     := ::cFilterFld
      else
         cExpr    := Eval( ::bFilterExp, uSeek )
      endif
   endif

   if Empty( cExpr ) .AND. ! Empty( cCol ) .AND. ! ::oRs:Eof() .AND. ! ::oRs:Bof()

      IIF( lSoft == nil, lSoft := Set(9), ) ; IIF( ::lSeekWild == nil, ::lSeekWild := .F., );

      cType       := ValType( uVal := ::oRs:Fields( cCol ):Value )

      do case
      case cType == "C"

         if ::lSeekWild
            lSoft    := .F.
            cExpr    := cCol + " LIKE '*" + uSeek + "*'"
         else

            cExpr    := If( Set( 1 ), cCol + " = '" + uSeek + "'",  cCol + " LIKE '" + uSeek + "*'" )
         endif

      case cType == "N"

         cExpr    := cCol + " >= " +  LTrim( Str( Val( uSeek ) ) )

            cExpr    := "STRING( SALARY ) LIKE '*" + uSeek + "*'"

      case cType $ "DT"

         if Empty( d := CToD( uSeek ) )
            d  := CToD( uSeek + SubStr( DToC( uVal ), Len( uSeek ) + 1 ) )
         endif
         if ! Empty( d )



            cExpr    := cCol + " >= #" +  StrZero( Year( d ), 4 ) + "-" +  StrZero( Month( d ), 2 ) + "-" +  StrZero( Day( d ), 2 ) + "#"

         endif
      endcase

      if ! Empty( cExpr )
         if ::lIncrFilter
            if Empty( uSeek )
               ::oRs:Filter   := ""
               ::oRs:MoveFirst()
               lFound         := .T.
            else
               ::oRs:Filter   := cExpr
               lFound         := ( ::oRs:RecordCount > 0 )
            endif
         else
            ::oRs:Find( cExpr, 0, 1, 1 )
            if ::oRs:Eof() .AND. lSoft .AND. cType == "C"
               ::oRs:MoveFirst()
               cExpr := cCol + " > '" + uSeek + "'"
               ::oRs:Find( cExpr, 0, 1, 1 )
            endif
            if ::oRs:Eof()
               ::oRs:MoveLast()
            else
               lFound   := .T.
            endif
         endif
      endif

   endif

return lFound



static FUNCTION DolphinSeek( c, oQry, oBrw )

   LOCAL nStart
   LOCAL uData, nNum
   LOCAL cSortOrder

   STATIC aLastRec := {}

   nNum = AScan( oBrw:aCols, {| o | !Empty( o:cOrder ) } )

   if nNum < 1
      RETURN .F.
   endif

   cSortOrder = oBrw:aCols[ nNum ]:cSortOrder

   IF Len( aLastRec ) < Len( c )
      IF Len( aLastRec ) == 0
         nStart = 1
      ELSE
         nStart = oQry:RecNo()
      ENDIF
      AAdd( aLastRec, nStart )
   ELSE
      ADel( aLastRec, Len( aLastRec ) )
      ASize( aLastRec, Len( aLastRec ) - 1 )
      IF Len( aLastRec ) == 0
         nStart = 1
      ELSE
         nStart = ATail( aLastRec )
      ENDIF
   ENDIF

   oQry:Seek( c, cSortOrder, nStart, oQry:LastRec(), .T., .T. )

RETURN .T.



static function MysqlSeek( oMysql, uSeek, lSoft, lWildSeek )

   local lFound   := .F.
   local cCol     := oMysql:cSort
   local cExpr    := ""
   local cType, d, uVal

   if ! Empty( cCol ) .AND. ! oMysql:Eof() .AND. ! oMysql:Bof()

      IIF( lSoft == nil, lSoft := Set(9), ) ; IIF( lWildSeek == nil, lWildSeek := .F., );

      uVal   := oMysql:FieldGet( cCol )
      cType  := oMysql:FieldType( cCol )

      do case
      case cType == "C"

         if lWildSeek
            lSoft    := .F.
            cExpr    := cCol + " LIKE '%" + uSeek + "%'"
         else

            cExpr    := If( Set( 1 ), cCol + " = '" + uSeek + "'",  cCol + " LIKE '" + uSeek + "%'" )
         endif

      case cType == "N"

         cExpr    := cCol + " >= " +  LTrim( Str( Val( uSeek ) ) )
      case cType == "D"

         if Empty( d := CToD( uSeek ) )
            d  := CToD( uSeek + SubStr( DToC( uVal ), Len( uSeek ) + 1 ) )
         endif
         if ! Empty( d )



            cExpr    := cCol + " >= #" +  StrZero( Year( d ), 4 ) + "-" +  StrZero( Month( d ), 2 ) + "-" +  StrZero( Day( d ), 2 ) + "#"

         endif
      endcase

      if ! Empty( cExpr )
         oMysql:WSeekplus( cExpr, oMysql:cSort, oMysql:recno() )
         if oMysql:Eof() .AND. lSoft .AND. cType == "C"
            oMysql:GoTop()
            cExpr := cCol + " > '" + uSeek + "'"
            oMysql:WSeekplus( cExpr, oMysql:cSort, oMysql:recno() )
         endif
         if oMysql:Eof()
            oMysql:GoBottom()
         else
            lFound   := .T.
         endif
      endif

   endif

return lFound



UTILITY STATIC function TXBrowse_SetTree( oTree, aResource, bOnSkip) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol, aBmp := { 0, 0, 0 }
   local n, nLevels, aBlocks, bBookMark

   IIF( oTree == nil, oTree := 2, ) ;

   if ValType( oTree ) == "N"
      if ! Empty( ::aCols ) .AND. Len( ::aCols ) >= 2
         nLevels  := Min( oTree, Len( ::aCols ) )
      else
         return nil
      end

      aBlocks := Array( nLevels )
      for n := 1 to nLevels
         aBlocks[ n ] := If( ::aCols[ n ]:bStrData == nil, ::aCols[ n ]:bEditvalue, ::aCols[ n ]:bStrData )
         ::aCols[ n ]:lHide   := .T.
      next
      ::nLen      := Eval( ::bKeyCount )
      bBookMark   := ::bBookMark
      oTree       := SummaryDataAsTree( ::bSkip, { |nRow| nRow > ::nLen }, aBlocks, ::bBookMark )
      bOnSkip     := { || Eval( bBookMark, ::oTreeItem:cargo ) }
      ::nDataType := nOr( ::nDataType, 32 )
   else
      ::nDataType := 32
   endif

   IIF( bOnSkip == nil, bOnSkip := { || nil }, ) ;

   ::oTree     := oTree
   ::oTreeItem := oTree:oFirst

   ::bGoTop    := { || ::oTreeItem := ::oTree:oFirst, Eval( bOnSkip, ::oTreeITem ) }
   ::bGoBottom := { || ::oTreeItem := ::oTree:GetLast(), Eval( bOnSkip, ::oTreeITem ) }
   ::bBof      := { || .F. }
   ::bEof      := { || .F. }
   ::bKeyCount := { || ::oTree:ncount() }


   ::bKeyNo    := { |n| If( n == nil, ::oTreeItem:ItemNo() ,  ( n--, ::oTreeItem := ::oTree:oFirst:Skip( @n ), Eval( bOnSkip, ::oTreeITem ), n + 1 ) ) }

   ::bBookMark := ::bKeyNo



   ::bSkip     := { |n| If( n == nil, n := 1, ),  ::oTreeItem := ::oTreeItem:Skip( @n ),   Eval( bOnSkip, ::oTreeITem ),  n }

   if Empty( ::aCols )
      oCol  := ::AddCol()
   else
      oCol  := ::InsCol( 1 )
   endif


   oCol:bStrData     :=  oCol:bEditValue   := { |x| If( x == nil, ::oTreeItem:cPrompt, ::oTreeItem:cPrompt := x ) }
   oCol:cHeader      := "Item"
   oCol:nWidth       := 200
   oCol:bLDClickData := { || If( ::oTreeItem:oTree <> nil,( ::oTreeItem:Toggle(), ::Refresh() ),) }
   oCol:bIndent      := { || ::oTreeItem:nLevel * 20 - 20 }

   if ValType( aResource ) == "A"
      oCol:AddBitmap( aResource )
   endif
   oCol:bBmpData   := { || If( ::oTreeItem:oTree == nil, 3, If( ::oTreeItem:lOpened, 1, 2 ) ) }

   ::nFreeze         := 1

return Self



UTILITY STATIC function TXBrowse_SetoDbf( oDbf, aCols, lAutoSort, lAutoCols, aRows) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local n, oCol, oRs
   local bOnSkip


   IIF( lAutoSort == nil, lAutoSort := .F., ) ; IIF( lAutoCols == nil, lAutoCols := .F., );

   ::oDbf              := oDbf

   if ValType( aRows ) == "A" .AND. Len( aRows ) > 0

      if ValType( aRows[ 1 ] ) == "A"
         bOnSkip        := { | oBrw | oBrw:oDbf:GoTo( oBrw:aArrayData[ oBrw:nArrayAt ][ 1 ] ) }
      else
         bOnSkip        := { | oBrw | oBrw:oDbf:GoTo( oBrw:aArrayData[ oBrw:nArrayAt ] ) }
      endif
      ::SetArray( aRows, .F., 0, .F., bOnSkip )
      ::nDataType       := nOr( 16, 2 )
      lAutoSort         := .F.

   elseif __ObjHasMethod( oDbf, "SETXBROWSE" )
      oDbf:SetXBrowse( Self, aCols, lAutoSort, lAutoCols )
      aCols       := nil
      lAutoCols   := .F.
   else




      IIF( ::bGoTop == nil, ::bGoTop := {|| oDbf:GoTop() }, ) ; IIF( ::bGoBottom == nil, ::bGoBottom := {|| oDbf:GoBottom()  }, ); IIF( ::bSkip == nil, ::bSkip := {| n | oDbf:Skipper( If( n == nil, 1, n ) ) }, ); IIF( ::bBof == nil, ::bBof := {|| oDbf:Bof() }, ); IIF( ::bEof == nil, ::bEof := {|| oDbf:Eof() }, );

      if __ObjHasMethod( oDbf, "BOOKMARK" )

         IIF( ::bBookMark == nil, ::bBookMark := { |u| oDbf:BookMark( u ) }, ) ;

      else



         IIF( ::bBookMark == nil, ::bBookMark := {| n | If( n == nil, ( oDbf:RecNo() ), ( oDbf:GoTo( n ) ) ) }, ) ;

      endif


      if __ObjHasMethod( oDbf, "KEYNO" ) .AND. __ObjHasMethod( oDbf, "KEYCOUNT" ) .AND.  __ObjHasMethod( oDbf, "KEYGOTO" )


         IIF( ::bKeyNo == nil, ::bKeyNo := { |n| If( n == nil, oDbf:KeyNo(), oDbf:KeyGoTo( n ) ) }, ) ; IIF( ::bKeyCount == nil, ::bKeyCount := { || oDbf:KeyCount() }, );
      else


         IIF( ::bKeyNo == nil, ::bKeyNo := ::bBookMark, ) ; IIF( ::bKeyCount == nil, ::bKeyCount := {|| oDbf:RecCount()}, );

      endif

      ::nDataType         := 16

   endif

   if Empty( aCols ) .AND. lAutoCols
      if __ObjHasData( oDbf, "aStruct" )
         aCols := {}
         AEval( oDbf:aStruct, { |a| AAdd( aCols, a[ 1 ] ) } )


      elseif __ObjHasData( oDbf, "cAlias" ) .AND. __ObjHasData( oDbf, "nArea" ) .AND.  Select( oDbf:cAlias ) == oDbf:nArea .AND. ! Empty( oDbf:cAlias ) .AND.  ! Empty( oDbf:nArea )

         aCols := {}
         AEval( ( oDbf:nArea )->( DbStruct() ), { |a| AAdd( aCols, a[ 1 ] ) } )

      elseif __ObjHasData( oDbf, "oRs" )
         oRs   := oDbf:oRs

      elseif __ObjHasData( oDbf, "orecset" )
         oRs   := oDbf:oRecSet

      endif

      if ! Empty( oRs )
         aCols := {}
         for n := 0 to oRs:Fields:Count() - 1
            AAdd( aCols, oRs:Fields( n ):Name )
         next
      endif
   endif

   if aCols <> nil
      for n := 1 to Len( aCols )
         AddoDbfCol( Self, acols[ n ], If( __objHasData( oDbf, "aStruct" ), oDbf:aStruct, nil ) )
         if lAutoSort
            ::aCols[ n ]:cSortOrder := aCols[ n ]
         endif
      next
   endif

   if __ObjHasMethod( oDbf, "SAVE" )
      IIF( ::bOnRowLeave == nil, ::bOnRowLeave := { || ::oDbf:Save() }, ) ;
   endif
   if __ObjHasMethod( oDbf, "SEEK" )
      IIF( ::bSeek == nil, ::bSeek := { |c| ::oDbf:Seek( c, , ::lSeekWild ) }, ) ;
   endif

return Self



UTILITY STATIC function TXBrowse_GetColsData( cData, lByCreationOrder) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aValues  := {}
   local oCol

   cData          := Upper( cData )
   IIF( lByCreationOrder == nil, lByCreationOrder := !( cData == "NCREATIONORDER" ), ) ;

   if ! Empty( ::aCols ) .AND. __ObjHasData( ::aCols[ 1 ], cData )
      if lByCreationOrder
         aValues  := Array( Len( ::aCols ) )
         for each oCol in ::aCols
            aValues[ oCol:nCreationOrder ]   := OSend( oCol, cData )
         next
      else
         AEval( ::aCols, { |o| AAdd( aValues, OSend( o, cData ) ) } )
      endif
   endif

return aValues



UTILITY STATIC function TXBrowse_SetColsData( cData, aValues, lByCreationOrder) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol

   cData       := Upper( cData )
   if ! Empty( ::aCols ) .AND. __ObjHasData( ::aCols[ 1 ], cData )

      IIF( lByCreationOrder == nil, lByCreationOrder := !( cData == "NCREATIONORDER" ), ) ;

      cData       := "_" + cData

      if ValType( aValues ) == "A"
         if lByCreationOrder
            for each oCol in ::aCols
               if oCol:nCreationOrder <= Len( aValues )
                  OSend( oCol, cData, aValues[ oCol:nCreationOrder ] )
               endif
            next
         else
            AEval( ::aCols, { |o,i| OSend( o, cData, aValues[ i ] ) }, 1, Len( aValues ) )
         endif
      else
         AEval( ::aCols, { |o,i| OSend( o, cData, aValues ) } )
      endif
   endif

return aValues



UTILITY STATIC function TXBrowse_SetGroupHeader( cGrpHdr, nFrom, nUpto, oFont) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nFor

   IIF( nFrom == nil, nFrom := 1, ) ; IIF( nUpto == nil, nUpto := Len( ::aCols ), );

   for nFor := nFrom to nUpto
      ::aCols[ nFor ]:cGrpHdr       := cGrpHdr
      if oFont == nil
         ::aCols[ nFor ]:oGrpFont   := ::oFont
      else
         ::aCols[ nFor ]:oGrpFont   := oFont
      endif

      if ::lAdjusted
         ::aCols[ nFor ]:nGrpHeight   := nil
         ::aCols[ nFor ]:Adjust()
      endif

   next

   if ::lAdjusted
      ::CalcHdrHeight()
      ::Refresh()
   endif

return Self



UTILITY STATIC function TXBrowse_SetGroupTotal( aCols, cHead, nType, oFont) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol, nLastCol, n
   local cGroup

   IIF( nType == nil, nType := 1, ) ;

   if ValType( aCols ) == "C"
      cGroup      := Upper( aCols )
      for n := Len( ::aCols ) to 1 step -1
         if ! Empty( ::aCols[ n ]:cGrpHdr ) .AND. Upper( ::aCols[ n ]:cGrpHdr ) == cGroup
            nLastCol := n
            exit
         endif
      next
   elseif ValType( aCols ) == "A"
      nLastCol := 0
      for n := 1 to Len( aCols )
         oCol     := ::oCol( aCols[ n ] )
         if ValType( oCol ) == "O"
            nLastCol := Max( nLastCol, oCol:nCreationOrder )
         endif
      next
   endif
   if Empty( nLastCol )
      return nil
   endif

   oCol     := ::InsCol( nLastCol + 1 )
   WITH OBJECT oCol
      :cHeader    := cHead
      :bEditValue := { || oCol:SumOfCols( aCols, nType ) }
      if oFont == nil .AND. ! Empty( cGroup )
         oFont    := ::aCols[ nLastCol ]:oGrpFont
      endif
      if ! Empty( oFont )
         :oHeaderFont := :oDataFont := :oFooterFont := oFont
         if ! Empty( cGroup )
            :oGrpFont   := oFont
         endif
      endif
      if ! Empty( cGroup )
         :cGrpHdr    := ::aCols[ nLastCol ]:cGrpHdr
      endif
   END

return oCol



UTILITY STATIC function TXBrowse_SetBackGround( uBack, uBckMode) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse


   local oBrush

   if uBack == nil .AND. uBckMode == nil

      ::lTransparent := .F.
      ::SetColor( ::nClrText, ::nClrPane )
      if ::lCreated
         ::Refresh()
      endif
   else
      if uBack == nil
         if ::oBrush:aGrad <> nil
            uBckMode    := If( Empty( uBckMode ), 2, 1 )
         elseif Empty( ::oBrush:hBitmap ) .OR. ValType( uBckMode ) <> "N"
            uBckMode := nil
         endif
         if uBckMode <> nil .AND. ::oBrush:nResizeMode <> uBckMode
            ::lTransparent    := .T.
            ::oBrush:nResizeMode := uBckMode
            ::oBrush:oRect       := nil
            ::MakeBrush()
         endif
      else
         IIF( uBckMode == nil, uBckMode := If( Empty( ::oBrush ), 0, ::oBrush:nResizeMode ), ) ;
         SWITCH ValType( uBack )
         CASE "A"








         CASE "N"

            oBrush := TBrush():New( nil, nil, nil, nil, uBack,  FW_Decode( uBckMode, 1, "STRETCH", 2, "RESIZE", "TILED" ) )
            EXIT
         CASE "C"
            uBckMode    := FW_Decode( uBckMode, 1, "STRETCH", 2, "RESIZE", "TILED" )
            if "." $ uBack
               oBrush := TBrush():New( Upper(( uBckMode )),, uBack,,, )
            else
               oBrush := TBrush():New( Upper(( uBckMode )),,, uBack,, )
            endif
            EXIT
         CASE "O"
            oBrush   := uBack
            EXIT
         END

         if oBrush <> nil
            ::lTransparent := .T.
            ::SetBrush( oBrush )
            ::MakeBrush()
         endif
      endif
   endif

return Self



UTILITY STATIC function TXBrowse_MakeBrush() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   if ::oBrush <> NIL

   ::oBrush:Resize( Self )
   if ::lCreated
      ::Refresh()
   endif

   endif

return Self



UTILITY STATIC function TXBrowse_DataRect() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oRect    := ::GetCliRect()

   if ::lRecordSelector
      oRect:nLeft    += ( ::nRecSelWidth - 1 )
   endif
   if ::lHeader
      oRect:nTop     += ::HeaderHeight()
   endif
   if ::lFooter
      oRect:nBottom  -= ::FooterHeight()
   endif

return oRect



UTILITY STATIC function TXBrowse_cBmpAdjBrush(cFile) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   ::SetBackGround( cFile )

return cFile



UTILITY STATIC function TXBrowse_AddCol() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol

   oCol  := Eval( ::bColClass ):New( Self )

   Aadd( ::aCols, oCol )

   oCol:nCreationOrder := Len( ::aCols )

return oCol



UTILITY STATIC function TXBrowse_InsCol( nPos) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nFor

   IIF( nPos == nil, nPos := Len( ::aCols ), ) ;

   oCol  := Eval( ::bColClass ):New( Self )

   Aadd( ::aCols, nil )
   Ains( ::aCols, nPos )

   ::aCols[ nPos ] := oCol

   for nFor := nPos to Len( ::aCols )
      ::aCols[ nFor ]:nCreationOrder := nFor
   next

   ::GetDisplayCols()
   ::TControl:Refresh()

return oCol



UTILITY STATIC function TXBrowse_DelCol( nPos) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nFor

   ::aCols[ nPos ]:End()

   ADel( ::aCols, nPos )
   ASize( ::aCols, Len( ::aCols ) - 1 )


   for nFor := nPos to Len( ::aCols )
      ::aCols[ nFor ]:nCreationOrder := nFor
   next

   ::GetDisplayCols()
   ::TControl:Refresh()

return nil






UTILITY STATIC function TXBrowse_AddColumn( cHead, bData, cPic, uClrFore, uClrBack,  cAlign, nWidth, lBitmap, lEdit, bOnPostEdit,   cMsg, bWhen, bValid, cErr, lHilite, ncOrder, nAt, bBmpData, aBmp, lHide, nTot, bFooter, uCargo) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol, uTemp





   if ValType( nAt ) == "O" .AND. nAt:IsKindOf( TXBrwColumn() )
      nAt   := nAt:nCreationOrder
   endif
   if ValType( nAt ) == "N" .AND. nAt > 0 .AND. nAt <= Len( ::aCols )
      oCol  := ::InsCol( nAt )
   else
      oCol  := ::AddCol()
   endif

   oCol:cHeader      := IfNil( cHead, "" )
   oCol:cEditPicture := cPic

   if bData <> nil
      if lBitmap .AND. bBmpData == nil
         oCol:bBmpData        := bData
      else
         if ValType( bData ) == "N"
            oCol:nArrayCol    := bData
         else
            oCol:bEditValue   := bData
         endif
      endif
   endif

   if bBmpData <> nil
      oCol:bBmpData  := bBmpData
   endif

   if cAlign <> nil
      cAlign            := Upper( Left( cAlign, 1 ) )
      cAlign            := iif( cAlign == "R", 1, iif( cAlign == "C", 2, nil ) )
      if cAlign <> nil
         oCol:nHeadStrAlign := oCol:nDataStrAlign := oCol:nFootStrAlign := cAlign
      endif
   endif

   if ValType( nWidth ) == "N"
      oCol:nWidth       := nWidth
   endif

   if lEdit .OR. ValType( bOnPostEdit ) == "B" .OR. ValType( bValid ) == "B" .OR. ValType( bWhen ) == "B"
      oCol:nEditType   := 1
      oCol:bEditWhen   := bWhen
      oCol:bEditValid  := bValid
      if bOnPostEdit == nil

         oCol:bOnPostEdit  := { |o,x,n| If( n <> 27 .AND. Eval( o:oBrw:bLock ),  o:Value := x, ) }

      else
         oCol:bOnPostEdit := bOnPostEdit
      endif

   endif

   if valtype( uClrFore ) == "N"
      if valtype( uClrBack ) == "N"
         oCol:bClrStd   := {|| {uClrFore,uClrBack} }
      elseif valtype( uClrBack ) == "B"
         oCol:bClrStd   := { || {uClrFore,eval(uClrBack)} }
      else
         oCol:bClrStd   := { || { uClrFore, eval( oCol:oBrw:bClrStd )[2] } }
      endif
   elseif valtype( uClrFore ) == "B"
      if uClrBack == nil
         if valtype( uTemp := eval( uClrFore ) ) == "A" .AND. Len( uTemp ) == 2
            oCol:bClrStd   := uClrFore
         else
            oCol:bClrStd   := { || { eval(uClrFore), eval( oCol:oBrw:bClrStd )[2] } }
         endif
      elseif valtype( uClrBack ) == "N"
         oCol:bClrStd      := { || { eval(uClrFore), uClrBack } }
      elseif valtype( uClrBack ) == "B"
         oCol:bClrStd      := { || { eval(uClrFore), eval(uClrBack) } }
      endif
   endif

   if ncOrder <> nil
      oCol:cSortOrder := ncOrder
      if ::nDataType == 1 .AND. ! Empty( ::cAlias ) .AND. SELECT( ::cAlias ) > 0
         oCol:cOrdBag    := ( ::cAlias )->( OrdBagName( ncOrder ) )
      endif
   endif

   if ValType( aBmp ) == "A"
      oCol:AddBitmap( aBmp )
   endif

   oCol:lHide     := lHide

   if ValType( nTot ) == "N"
      oCol:nTotal := nTot
      oCol:lTotal  := .T.
   endif
   if ValType( bFooter ) == "B"
      oCol:bFooter := bFooter
   elseif ValType( nTot ) == "B"
      oCol:bFooter := nTot
   endif

   oCol:Cargo := uCargo

   if ::lCreated
      oCol:Adjust()
   endif

return oCol



UTILITY STATIC function TXBrowse_SwapCols( xCol1, xCol2, lRefresh) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nAt1, nAt2, nPos

   IIF( lRefresh == nil, lRefresh := .T., ) ;

   if Valtype( xCol1 ) == "O"
      nAt1 := Ascan( ::aCols, {|v| v:nCreationOrder == xCol1:nCreationOrder } )
      nAt2 := Ascan( ::aCols, {|v| v:nCreationOrder == xCol2:nCreationOrder } )
   else
      nAt1 := xCol1
      nAt2 := xCol2
   endif

   if nAt1 > 0 .AND. nAt2 > 0
      oCol := ::aCols[ nAt1 ]
      nPos := oCol:nPos
      ::aCols[ nAt1 ]:nPos := ::aCols[ nAt2 ]:nPos
      ::aCols[ nAt2 ]:nPos := nPos
      ::aCols[ nAt1 ] := ::aCols[ nAt2 ]
      ::aCols[ nAt2 ] := oCol
      if lRefresh
         ::GetDisplayCols()
         ::TControl:Refresh()
      endif
   endif

return nil



UTILITY STATIC function TXBrowse_MoveCol( xFrom, xTo, lRefresh, lUser) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nFrom, nTo, nPos, n, cPrevGrp

   IIF( lRefresh == nil, lRefresh := .T., ) ; IIF( lUser == nil, lUser := .F., );

   if Valtype( xFrom ) == "O"
      nFrom := Ascan( ::aCols, {|v| v:nCreationOrder == xFrom:nCreationOrder } )
   else
      nFrom := xFrom
   endif
   if ValType( xTo ) == "O"
      nTo   := Ascan( ::aCols, {|v| v:nCreationOrder == xTo:nCreationOrder   } )
   else
      nTo   := xTo
   endif

   if lUser .AND. ! Empty( ::nFreeze )


      if ( nFrom >  ::nFreeze .AND. nTo <= ::nFreeze ) .OR.  ( nFrom <= ::nFreeze .AND. nTo >  ::nFreeze )

         return nil
      endif
   endif


   if nFrom > 0 .AND. nTo > 0 .AND. ( ::lAllowColReGroup .OR.  ::aCols[ nFrom ]:cGrpHdr == ::aCols[ nTo ]:cGrpHdr )
      oCol := ::aCols[ nFrom ]
      if ::lAllowColReGroup
         cPrevGrp       := oCol:cGrpHdr
         oCol:cGrpHdr   := ::aCols[ nTo ]:cGrpHdr
      endif
      nPos := oCol:nPos
      ADel( ::aCols, nFrom )
      AIns( ::aCols, nTo   )
      ::aCols[ nTo ] := oCol
      ::GetDisplayCols()

      if ::bOnSwapCol <> nil
         Eval( ::bOnSwapCol, Self, nFrom, nTo )
      endif

      if oCol:cGrpHdr <> cPrevGrp
         ::CalcHdrHeight()
      endif

      if lRefresh
         ::TControl:Refresh()
      endif
   endif

return nil



UTILITY STATIC function TXBrowse_ReArrangeCols( aSeq, lRetainRest, lReNumber) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aNew     := {}
   local nCol, oCol, n


   IIF( lRetainRest == nil, lRetainRest := .T., ) ; IIF( lReNumber == nil, lReNumber := .T., );

   for n := 1 to Len( aSeq )

      nCol  := AScan( ::aCols, { |o| o == aSeq[ n ] } )
      if nCol > 0
         AAdd( aNew, ::aCols[ nCol ] )
         ADel( ::aCols, nCol )
         ASize( ::aCols, Len( ::aCols ) - 1 )
      endif
   next

   if ! Empty( ::aCols )
      if lRetainRest
         AEval( ::aCols, { |o| AAdd( aNew, o ) } )
      else
         for n := 1 to Len( ::aCols )
            ::aCols[ n ]:End()
         next
      endif
      if ! lReNumber
         for n := 1 to Len ( aNew )
            if aNew[ n ]:nCreationOrder > Len( aNew )
               lReNumber   := .F.
            endif
         next
      endif
   endif
   if lReNumber
      AEval( aNew, { |o,i| o:nCreationOrder := i } )
   endif
   ::aCols  := aNew
   if ::lCreated
      ::GetDisplayCols()
   endif

return nil



UTILITY STATIC function TXBrowse_SaveState( aAdditionalData) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aData    := { "nCreationOrders", "nRowHeight", "nWidths", "lHides", "cGrpHdrs", "cHeaders" }
   local aState   := {}

   if ValType( aAdditionalData ) == "A"
      AEval( aAdditionalData, { |c| AAdd( aData, c ) } )
   endif

   AEval( aData, { |c| AAdd( aState, { "_" + c, OSend( Self, c ) } ) } )



return "XS1:" + FW_ValToExp( aState )



UTILITY STATIC function TXBrowse_RestoreState( cState) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aState

   if ! Empty( cState )
      if Left( cState, 2 ) == "XS"
         if Left( cState, 4 ) == "XS1:"
            cState      := SubStr( cState, 5 )
            aState      := &( cState )
         elseif Left( cState, 4 ) == "XSS:"
            aState      := ARead( HexToStr(SubStr( cState, 5 )) )
         else
            return nil
         endif
         ::ReArrangeCols( aState[ 1, 2 ], .T. , .F. )
         AEval( aState, { |a| OSend( Self, a[ 1 ], a[ 2 ] ) }, 2 )
      else
         return ::OldRestoreState( cState )
      endif

      ::GetDisplayCols()
      ::Refresh()
   endif

return nil



UTILITY STATIC function TXBrowse_OldRestoreState( cState) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aCols       := {}
   local aNewOrder   := {}
   local nFor, nLen, nHeight, cCol, oCol, nOrder

   if Empty( cState )
      return nil
   endif

   nLen   := Len( ::aCols )
   nHeight := Val(StrToken( cState, 1, ";" ) )

   if Empty( ::nRowHeight )
      return nil
   endif

   for nFor := 1 to nLen
      cCol := StrToken( cState, nFor + 1, ";" )
      if Empty( cCol )
         return nil
      endif
      nOrder         := Val( StrToken( cCol, 1, ":" ) )
      if nOrder < 1 .OR. nOrder > nLen
         return nil
      endif
      aadd( aNewOrder, nOrder )
   next

   ASort( ::aCols,,, { |x,y| x:nCreationOrder < y:nCreationOrder } )

   ::nRowHeight := nHeight

   for nFor := 1 to nLen
      cCol           := StrToken( cState, nFor + 1, ";" )
      nOrder         := Val( StrToken( cCol, 1, ":" ) )

      WITH OBJECT ::aCols[ nOrder ]
         :lHide      := ( AllTrim( StrToken( cCol, 4, ":" ) ) == "H" )
         :nWidth     := Val( StrToken( cCol, 2, ":" ) )
         :cHeader    := StrToken( cCol, 3, ":" )
         :cGrpHdr    := StrToken( cCol, 5, ":" )
         if Empty( :cGrpHdr )
            :cGrpHdr := nil
         endif
      END
   next

   AEval( aNewOrder, { |n| AAdd( aCols, ::aCols[ n ] ) } )
   ::aCols        := aCols

   ::GetDisplayCols()
   ::TControl:Refresh()

return nil



UTILITY STATIC function TXBrowse_CancelEdit() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol, nFor, nlen






   if ::lEditMode
      nLen := Len( ::aCols )
      for nFor := 1 to nLen
         oCol := ::aCols[ nFor ]
         if oCol:oEditGet <> nil
            if oCol:nEditType < 6 .AND. !oCol:lAutoSave
               oCol:oEditGet:VarPut( oCol:Value )
            elseif oCol:lAutoSave
               if oCol:oEditGet:lValid() .AND. oCol:oEditGet:nLastKey <> 27
                  if oCol:oEditGet:ClassName == "TGET"
                     oCol:oEditGet:Assign()
                  elseif oCol:oEditGet:ClassName == "TTIMEPICK"
                     oCol:oEditGet:cText( oCol:oEditGet:cText )
                  endif
               else
                  oCol:oEditGet:VarPut( oCol:Value )
               endif
            endif
            oCol:oEditGet:bValid = nil
            oCol:PostEdit()
         endif
         if oCol:oEditLbx <> nil
            oCol:oEditLbx:End()
         endif
      next

      ::lEditMode := .F.
   endif

   if ::lEdited
      if ::bOnRowLeave <> nil
         Eval( ::bOnRowLeave, Self )
      endif
      ::lEdited   := .F.
   endif

return nil



UTILITY STATIC function TXBrowse_Select( nOperation) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local uBook, uCurRow, uOldRow, uTemp
   local aTemp
   local nAt, nLen
   local lRefresh

   if ! ::lMultiSelect
      return nil
   endif

   IIF( nOperation == nil, nOperation := 1, ) ;
   do case
   case nOperation ==   0
      if Len( ::aSelected ) == 1 .AND.  Eval( ::bBookMark ) == ::aSelected[ 1 ]
         lRefresh := .F.
      else
         lRefresh := .T.
      endif
      ::aSelected   := {}

      if ! Empty( ::nSaveMarq )
         ::nMarqueeStyle   := ::nSaveMarq
         ::nSaveMarq       := nil
      endif

      if lRefresh

         ::GetDC()
         ::TControl:Refresh( .T. )
         ::ReleaseDC()
      endif

   case nOperation == 1 .OR. ( Len( ::aSelected ) == 0 .AND. nOperation <> 4 )
      uBook := Eval( ::bBookMark )
      nAt   := Ascan( ::aSelected, uBook )
      if nAt == 0
         Aadd( ::aSelected, uBook )
         ::DrawLine( .T. )
      endif

   case nOperation == 2
      uBook := Eval( ::bBookMark )
      nAt   := Ascan( ::aSelected, uBook )
      if nAt > 0
         ::DrawLine( .F. )
         ::aSelected[ nAt ] := Atail( ::aSelected )
         Asize( ::aSelected, Len( ::aSelected ) - 1 )
      else
         Aadd( ::aSelected, Eval( ::bBookMark ))
         ::DrawLine( .T. )
      endif

   case nOperation == 3
      uBook   := Eval( ::bBookMark )
      uCurRow := ::KeyNo()
      Eval( ::bBookMark,  Atail( ::aSelected ) )
      uOldRow := ::KeyNo()
      if uOldRow <> uCurRow
         ::aSelected := { Atail( ::aSelected ) }
         if uCurRow > uOldRow
            CursorWait()
            while ( uTemp := Eval( ::bBookMark ) ) <> uBook .AND. ! ::Eof()
               If Ascan( ::aSelected, uTemp ) == 0
                  Aadd( ::aSelected, uTemp )
               Endif
               ::Skip( 1 )
            enddo
            CursorArrow()
         else
            CursorWait()
            while ( uTemp := Eval( ::bBookMark ) ) <> uBook .AND. ! ::Bof()
               If Ascan( ::aSelected, uTemp ) == 0
                  Aadd( ::aSelected, uTemp )
               endif
               ::Skip( -1 )
            enddo
            CursorArrow()
         endif
         Aadd( ::aSelected, uBook )
         Eval( ::bBookMark, uBook )

         ::GetDC()
         ::Paint()
         ::ReleaseDC()

      else
         Eval( ::bBookMark, uBook )
      endif

   case nOperation == 4
      uBook       := Eval( ::bBookMark )
      ::aSelected := Array( ::KeyCount() )
      nAt         := 1
      nLen        := ::nLen
      aTemp       := ::aSelected
      CursorWait()
      Eval( ::bGotop )
      while nAt <= nLen
         aTemp[ nAt++ ] := Eval( ::bBookMark )
         ::Skip( 1 )
      enddo
      Eval( ::bBookMark, uBook )
      CursorArrow()

      ::GetDC()
      ::Paint()
      ::ReleaseDC()

   case nOperation == 5
      uBook = Eval( ::bBookMark )
      nAt = Ascan( ::aSelected, uBook )
      if nAt == 1 .AND. Len( ::aSelected ) == 1
         return nil
      elseif nAt == 0
         Aadd( ::aSelected, uBook )
         ::DrawLine( .T. )
      else
         if nAt <> Len( ::aSelected )
            Asize( ::aSelected, Len( ::aSelected ) - 1 )
            ::Refresh()
         endif
      endif

   end

return nil



UTILITY STATIC function TXBrowse_Seek( cSeek) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local uBook, uSeek
   local nFor, nRows, lRet := .F.
   local lRefresh

   if ::bSeek == nil
      return lRet
   endif

   if ::lIncrFilter
      if ValType( cSeek ) == "C"
         uBook    := ::BookMark
         if Eval( ::bSeek, cSeek, @uSeek )
            lRet     := .T.
            if Empty( uSeek )
               ::Refresh( .T. )
               if ::BookMark <> uBook
                  ::Change( .T. )
               endif
            else
               ::BookMark  := uSeek
               ::Refresh()
            endif
            ::cSeek     := cSeek
            if ::oSeek <> nil
               ::oSeek:SetText( cSeek )
            endif
         else
            Eval( ::bSeek, ::cSeek )
            ::BookMark  := uBook
         endif
      endif

      return lRet

   endif

   If cSeek == nil
      if ! Empty( ::cSeek )
         ::cSeek := ""
         If ::oSeek <> nil
            ::oSeek:SetText( "" )
         Endif
      endif
      return lRet
   Endif

   uBook := ::BookMark

   if !Eval( ::bSeek, cSeek )
      ::BookMark  := uBook
      MsgBeep()
      return lRet
   endif

   lRet     := .T.
   if ::nRowSel > ::KeyNo()
      ::nRowsel := 1
   endif

   ::cSeek  := cSeek
   uSeek    := ::BookMark
   nRows    := ::nDataRows
   lRefresh := .T.

   if ::oSeek <> nil
      ::oSeek:SetText( cSeek )
   endif



   ::BookMark  := uBook
   ::Skip( 1 - ::nRowSel )

   for nFor := 1 to nRows
      if ::BookMark == uSeek
         lRefresh := .F.
         exit
      endif
      if ::Skip( 1 ) == 0
         exit
      endif
   next

   if lRefresh
      ::BookMark  := uSeek
      ::Change( .T. )
      ::TControl:Refresh( .F. )
   else
      if ! ::FullPaint
         ::BookMark  := uBook
         ::DrawLine( .F. )
      endif
      ::nRowSel   := nFor
      ::BookMark  := uSeek
      ::Change( .T. )
      if ::FullPaint
         ::TControl:Refresh( .F. )
      else
         ::DrawLine( .T. )
      endif
   endif

   if ::oVScroll <> nil
      ::VSetPos( ::KeyNo() )
   endif

return lRet



UTILITY STATIC function TXBrowse_SetColumns( nRow, nCol, nFlags) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oMenu, oCol
   local nFor, nLen

   nLen := Len( ::aCols )

   oMenu := MenuBegin( .T.,,, .F., .F. )
   oMenu:l2007    := ::l2007
      for nFor := 1 to nLen
         oCol := ::aCols[ nFor ]


         MenuAddItem( oCol:cHeader, , !oCol:lHide,  ( Len(::aDisplay) <> 1 .OR. ocol:nPos <> 1 ),  GenMenuBlock( ::aCols, nFor ) )
      next
   MenuEnd()

   oMenu:Activate( nRow, nCol, Self, ! .F., )

return nil



UTILITY STATIC function TXBrowse_GoNextCtrl( hWnd) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local aCols
   local nCol, nNextPos, n
   local lDir := .F.
   local nI
   local nOldMove

   If hWnd <> Nil
      If ::nLastKey == 9
         PostMessage(hWnd, 256, 13)
      Endif
      return nil
   Endif

   if ::nColSel == ::nLastEditCol
      ::nLastEditCol := 0

      if ::nLastKey == 40
         ::Select( 0 )
         ::GoDown()
         ::Select( 1 )
      elseif ::nLastKey == 38
         ::Select( 0 )
         ::GoUp()
         ::Select( 1 )
      else
         if ::lFastEdit

               DO CASE
               CASE ::nMoveType == 6

                  nNextPos    := 0
                  if ::nColSel < Len( ::aDisplay )
                     nNextPos := AScan( ::aDisplay, { |i| ::aCols[ i ]:lEditable }, ::nColSel + 1 )
                  endif
                  if nNextPos > 0
                     if ::IsDisplayPosVisible( nNextPos, .T. )
                        ::nColSel   := nNextPos
                        if ::FullPaint()
                           ::TControl:Refresh( .T. )
                        else
                           ::DrawLine( .T. )
                        endif
                     else
                        for n := ::nColSel + 1 to nNextPos
                           ::GoRight()
                        next
                     endif
                  elseif ::KeyNo() < ::nLen .OR. ::lAutoAppend

                     ::GoLeftMost()
                     ::Select( 0 )
                     ::GoDown()
                     ::Select( 1 )

                     if ! ::SelectedCol():lEditable
                        nNextPos := AScan( ::aDisplay, { |i| ::aCols[ i ]:lEditable  }, ::nColSel + 1 )

                        if nNextPos > ::nColSel
                           if ::IsDisplayPosVisible( nNextPos, .T. )
                              ::nColSel   := nNextPos
                              ::DrawLine( .T. )
                           else
                              for n := ::nColSel to nNextPos - 1
                                 ::GoRight()
                              next
                           endif
                        endif
                     endif
                  endif


               CASE ::nMoveType == 1
                  nNextPos    := ::nColSel + 1
                  if !::IsDisplayPosVisible( nNextPos, .T. )
                     ::GoLeftMost()
                     if ::nDataRows > ::nRowSel
                      ::GoDown()
                     endif
                  else
                     ::GoRight()
                  endif
               CASE ::nMoveType == 7
                  nNextPos    := ::SelectedCol():nCreationOrder  - 1
                  nI := nNextPos
                  if nNextPos > 0
                     while ::aCols[ nI ]:nEditType < 1
                        if ( --nI ) == 0
                           exit
                        endif
                     enddo
                  endif

                  nNextPos := ascan(::aDisplay,{|i| i = nI } )

                  if nNextPos > 0
                     if ::IsDisplayPosVisible( nNextPos, .T. )
                        ::nColSel   := nNextPos
                        if ::FullPaint()
                           ::TControl:Refresh( .T. )
                        else
                           ::DrawLine( .T. )
                        endif
                     endif
                  else
                     if nI > 0
                        for n := ::aDisplay[ ::nColSel ] - 1 to nI step -1
                           ::GoLeft()
                        next
                     else
                        ::GoRightMost()
                        nI := len( ::aCols )
                        while ::aCols[ nI ]:nEditType < 1
                           if ( --nI ) == 0
                              exit
                           endif
                        enddo

                        nNextPos := ascan( ::aDisplay, { | i | i == nI } )
                        if nNextPos > 0
                           if ::IsDisplayPosVisible( nNextPos, .T. )
                              ::nColSel   := nNextPos
                              ::DrawLine( .T. )
                           else
                              for n := ::aDisplay[ ::nColSel ] - 1 to nI step -1
                                 ::GoLeft()
                              next
                           endif
                           if ::nDataRows > 1
                              ::GoUp()
                           endif
                        endif
                      endif
                  endif

               CASE ::nMoveType == 2
                  nNextPos  := ::aDisplay[ ::nColSel ] - 1
                  if nNextPos > 0
                     ::GoLeft()
                  else
                     ::GoRightMost()
                     if ::nRowSel > 1
                      ::GoUp()
                     endif
                  endif

               CASE ::nMoveType == 4

                  if ::KeyNo() < ::nLen .OR. ::lAutoAppend
                     ::Select( 0 )
                     ::GoDown()
                     ::Select( 1 )
                  endif

               CASE ::nMoveType == 3
                  ::GoUp()
                  ::refresh()

            ENDCASE
         else
         nOldMove := ::nMoveType
         if ::nMoveType == 7 .OR. ::nMoveType == 6
            ::nMoveType := 5
         endif

         DO CASE
            CASE ::nMoveType == 1
               ::GoRight()
               ::refresh()

            CASE ::nMoveType == 2
                ::GoLeft()
                ::refresh()

            CASE ::nMoveType == 4
                ::GoDown()
                ::refresh()

            CASE ::nMoveType == 3
               ::GoUp()
               ::refresh()
            ENDCASE
            ::nMoveType := nOldMove
         endif
      endif
   endif

return nil



UTILITY STATIC function TXBrowse_SelFont() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol

   ::TControl:SelFont()
   for each oCol in ::aCols
      WITH OBJECT oCol
         :oDataFont     := ::oFont
         :oHeaderFont   := ::oFont
         :oFooterFont   := ::oFont
      END
   next

   ::Refresh()

return nil



UTILITY STATIC function TXBrowse_FontSize( nPlus) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oFont, n

   if ::lCreated .AND. ::oFont:nInpHeight < 0

      IIF( nPlus == nil, nPlus := 1, ) ;

      oFont := TFont():New( ::oFont:cFaceName, 0, ::oFont:nInpHeight - nPlus,,,,,,,,,,,,,, )

      ::SetFont( oFont )

      for n = 1 to Len( ::aCols )

         if ValType( ::aCols[ n ]:oDataFont ) == "O"
            ::aCols[ n ]:oDataFont := oFont



            ::aCols[ n ]:nWidth    := Max( Max( ::aCols[ n ]:HeaderWidth(), ::aCols[ n ]:FooterWidth() ), ::aCols[ n ]:DataWidth() ) +  6
         endif

      next

      ::Refresh()

   endif

return nil



UTILITY STATIC function TXBrowse_ClpRow( lFullRow, aCols) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local n, RetVal := ""

   IIF( lFullRow == nil, lFullRow := ( ::nMarqueeStyle >= 4 ) .OR. aCols <> nil, ) ;
   IIF( aCols == nil, aCols := ::GetVisibleCols(), ) ;

   if lFullRow
      for n := 1 to Len( aCols )
         RetVal += StrTran( StrTran( aCols[ n ]:ClpText, Chr(13)+Chr(10), " ; " ), Chr(9), " " ) + Chr( 9 )
      next
   else
      RetVal := StrTran( StrTran( ::SelectedCol():ClpText, Chr(13)+Chr(10), " ; " ), Chr(9), " " )
   endif

return RetVal



UTILITY STATIC function TXBrowse_Copy() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oClip
   local cText
   local uBm, n, aSel

   if Empty( ::aSelected )
      cText       := ::ClpRow()
   else
      aSel     := AClone( ::aSelected )
      ubm      := Eval( ::bBookMark )
      cText    := ""
      for n := 1 to Len( aSel )
         Eval( ::bBookMark, asel[ n ] )
         if n > 1
            cText    += Chr(13)+Chr(10)
         endif
         cText       += ::ClpRow()
      next
      Eval( ::bBookMark, ubm )
   endif

   oClip := TClipBoard():New( 1, ::oWnd )
   if oClip:Open()
      oClip:SetText( cText )
      oClip:Close()
   endif
   oClip:End()

return cText



UTILITY STATIC function TXBrowse_Paste( cText) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oClp, aText, nRows, nCols, n, j, uBm

   if cText == nil
      oClp := TClipBoard():New( Upper("TEXT"), ::oWnd )
      cText    := oClp:GetText()
      if ! Empty( cText )
        oClp:Clear()
      endif
      oClp:End()
   endif

   if Empty( cText )
      return nil
   endif

   if ::bPaste <> nil
      Eval( ::bPaste, Self, cText )
      return nil
   endif

   if ( Chr(13)+Chr(10) $ cText .OR. Chr(9) $ cText )
      aText    := ClipTextAsArray( cText )
      if Len( aText ) == 1 .AND. Len( aText[ 1 ] ) == 1
         ::SelectedCol():Paste( aText[ 1 ][ 1 ] )
         return nil
      endif
      if ::nDataType == 2
         If Empty( ::aArrayData )
            for n := 1 to Len( aText )
               AEval( aText[ n ], { |c,i| aText[ n, i ] := uCharToVal( c ) } )
            next
            ::aCols     := {}
            ::SetArray( aText )
            ::Refresh( .T. )
         else
            nCols    := Min( Len( aText[ 1 ] ), Len( ::aDisplay ) - ::nColSel + 1 )
            if ::nColSel == 1 .AND. ::lAutoAppend
               nRows := Len( aText )
               if ::nLen < nRows + ::nArrayAt - 1
                  ArrayResize( ::aArrayData, nRows + ::nArrayAt - 1 )
                  ::KeyCount()
               endif
            else
               nRows := Min( Len( aText ), ::nLen - ::nArrayAt + 1 )
            endif
            uBm      := ::nArrayAt
            for n := 1 to nRows
               for j := 1 to nCols
                  ::aCols[ ::aDisplay[ j + ::nColSel - 1 ] ]:Paste( aText[ n, j ] )
               next
               ::nArrayAt++
            next
            ::nArrayAt  := uBm
            ::Refresh()
         endif
      else
         uBm      := Eval( ::bBookMark )
         nCols    := Min( Len( aText[ 1 ] ), Len( ::aDisplay ) - ::nColSel + 1 )
         nRows    := Len( aText )
         n        := 1
         while n <= nRows
            for j := 1 to nCols
               ::aCols[ ::aDisplay[ j + ::nColSel - 1 ] ]:Paste( aText[ n, j ] )
            next
            if ::Skip( 1 ) < 1
               exit
            endif
            n++
         enddo
         Eval( ::bBookMark, uBm )
         if nRows == 1
            ::RefreshCurrent()
         else
            ::Refresh()
         endif
      endif
   else
      ::SelectedCol():Paste( cText )
      ::RefreshCurrent()
   endif

   ::MakeTotals()
   ::RefreshFooters()

return nil



UTILITY STATIC function TXBrowse_Eval( bBlock, bFor, bWhile, nNext, nRec, lRest) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local lFromTop    := bWhile == nil .AND. nNext == nil .AND. nRec == nil .AND. Empty( lRest )
   local nSaveSelect := nil
   local uBookMark
   local nRow        := 0


   IIF( bBlock == nil, bBlock := { || nil }, ) ; IIF( bFor == nil, bFor := { || .T. }, ); IIF( bWhile == nil, bWhile := { || .T. }, ); IIF( nRec == nil, nRec := 0, ); IIF( lRest == nil, lRest := .T., );

   if ::nDataType == 1 .AND. ! Empty( ::cAlias )
      nSaveSelect := SELECT()
      dbSelectArea( ( ::cAlias ) )
   endif

   uBookMark      := Eval( ::bBookMark )
   if lFromTop
      ::GoTop()
   endif
   if nRec > 0
      ::KeyNo( nRec )
      Eval( bBlock, Self )
   else
      while nRow++ <= ::nLen .AND. Eval( bWhile, Self )
         if Eval( bFor, Self )
            Eval( bBlock, Self )
         endif
         if ::GoDown() < 1
            exit
         endif
      enddo
   endif
   Eval( ::bBookMark, uBookMark )
   if ! Empty( nSaveSelect )
      dbSelectArea( ( nSaveSelect ) )
   endif
   ::Refresh()

return Self



UTILITY STATIC function TXBrowse_MakeTotals( aCols) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local uBm, n, nCols, oCol, nValue
   local bCond    := { |u,o| u <> nil }

   if aCols == nil
      aCols    := {}
      for each oCol in ::aCols
         WITH OBJECT oCol
            if ValType( :nTotal ) == "N" .OR. ! Empty( :nFooterType )
               AAdd( aCols, oCol )
            endif
         END
      next
   else
      if ValType( aCols ) == "O"
         aCols := { aCols }
      endif
      for n := 1 to Len( aCols )
         if Empty( aCols[ n ]:nFooterType )
            ADel( aCols, n )
            ASize( aCols, Len( aCols ) - 1 )
         endif
      next
   endif

   if ! Empty( aCols )

      for each oCol in aCols
         WITH OBJECT oCol
            IIF( :nFooterType == nil, :nFooterType := 1, ) ;
            :nTotal := :nTotalSq := 0.0
            :nCount := 0
            if :nFooterType == 2 .OR. :nFooterType == 4
               :nTotal := nil
            endif
         END
      next

      nCols    := Len( aCols )
      uBm      := ::BookMark()
      Eval( ::bGoTop )
      while .T.
         for each oCol in aCols
            WITH OBJECT oCol
               nValue   := :Value
               if Eval( IfNil( :bSumCondition, bCond ), nValue, oCol )

                  if :nFooterType == 8
                     :nCount++
                  elseif ValType( nValue ) == "N"
                     if :nFooterType == 2
                        :nTotal  := If( :nTotal == nil, nValue, Min( nValue, :nTotal ) )
                     elseif :nFooterType == 4
                        :nTotal  := If( :nTotal == nil, nvalue, Max( nValue, :nTotal ) )
                     else
                        :nTotal  += nValue
                        :nCount++
                        if lAnd( :nFooterType, 1 + 8 + 16 )
                           :nTotalSq   += ( nValue * nValue )
                        endif
                     endif
                  endif
               endif
            END
         next
      if ( ::Skip( 1 ) < 1 ); exit; end; end

      ::BookMark( uBm )

   endif

return Self



UTILITY STATIC function TXBrowse_Report( cTitle, lPreview, lModal, bSetUp, aGroupBy) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oRep, oPrn, oFont, oBold, uRet
   local aCols, nFor, oCol, uBookMark
   local oBrw := Self
   local lAddCols := .T.
   local nRows, nSel, n
   local lEof     := .F.
   local lSetUpTwice := .F.
   local nLevels

   IIF( cTitle == nil, cTitle := If( ::oWnd:ClassName == "TPANEL", ::oWnd:oWnd:cTitle, ::oWnd:cTitle ), ) ;
   IIF( lPreview == nil, lPreview := .T., ) ;
   IIF( lModal == nil, lModal := .T., ) ;

   if ::nLen < 1 .OR. Empty( ::GetVisibleCols )
      return nil
   endif




   oPrn :=  PrintBegin( nil,  .F.,  lPreview, nil,  lModal, .F. )

   if oPrn:hDC == 0
       return .F.
   endif

   if ValType( aGroupBy ) $ "ON"
      aGroupBy    := { aGroupBy }
   endif

   oFont := TFont():New( "TAHOMA", 0, - 8,,,,,,,,,,,,,, )
   oBold := TFont():New( "TAHOMA", 0, - 8,, .T.,,,,,,,,,,,, )



   oRep := RptBegin({{|| cTitle}}, {}, {}, {oFont,oBold}, {}, .F.,,,, .F.,, oPrn,,,, )

   if ::oTree <> nil
      nLevels     := ::oTree:Levels()
      oRep:Cargo  := Array( nLevels - 1 )
      ::oTree:OpenAll()

   endif

   if ! Empty( bSetUp )
      uRet := Eval( bSetUp, oRep, Self, 1 )
      if ValType( uRet ) == "L" .AND. uRet
         lAddCols := .F.
      elseif ValType( uRet ) == "N" .AND. uRet == 2
         lSetUpTwice := .T.
      endif
   endif

   if lAddCols

      aCols  := ::GetVisibleCols()

      if ValType( aGroupBy ) == "A"
         for nFor := 1 to Len( aGroupBy )
            if ValType( aGroupBy[ nFor ] ) == "N"
               aGroupBy[ nFor ] := aCols[ aGroupBy[ nFor ] ]
            endif
         next
      else
         aGroupBy := {}
      endif

      for nFor := 1 to Len( aCols )
         if AScan( aGroupBy, { |o| o:nCreationOrder == aCols[ nFor ]:nCreationOrder } ) == 0
            oCol := MakeRepCol( oRep, aCols[ nFor ] )
         endif
      next
      if ::oTree == nil
         for n := 1 to Len( aGroupBy )
            MakeRepGroup( aGroupBy[ n ] )
         next
      else
         for n := 1 to nLevels - 1
            MakeRepTreeGroup( oBrw, oRep, n )
         next
      endif
   endif

   RptEnd()

   if lSetUpTwice
      Eval( bSetUp, oRep, Self, 2 )
   endif

   uBookMark := Eval( ::bBookMark )

   if Len( ::aSelected ) > 1
       Eval( ::bBookMark, ::aSelected[ 1 ] )
       nRows        := Len( ::aSelected )
       nSel         := 1
       oRep:bSkip   := { || nSel++, Eval( oBrw:bBookMark, oBrw:aSelected[ min( nSel, nRows ) ] ) }
   else
      Eval( ::bGoTop )
      nRows           := Eval( ::bKeyCount )
      oRep:bSkip   := { |n| lEof := ( Eval( oBrw:bSkip, n ) <> n ) }

   endif
   oRep:bWhile      := { || oRep:nCounter < nRows .AND. ! lEof }
   oRep:bEnd        := ::bGoTop

   if ::oTree <> nil



      oRep:bFor      := { || If( ::oTreeItem:nLevel < nLevels,  oRep:Cargo[ ::oTreeItem:nLevel ] := ::oTreeItem:cPrompt, ),  ::oTreeItem:nLevel == nLevels }
   endif

   oRep:Activate()

   if ::oTree <> nil
      ::oTree:Collapse()
   endif

   Eval( ::bGoTop )
   Eval( ::bBookMark, UBookMark )

   ::Refresh()
   ::SetFocus()

   oFont:End() ; oFont := nil
   oBold:End() ; oBold := nil

return Self



UTILITY STATIC function TXBrowse_ToExcel( bProgress, nGroupBy, aCols) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oExcel, oBook, oSheet, oWin
   local nCol, nXCol, oCol, cType, uValue, nAt, cxlAggr
   local uBookMark, nRow
   local nDataRows
   local oClip, cText, nPasteRow, nStep, cFormat
   local aTotals  := {}, lAnyTotals := .F.
   local aWidths  := {}
   local lContinue   := .T.

   if lExcelInstl == .F.

      if lCalcInstl == .F.

         return Self
      else
         return ::ToCalc( bProgress, nGroupBy,,, aCols )
      endif
   endif

   nDataRows   := EVAL( ::bKeyCount )
   if nDataRows == 0
      return Self
   endif

   IIF( aCols == nil, aCols := ::GetVisibleCols(), ) ;

   if Empty( aCols )
      return Self
   endif

   if ( oExcel := ExcelObj() ) == nil
      lExcelInstl := .F.
      if lCalcInstl == .F.
         MsgAlert( "Excel not installed" )
         return Self
      else
         return ::ToCalc( bProgress, nGroupBy, , , aCols )
      endif
   endif
   lExcelInstl    := .T.

   if nxlLangID == nil
      SetExcelLanguage( oExcel )
   endif

   oExcel:ScreenUpdating := .F.
   oBook   := oExcel:WorkBooks:Add()
   oSheet   := oExcel:ActiveSheet

   uBookMark   := EVAL( ::bBookMark )

   nRow     := 1
   nCol     := 0
   aWidths  := Array( Len( aCols ) )

   for nXCol := 1 TO Len( aCols )
      oCol   := aCols[ nXCol ]

      nCol ++

      oSheet:Cells( nRow, nCol ):Value   := oCol:cHeader
      cType      := oCol:cDataType

      if ::nDataType <> 2
         DO CASE
         CASE Empty( cType )

         CASE cType == "N"
            cFormat     := Clp2xlNumPic( oCol:cEditPicture )
            oSheet:Columns( nCol ):NumberFormat := cFormat
            oSheet:Columns( nCol ):HorizontalAlignment := - 4152

         CASE cType == "D"
            if lxlEnglish
              if ValType( oCol:cEditPicture ) == "C" .AND. Left( oCol:cEditPicture, 1 ) <> "@"
                 oSheet:Columns( nCol ):NumberFormat := Lower( oCol:cEditPicture )
              else
                 oSheet:Columns( nCol ):NumberFormat := Lower( Set( 4 ) )
              endif
              oSheet:Columns( nCol ):HorizontalAlignment := - 4152
            endif
         CASE cType $ "LPFM"

         OTHERWISE
            if ::nDataType <> 2
               oSheet:Columns( nCol ):NumberFormat := "@"
               if ! Empty( oCol:nDataStrAlign )
                  oSheet:Columns( nCol ):HorizontalAlignment := If( oCol:nDataStrAlign == 2, -4108, -4152 )
               endif
            endif
         ENDCASE
      endif

      if cType <> nil .AND. cType $ "PFM"
         aWidths[ nCol ]                     := oCol:nWidth / 7.5
         oSheet:Columns( nCol ):ColumnWidth  := aWidths[ nCol ]
         oSheet:Rows( "2:" + LTrim(Str( ::nLen + 1 )) ):RowHeight := ::nRowHeight
         if cType == "M"
            oSheet:Columns( nCol ):WrapText  := .T.
         endif
      endif

   next

   oSheet:Range( oSheet:Cells( 1, 1 ), oSheet:Cells( 1, Len( aCols ) ) ):Select()

   oExcel:Selection:Borders(9):LineStyle := 1
   oExcel:Selection:Borders(9):Weight    := -4138

   if Empty( ::aSelected ) .OR. Len( ::aSelected ) == 1

      Eval( ::bGoTop )
      if ::oRs <> nil .AND. Len( aCols ) == ::oRs:Fields:Count()
            ::oRs:MoveFirst()
            nRow   := oSheet:Cells( 2, 1 ):CopyFromRecordSet( ::oRs )
            ::oRs:MoveFirst()
         nRow   += 2
      else

         if bProgress == nil
            if ::oWnd:oMsgBar == nil
               bProgress := { || nil }
            else
               bProgress := { | n, t | ::oWnd:SetMsg( "To Excel : " + Ltrim( Str( n ) ) + "/" + Ltrim( Str( t ) ) ) }
            endif
         endif

         nRow      := 2
         nStep     := Max( 1, Min( 100, Int( nDataRows / 100 ) ) )

         if ::lExcelCellWise
            while nRow <= ( nDataRows + 1 ) .AND. lContinue

               nCol        := 0
               for nxCol   := 1 to Len( aCols )
                  oCol     := aCols[ nXCol ]
                  nCol++
                  oCol:ToExcel( oSheet, nRow, nCol )
               next

               lContinue := ( ::Skip( 1 ) == 1 )
               nRow ++
               If ( nRow - 2 ) % nStep == 0
                  if Eval( bProgress, nRow - 2, nDataRows ) == .F.
                     Exit
                  endif
                  SysRefresh()
               endif

            enddo
         else

            nPasteRow := 2
            cText     := ""
            oClip := TClipBoard():New( 1, ::oWnd )
            if oClip:Open()

               Eval( bProgress, 0, nDataRows )

               while nRow <= ( nDataRows + 1 ) .AND. lContinue
                  if ! Empty( cText )
                     cText += Chr(13)+Chr(10)
                  endif
                  cText    += ::ClpRow( .T., aCols )

                  lContinue := ( ::Skip( 1 ) == 1 )
                  nRow ++

                  if Len( cText ) > 16000
                     oClip:SetText( cText )
                     oSheet:Cells( nPasteRow, 1 ):Select()
                     oSheet:Paste()
                     oClip:Clear()
                     cText       := ""
                     nPasteRow   := nRow
                  endif

                  If ( nRow - 2 ) % nStep == 0
                     if Eval( bProgress, nRow - 2, nDataRows ) == .F.
                        Exit
                     endif
                     SysRefresh()
                  endif

               enddo
               if ! Empty( cText )
                  oClip:SetText( cText )
                  oSheet:Cells( nPasteRow, 1 ):Select()
                  oSheet:Paste()
                  oClip:Clear()
                  cText    := ""
               endif
               oClip:Close()

               Eval( bProgress, nDataRows, nDataRows )
               SysRefresh()

            endif
            oClip:End()
         endif
      endif
   else
      ::Copy()
      oSheet:Cells( 2, 1 ):Select()
      oSheet:Paste()
      nRow := Len( ::aSelected ) + 2
   endif
   oSheet:Cells( 1, 1 ):Select()



   oSheet:Rows(    1 ):Font:Bold   := .T.
   oSheet:Rows( nRow ):Font:Bold   := .T.

   if ValType( nGroupBy ) == "N"
      for nxCol := 1 TO Len( aCols )
         if aCols[ nxCol ]:lTotal
            AAdd( aTotals, nxCol )
         endif
      next
      if ! Empty( aTotals )
         oSheet:Activate()




         oExcel:Selection:Subtotal( nGroupBy , -4157,   aTotals,  .T.,  .F.,  .T. )

      endif
   else
      nCol   := 0
      oSheet:Range( oSheet:Cells( nRow, 1 ), oSheet:Cells( nRow, Len( aCols ) ) ):Select()

      oExcel:Selection:Borders(8):LineStyle := 1
      oExcel:Selection:Borders(8):Weight    := -4138

      for nXCol := 1 TO Len ( aCols )
         oCol   := aCols[ nXCol ]
         nCol ++
         if oCol:lTotal
            if ! Empty( cxlSum )
               cxlAggr     := cxlSum
               if lxlEnglish .AND. ! Empty( oCol:nFooterType ) .AND. oCol:nFooterType > 1


                  cxlAggr  := { "SUM(", "MAX(", "MIN(", "COUNT(", "AVERAGE(", "STDEV(", "STDEVP(" }  [ AScan( { 1, 4, 2, 8, 1 + 8, 1 + 8 + 16, 1 + 8 + 16 + 32 },  oCol:nFooterType ) ]
               endif



               oSheet:Cells( nRow, nCol ):Formula := "=" + cxlAggr +  oSheet:Range( oSheet:Cells( 2, nCol ),  oSheet:Cells( nRow - 1, nCol ) ):Address( .F., .F. ) + ")"

               lAnyTotals := .T.
            endif
         endif
      next
      if lAnyTotals
        oExcel:Selection:Borders(9):LineStyle := 1
        oExcel:Selection:Borders(9):Weight    := 4
      endif
   endif

   for nCol := 1 to Len( aCols )
      if aWidths[ nCol ] == nil
         oSheet:Columns( nCol ):AutoFit()
      endif
      oSheet:Columns( nCol ):VerticalAlignment := -4108
   next

   oSheet:Cells(1,1):Select()
   oWin   := oExcel:ActiveWindow
   oWin:SplitRow := 1
   oWin:FreezePanes := .T.



   Eval( ::bBookMark, uBookMark )
   ::Refresh()
   ::SetFocus()

   oExcel:ScreenUpdating   := .T.
   oExcel:visible          := .T.
   ShowWindow( oExcel:hWnd, 3 )
   BringWindowToTop( oExcel:hWnd )

return oSheet


UTILITY STATIC function TXBrowse_ToCalc( bProgress, nGroupBy, nPasteMode, aSaveAs, aCols) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCalc, oDeskTop,oBook, oSheet, oWin, oLocal, oDispatcher
   local nCol, nXCol, oCol, cType, uValue, nAt
   local uBookMark, nRow
   local nDataRows
   local oClip, cText, nPasteRow, nStep, cFormat,cFileName,cURL,i
   local aTotals  := {}, lAnyTotals := .F. , aProp:={} , aOOFilters:={} , nPos, oCharLocale
   local lContinue := .T.

   if lCalcInstl == .F.

      if lExcelInstl == .F.

      else
         return ::ToExcel( bProgress, nGroupBy, aCols )
      endif
   endif

   IIF( nPasteMode == nil, nPasteMode := 1, ) ;
   IIF( aSaveAs == nil, aSaveAs := {}, ) ;
   nxlLangID:=0

   aOOFilters:={ {"PDF","calc_pdf_Export"},{"XLS","MS Excel 97"},{"HTML","XHTML Calc File"} }

   nDataRows   := EVAL( ::bKeyCount )
   if nDataRows == 0
     nxlLangID:=nil
     return nil
   endif

   IIF( aCols == nil, aCols := ::GetVisibleCols(), ) ;

   if Empty( aCols )
     nxlLangID:=nil
     return nil
   endif

   if ( oCalc := SunCalcObj() ) == nil
      lCalcInstl  := .F.
      if lExcelInstl == .F.
         MsgAlert( "No spreadsheet software installed" )
         return Self
      else
         return ::ToExcel( bProgress, nGroupBy, aCols )
      endif
   endif
   lCalcInstl := .T.

   lxlEnglish:=.T.

   oDesktop := oCalc:CreateInstance( "com.sun.star.frame.Desktop" )


   aProp:={}
   AAdd(aProp,GetPropertyValue(oCalc, "Hidden", .T. )  )
   oBook    := oDesktop:LoadComponentFromURL( "private:factory/scalc", "_blank", 0, aProp )
   oSheet   := oBook:GetSheets():GetByIndex( 0 )
   oDispatcher:= oCalc:CreateInstance( "com.sun.star.frame.DispatchHelper" )


   oCharLocale = oBook:GetPropertyValue("CharLocale")
   IF oCharLocale:Language == "de"
      cxlSum:="=SUMME("
   ELSEIF oCharLocale:Language == "fr"
      cxlSum:="=SOMME("
   ELSEIF oCharLocale:Language == "es"
      cxlSum:="=SUMA("
   ELSEIF oCharLocale:Language == "pt"
      cxlSum:="=SOMA("
   ELSEIF oCharLocale:Language == "it"
      cxlSum:="=SOMMA("
   ELSE
      cxlSum:="=SUM("
   ENDIF


   oBook:addActionLock()
   oBook:LockControllers()

   uBookMark   := EVAL( ::bBookMark )

   nRow   := 1
   nCol   := 0
   for nXCol := 1 TO Len( aCols )
      oCol   := aCols[ nXCol ]

      nCol ++

      oSheet:GetCellByPosition( nCol-1, nRow-1 ):SetString = oCol:cHeader
      cType      := oCol:cDataType

      DO CASE
         CASE cType == "N"

            cFormat     := If( FWNumFormat()[ 2 ], If( lxlEnglish, "#,##0", "#.##0" ), "0" )
            if oCol:cEditPicture <> nil
               if "." $ oCol:cEditPicture


                  cFormat  += If( lXlEnglish, ".", "," ) + StrTran(  StrTran( SubStr( oCol:cEditPicture,  At( ".", oCol:cEditPicture ) + 1 ), "9", "0" ), "#", "0" )
               endif
               if ( nAt := At( " ", cFormat ) ) > 0
                  cFormat  := Left( cformat, nAt ) + '"' + SubStr( cFormat, nAt + 1 ) + '"'
               endif
            endif
            oSheet:GetColumns():GetByIndex( nCol-1 ):NumberFormat:=GetNumberFormatId(oBook, cFormat, cType)
            oSheet:GetColumns():GetByIndex( nCol-1 ):HoriJustify = 3

         CASE cType == "D"
            if lxlEnglish
              if ValType( oCol:cEditPicture ) == "C" .AND. Left( oCol:cEditPicture, 1 ) <> "@"
                 oSheet:GetColumns():GetByIndex( nCol-1 ):NumberFormat:=GetNumberFormatId(oBook,  oCol:cEditPicture, oCol:cHeader, cType )
              else
                 oSheet:GetColumns():GetByIndex( nCol-1 ):NumberFormat:=GetNumberFormatId(oBook,   Set( 4 ), oCol:cHeader, cType  )
              endif
              oSheet:GetColumns():GetByIndex( nCol-1 ):HoriJustify = 3
            endif
         CASE cType == "L"

         OTHERWISE
             oSheet:GetColumns():GetByIndex( nCol-1 ):NumberFormat:= "@"
      ENDCASE

   next

   oBook:CurrentController:select( oSheet:GetCellRangeByPosition( 0, 0, Len( aCols )-1,0 ) )
   oSheet:getCellByPosition(0,0):Rows:Height=750


   aProp:={}
   AAdd(aProp,GetPropertyValue(oCalc, "OuterBorder.BottomBorder", {0,0,2,0}  )        )
   oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:SetBorderStyle", "", 0, aProp)


   aProp:={}
   AAdd(aProp,GetPropertyValue(oCalc, "Bold", .T.  )        )
   oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:Bold", "", 0, aProp)


   aProp:={}
   AAdd(aProp,GetPropertyValue(oCalc,  "FilterName", "Text" ) )
   AAdd(aProp,GetPropertyValue(oCalc, "FilterOptions", "9,,MS_1257,0,2/2/2/2/2/2/2/2/2/2/2/2/2/2/2/2"   )        )

    if Empty( ::aSelected ) .OR. Len( ::aSelected ) == 1

      Eval( ::bGoTop )

      if bProgress == nil
         if ::oWnd:oMsgBar == nil
            bProgress := { || nil }
         else
            bProgress := { | n, t | ::oWnd:SetMsg( "To Calc  : " + Ltrim( Str( n ) ) + "/" + Ltrim( Str( t ) ) ) }
         endif
      endif

      nRow      := 2
      nPasteRow := 2
      nStep     := Max( 1, Min( 100, Int( nDataRows / 100 ) ) )
      cText     := ""
      oClip := TClipBoard():New( 1, ::oWnd )
      if oClip:Open()

         Eval( bProgress, 0, nDataRows )
         while nRow <= ( nDataRows + 1 ) .AND. lContinue
            if ! Empty( cText )
               cText += Chr(13)+Chr(10)
            endif
            cText    += ::ClpRow( .T. )

            lContinue := ( ::Skip( 1 ) == 1 )
            nRow ++

            if Len( cText ) > 16000
               oClip:SetText( cText )
               oBook:CurrentController:select( oSheet:GetCellByPosition( 0,nPasteRow-1 ) )
               IF nPasteMode == 2
                  oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:Paste", "", 0, aProp)
               else
                  PasteUnformattedText(oCalc,oBook,oSheet,aCols)
               Endif
               oClip:Clear()
               cText       := ""
               nPasteRow   := nRow
            endif

            If ( nRow - 2 ) % nStep == 0
               if Eval( bProgress, nRow - 2, nDataRows ) == .F.
                  Exit
               endif
               SysRefresh()
            endif

         enddo
         if ! Empty( cText )
            oClip:SetText( cText )
            oBook:CurrentController:select( oSheet:GetCellByPosition( 0,nPasteRow-1 ) )
            IF nPasteMode == 2
               oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:Paste", "", 0, aProp)
            else
               PasteUnformattedText(oCalc,oBook,oSheet,aCols)
            Endif
            oClip:Clear()
            cText    := ""
         endif
         oClip:Close()

         Eval( bProgress, nDataRows, nDataRows )
         SysRefresh()

      endif
      oClip:End()

   else
      ::Copy()
      oBook:CurrentController:select( oSheet:GetCellByPosition( 2,1 ) )
      IF nPasteMode == 2
         oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:Paste", "", 0, aProp)
      else
         PasteUnformattedText(oCalc,oBook,oSheet,aCols)
      Endif
      nRow := Len( ::aSelected ) + 2
   ENDIF

   nCol   := 0 ; nRow:=nRow-2
   oBook:CurrentController:select( oSheet:GetCellRangeByPosition( 0, nRow, Len( aCols )-1,nRow ) )


   aProp:={}
   AAdd(aProp,GetPropertyValue(oCalc, "OuterBorder.BottomBorder", {1,1,2,1}  )        )
   oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:SetBorderStyle", "", 0, aProp)

   if ValType( nGroupBy ) == "N"
      for nxCol := 1 TO Len( aCols )
         if aCols[ nxCol ]:lTotal
            AAdd( aTotals, nxCol )
         endif
      next
      if ! Empty( aTotals )
         CalcSubTotal(oCalc,oBook,oSheet,nGroupBy,aTotals,nRow,Len(aCols)-1)
      Endif
   else


      for nXCol := 1 TO Len ( aCols )
         oCol   := aCols[ nXCol ]
         nCol ++
         if oCol:lTotal
            oBook:CurrentController:select( oSheet:GetCellByPosition( nCol-1,nRow+1 ) )
            aProp:={}

            AAdd(aProp,GetPropertyValue(oCalc, "StringName",cxlSum+ MakeColAlphabet(nCol)+"2:"+MakeColAlphabet(nCol)+LTrim(Str(nRow+1))+")"  )  )
            oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:EnterString", "", 0, aProp)
            lAnyTotals := .T.
         endif
      next
      if lAnyTotals
         oBook:CurrentController:select( oSheet:GetCellRangeByPosition( 0, nRow+1, Len( aCols )-1,nRow+1 ) )

         aProp:={}
         AAdd(aProp,GetPropertyValue(oCalc, "OuterBorder.BottomBorder", {1,1,2,1}  )        )
         oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:SetBorderStyle", "", 0, aProp)


         aProp:={}
         AAdd(aProp,GetPropertyValue(oCalc, "Bold", .T.  )        )
         oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:Bold", "", 0, aProp)
      ENDIF
   Endif

   oBook:CurrentController:select( oSheet:GetCellByPosition( 1,1 ) )

   for nCol := 1 to Len( aCols )
     oSheet:GetColumns():GetByIndex( nCol-1 ):OptimalWidth = .T.
   next

   oBook:CurrentController:select( oSheet:GetCellByPosition( 0,1 ) )
   oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:FreezePanes", "", 0, {})

   Eval( ::bBookMark, uBookMark )
   ::Refresh()
   ::SetFocus()


   oBook:UnlockControllers()
   oBook:removeActionLock()


   IF Len(aSaveAs) > 0
      FOR I:=1 TO Len(aSaveAs)
         cFormat:=Upper(aSaveAs[i][1])
         cFileName:=aSaveAs[i][2]

         IF LEFT( cFilename, 1 ) <> "/"
            cFileName:= "/" + cFileName
         ENDIF

         cURL:= StrTran( cFilename, "\", "/" )
         cURL = "file://" + cURL

         aProp:={} ; nPos:=0
         nPos:=AScan(aOOFilters,{ |x| x[1] == cFormat})
         IF nPos > 0
            AAdd(aProp,GetPropertyValue(oCalc, "FilterName", aOOFilters[nPos][2])  )
            cURL:=cURL+"."+cFormat
            oBook:StoreToURL( cURL, aProp )
         Endif

      Next
   ENDIF
   oBook:GetCurrentController():GetFrame():GetContainerWindow():SetVisible(.T.)
   oBook:CurrentController:select( oSheet:GetCellByPosition( 0,0 ) )

   nxlLangID:=nil

Return Self



UTILITY STATIC function TXBrowse_ToDbf( cFile, bProgress, aCols, lPrompt) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aStruct  := {}
   local nKeyNo   := ::KeyNo
   local nRowPos  := ::nRowSel
   local n, uVal, c, oCol, nCols
   local nSelect

   if ::nLen < 1
      return nil
   endif

   IIF( lPrompt == nil, lPrompt := .F., ) ;

   if aCols == nil
      aCols    := ::GetVisibleCols()
   else
      AEval( aCols, { |u,i| aCols[ i ] := ::oCol[ u ] } )
   endif

   ::GoTop()
   nCols       := Len( aCols )

   for each oCol in aCols
      uVal     := oCol:Value
      AAdd( aStruct, { Upper( PadR( oCol:cHeader, 10 ) ), oCol:cDataType, oCol:nDataLen, oCol:nDataDec } )
      if Empty( oCol:cHeader )
         ATail( aStruct )[ 1 ]   := "COL" + StrZero( oCol:nCreationOrder, 2 )
      endif
      if Empty( c := oCol:cDataType ) .OR. !( c $ "DLMNT" )
         ATail( aStruct )[ 2 ]   := c := If( uVal == nil, "C", ValType( uVal ) )
      endif
      if Empty( oCol:nDataLen ) .OR. c $ "DTLM"
         ATail( aStruct )[ 3 ]   := HB_DeCode( c, "C", 40, "D", 8, "T", 8, "L", 1, "N", 14, 10 )
      endif
      if c == "N"
         if oCol:nDataDec == nil
            ATail( aStruct )[ 4 ]   := 0
         endif
      else
         ATail( aStruct )[ 4 ]   := 0
      endif

   next

   if lPrompt

      XBrowse( aStruct, cFile + ":STRUCTURE",, {|oBrw|(oBrw:cEditPictures := { "@!", "!", "99","99" } )},,,!.F., .T. )
   endif

   nSelect  := Select()

   DBCREATE( cFile, aStruct )

   if bProgress == nil
      if ::oWnd:oMsgBar == nil
         bProgress := { || nil }
      else
         bProgress := { | n, t | ::oWnd:SetMsg( "To DBF : " + Ltrim( Str( n ) ) + "/" + Ltrim( Str( t ) ) ) }
      endif
   endif

   Eval( bProgress, 0, ::nLen )

   dbUseArea( .T.,, (cFile), "XBRTODBF", if(.F. .OR. .T., !.T., NIL), .F.,, )
   while .T.

      XBRTODBF->( DbAppend() )
      for n := 1 to nCols
         C     := aStruct[ n ][ 2 ]
         uVal  := aCols[ n ]:Value
         if ! Empty( uVal )
            if c == "C"
               if ValType( uVal ) <> "C"
                  uVal     := cValToChar( uVal )
               endif
            elseif ValType( uVal ) == "C"
               uVal  := uCharToVal( uVal, c )
            endif
            TRY
               XBRTODBF->( FieldPut( n, aCols[ n ]:Value ) )
            CATCH

            END
         endif
      next
      Eval( bProgress, XBRTODBF->( RecNo() ), ::nLen )

   if ::Skip( 1 ) == 0; exit; end; end
   Eval( bProgress, XBRTODBF->( LASTREC() ), XBRTODBF->( LASTREC() ) )
   XBRTODBF->( dbCloseArea() )

   ::KeyNo     := nKeyNo
   ::nRowSel   := nRowPos
   ::Refresh()

   if lPrompt .AND. MsgYesNo( "View " + cFile + "?" )
      XBrowse( cFile )
   endif

   ::SetFocus()

return nil





















static Function MakeColAlphabet( nCol )

   local cCol  := ""
   local nDigit

   while nCol > 0
      nDigit   := nCol % 26
      if nDigit == 0
         nDigit   := 26
         nCol     -= 26
      endif
      cCol     := Chr( nDigit + 64 ) + cCol
      nCol     := Int( nCol / 26 )
   enddo

return cCol



STATIC FUNCTION GetPropertyValue(oService, cName, xValue )
   LOCAL oArg
   oArg := oService:Bridge_GetStruct( "com.sun.star.beans.PropertyValue" )
   oArg:Name  := cName
   oArg:Value := xValue
RETURN oArg



STATIC Function GetNumberFormatId(oBook, cNumberFormat, cColHeader, cDataType)
  LOCAL cCharLocale,nFormatId
  cCharLocale = oBook:GetPropertyValue("CharLocale")
  IF cDataType == "D"
      cNumberFormat:=Upper(cNumberFormat)
      IF cCharLocale:Language == "es" .OR. cCharLocale:Language == "pt" .OR. cCharLocale:Language == "it"
        cNumberFormat:=StrTran(cNumberFormat,"Y","A")
      ELSEIF cCharLocale:Language == "de"
         cNumberFormat:=StrTran(cNumberFormat,"D","T")
         cNumberFormat:=StrTran(cNumberFormat,"Y","J")
      elseif cCharLocale:Language == "fr"
         cNumberFormat:=StrTran(cNumberFormat,"D","J")
         cNumberFormat:=StrTran(cNumberFormat,"Y","A")
      Endif
  Endif
  nFormatId = oBook:GetNumberFormats:QueryKey(cNumberFormat, cCharLocale, .F.)
  IF nFormatId = -1
     TRY
        nFormatId = oBook:GetNumberFormats:AddNew(cNumberFormat, cCharLocale)
     CATCH
        MsgInfo("Could not set the format "+cNumberFormat+" to column "+cColHeader)
        IF cDataType == "D"
           nFormatId:=37
        Endif
     END
  ENDIF

RETURN nFormatId



STATIC FUNCTION CalcSubTotal(oCalc,oBook,oSheet,nGroupBy,aTotals,nRow,nCol)

   LOCAL oRange, oSubTotDesc,oColumns,aArg:={},nCount

   FOR nCount:=1 TO Len(aTotals)
      oColumns := oCalc:Bridge_GetStruct( "com.sun.star.sheet.SubTotalColumn" )

      oColumns:Column  := aTotals[nCount]-1
      oColumns:Function :=2
      AAdd(aArg,oColumns)
   Next

   oRange:= oSheet:getCellRangeByPosition( 0, 0, nCol,nRow )
   oSubTotDesc:=oRange:createSubTotalDescriptor(.T.)


   oSubTotDesc:addNew(aArg, nGroupBy-1)
   oRange:applySubTotals(oSubTotDesc, .T.)
Return NIL



STATIC Function PasteUnformattedText(oCalc,oBook,oSheet,aCols)
  LOCAL oClipContType,oClipContent,oClip,cStr,i,nClipColNo
  LOCAL lFound,nRow,nCol,k,oCol

  oClip = oCalc:CreateInstance("com.sun.star.datatransfer.clipboard.SystemClipboard")
  oClipContType = oClip:Contents:getTransferDataFlavors

  lFound = .F. ;   i:= 1

  while i <= Len(oClipContType) .AND. !lFound
    if oClipContType[i]:HumanPresentableName = "OEM/ANSI Text"
      lFound = .T.
      k:=i
    else
      i:=i + 1
    endif
  Enddo

  if lFound

    nRow   = oBook:CurrentSelection:getRangeAddress():startrow
    oClipContent:=oClip:Contents:getTransferData( oClipContType[k] )

    i:=1 ;  cStr:="" ; nCol:=0

    while i <= Len(oClipContent)
       if oClipContent[i] = 0 .OR. oClipContent[i] = 13 .OR. oClipContent[i] = 10
        i=i+2 ; nRow:=nRow + 1 ; cStr:="" ;  nCol:=0
     ELSEIF oClipContent[i] = 9
        oCol:=aCols[nCol+1]

        IF oCol:cDataType == "C"
            oSheet:getCellByposition(nCol,nRow):SetString(cStr)
        ELSEIF oCol:cDataType == "N"
            oSheet:getCellByposition(nCol,nRow):SetValue(cStr)
        ELSEIF oCol:cDataType == "D"
           oSheet:getCellByposition(nCol,nRow):SetFormula(cStr)
        ELSE
           oSheet:getCellByposition(nCol,nRow):SetString(cStr)
        Endif
        nCol:=nCol+1 ; cStr:="" ; i:=i+1
      else
        cStr:=cStr + chr(oClipContent[i])
        i:=i+1
      endif
    Enddo

  endif
RETURN NIL



UTILITY STATIC function TXBrowse_CurrentRow() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oRow
   local aHeaders := {}
   local aValues  := {}
   local n

   for n := 1 to Len( ::aCols )
      AAdd( aHeaders, ::aCols[ n ]:cHeader )
      AAdd( aValues,  ::aCols[ n ]:Value   )
   next

   oRow  := TXBrRow():New( Self, Eval( ::bBookMark ), ::KeyNo(), aHeaders, aValues )

return oRow



UTILITY STATIC function TXBrowse_aCellCoor( nRow, nCol) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nTop, nLeft, nBottom, nRight
   local oCol := ::ColAtPos( nCol )

   IIF( nRow == nil, nRow := ::nRowSel, ) ; IIF( nCol == nil, nCol := ::nColSel, );

   nTop     := ( ( nRow - 1 ) * ::nRowHeight ) + ::HeaderHeight()
   nLeft    := oCol:nDisplayCol
   nBottom  := nTop + ::nRowHeight - 1
   nRight   := nLeft + oCol:nWidth - 1

return { nTop, nLeft, nBottom, nRight }



UTILITY STATIC function TXBrowse_DestroyToolTip() ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

  TWindow():DestroyToolTip()
  ::oColToolTip := nil

return nil



UTILITY STATIC function TXBrowse_NcMouseMove( nHitTestCode, nRow, nCol) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   TWindow():NcMouseMove( nHitTestCode, nRow, nCol )
   ::oColToolTip   := nil

return nil



UTILITY STATIC function TXBrowse_OnError(uParam1) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local cMsg   := __GetMessage()
   local nError := If( SubStr( cMsg, 1, 1 ) == "_", 1005, 1004 )
   local oCol, aRet
   local lByCreationOrder  := .T.
   local lAssign := .F.

   if Left( cMsg, 1 ) == "_"
      lAssign     := .T.
      nError      := 1005
      cMsg        := SubStr( cMsg, 2 )
   endif
   oCol           := ::oCol( cMsg )

   if oCol == nil

      if ! Empty( ::aCols ) .AND. Len( cMsg ) > 3 .AND. Upper( Right( cMsg, 1 ) ) == "S" .AND.  __ObjHasData( ::aCols[ 1 ], Left( cMsg, Len( cMsg ) - 1 ) )
         cMsg     := Left( cMsg, Len( cMsg ) - 1 )
         if lAssign
            ::SetColsData( cMsg, uParam1 )
            return uParam1
         else
            return ::GetColsData( cMsg )
         endif
      elseif lAssign .AND. ValType( uParam1 ) == "B"
         oCol              := ::AddCol()
         oCol:cHeader      := cMsg
         oCol:bEditValue   := uParam1
         if ::lCreated
            oCol:Adjust()
         endif
         return oCol
      endif
   else
      if lAssign
         if ValType( uParam1 ) == "B"
            oCol:bEditValue   := uParam1
            return uParam1
         else
            oCol:Value := uParam1
            return oCol:Value
         endif
      else
         return oCol
      endif
   endif

    _ClsSetError( _GenError( nError, ::ClassName(), cMsg ) )

return nil





static function treerecno( oItem )

   local nRec  := - 10000

   oItem:Skip( @nRec )

return -nRec



static function MakeRepCol( oRep, oXCol )

   local oCol, bData, cPic, nSize
   local cAlign

   if ( bData := oXCol:bEditValue ) == nil
      bData := oXCol:bStrData
   else
      cPic := oXCol:cEditPicture
   endif

   if Empty( cPic )
      nSize       := oxCol:nWidthChr
   endif

   if bData <> nil


      cAlign   := If( oXCol:nDataStrAlign  == 1, "RIGHT",  If( oXCol:nDataStrAlign  == 2, "CENTER", "LEFT" ))













      oCol := RptAddColumn( { { || oXCol:cHeader } }, nil , { bData }, nSize, { cPic } , nil, oXCol:lTotal, nil , cAlign, .F., .F., nil,  oxCol:cDataType == "M", oxcol:cDataType == "P",  nil, nil, nil, oxCol:nAlphaLevel() )

   endif

return oCol



static function MakeRepGroup( oCol )

   local bData    := { || oCol:cHeader + " " + Eval( oCol:bStrData ) }

   if ! Empty( bData )
       RptAddGroup( bData, bData, nil, { || 2 }, .F. )
   endif

return nil


static function MakeRepTreeGroup( oBrw, oRep, n )

   RptAddGroup( { || oRep:Cargo[ n ]  }, { || oRep:Cargo[ n ] }, nil, { || 2 },, .F. )

return nil



static function RepTreeFor( oBrw, oRep, nCols, nLevels )

   local nLevel   := oBrw:oTreeItem:nLevel

   nCols    := Len( oRep:aColumns )

   if nLevel < nLevels
      oRep:Cargo[ nLevel ] := oBrw:oTreeItem:cPrompt
   endif

return ( oBrw:oTreeItem:nLevel == nLevels )



static function AdoSkip(oRs,n)

   LOCAL nRec

   if oRs:RecordCount() == 0
      return 0
   endif

   nRec := oRs:AbsolutePosition
   oRs:Move( n )
   IIF( oRs:Eof, oRs:MoveLast(), If( oRs:Bof, oRs:MoveFirst(),) )

return oRs:AbsolutePosition - nRec



UTILITY STATIC function TXBrowse_ArrayIncrSeek( cSeek, nGoTo) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nAt, nBrwCol, nSortCol, nRow, uVal
   local lExact

   if ::lIncrFilter
      return ::ArrayIncrFilter( cSeek, @nGoTo )
   endif

   if ( nBrwCol := AScan( ::aCols, { |o| !Empty( o:cOrder ) } ) ) > 0
      if ! Empty( nSortCol := ::aCols[ nBrwCol ]:cSortOrder ) .AND. ValTyPe( nSortCol ) == "N"
         if ! ::aCols[ nBrwCol ]:lCaseSensitive
            cSeek    := Upper( cSeek )
         endif
         for nRow := 1 to ::nLen
            uVal  := ::ArrCell( nRow, nSortCol )
            if ValType( uVal ) $ "CDLN"
               uVal     := cValToChar( uVal )
               if ! ::aCols[ nBrwCol ]:lCaseSensitive
                  uVal  := Upper( uVal )
               endif
               if ::lSeekWild
                  if WildMatch("*" + cSeek, uVal)
                     nAt   := nRow
                  endif
               else
                  lExact := Set( 1, .F. )
                  if uVal = cSeek
                     nAt   := nRow
                  endif
                  Set( 1, lExact )
               endif
               if ! Empty( nAt )
                  ::nArrayAt  := nAt
                  return .T.
               endif
            endif
         next
      endif
   endif

return .F.



UTILITY STATIC function TXBrowse_ArrayIncrFilter( cSeek, nGoTo) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local lFound   := .F.
   local nLen, x, n, nSave, cVal, lMatch := .F.
   local oCol
   local nMatches := 0

   cSeek    := Upper( cSeek )
   if cSeek == Upper( ::cSeek )
      return .T.
   endif
   if cSeek == ""
      ::bKeyCount    := { || Len( ::aArrayData ) }
       AEval( ::aCols, { |o| If( Empty( o:cOrder ), nil, oCol := o ) } )
       oCol:cOrder := If( oCol:cOrder == "A", "D", "A" )
       ::KeyCount()
       oCol:SetOrder()
       nGoTo   := ::nArrayAt
      return .T.
   endif

   IIF( ::cFilterFld == nil, ::cFilterFld := ::SelectedCol():cHeader, ) ;
   oCol     := ::oCol( ::cFilterFld )
   nLen     := If( Len( cSeek ) >= Len( ::cSeek ), ::nLen, Len( ::aArrayData ) )
   if ::lSeekWild
      cSeek    := "*" + cSeek + "*"
   endif
   nSave       := ::nArrayAt
   cVal     := Upper( Eval( oCol:bStrData ) )
   lMatch   := If( ::lSeekWild, WildMatch( cSeek, cVal ), cVal = cSeek )
   for n := 1 to nLen
      ::nArrayAt     := n
      cVal     := Upper( Eval( oCol:bStrData ) )
      if If( ::lSeekWild, WildMatch( cSeek, cVal ), cVal = cSeek )
         nMatches++
         if n > nMatches
            x                          := ::aArrayData[ nMatches ]
            ::aArrayData[ nMatches ]   := ::aArrayData[ n ]
            ::aArrayData[ n ]          := x
            if lMatch .AND. n == nSave

               nSave    := nMatches
            endif
         endif
      endif
   next
   if nMatches > 0
      lFound         := .T.
      ::nArrayAt     := If( lMatch, nSave, 1 )
      ::bKeyCount    := { || nMatches }
      if nLen > ::nLen
         oCol        := nil
         AEval( ::aCols, { |o| If( Empty( o:cOrder ), nil, oCol := o ) } )
         oCol:cOrder := If( oCol:cOrder == "A", "D", "A" )
         ::KeyCount()
         oCol:SetOrder()
      endif
      if lMatch
         nGoTo       := ::nArrayAt
      endif
   else
      ::nArrayAt  := nSave
   endif

return lFound













































static function GenMenuBlock( aCols, nFor )

   local oCol := aCols[ nFor ]

return {|| iif( oCol:lHide, oCol:Show(), oCol:Hide() ) }



static function SetColFromRDD( oCol, nFld, cAlias, aFldInfo )

   local cName
   local uVal, nLen, nDec, nSelect  := SELECT( cAlias )

   if valtype( nFld ) == "C"
      nFld  := (cAlias)->(FieldPos(cName := nFld))

   endif

   aFldInfo          := aFldInfo[ nFld ]

   oCol:cHeader      := If( cName == nil, aFldInfo[ 1 ], cName )
   if ( cName == nil )
      cName          := aFldInfo[ 1 ]
   endif



   oCol:bEditValue   := { |x| If( x == nil, ( oCol:oBrw:cAlias )->( FieldGet( nFld ) ),  ( oCol:oBrw:cAlias )->( FieldPut( nFld, x ) ) ) }

   uVal              := ( oCol:oBrw:cAlias )->( FieldGet( nFld ) )
   oCol:nDataLen              := aFldInfo[ 3 ]
   oCol:nDataDec              := aFldInfo[ 4 ]

   if Len( aFldInfo[ 2 ] ) == 1

      oCol:cDataType      := aFldInfo[ 2 ]

      if oCol:cDataType == "I"
         oCol:cDataType := "N"
         if aFldInfo[ 3 ] == 2
            oCol:nDataLen        := 6
         else
            oCol:nDataLen        := 13
         endif
         oCol:nDataDec           := 0
      elseif oCol:cDataType == "Y"
         oCol:cDataType := "N"
         oCol:nDataLen           := 15
         oCol:nDataDec           := 2
      elseif oCol:cDataType == "@"
         oCol:nDataLen           := 20

         oCol:cDataType := "T"






      elseif oCol:cDataType == "U"
         oCol:cDataType := "C"
      endif
   else

      oCol:cDataType    := ValType( uVal )
      do case
         case oCol:cDataType == "N"
            do case
               case "DOUBLE" $ aFldInfo[ 2 ] .OR. "MONEY" $ aFldInfo[ 2 ]
                  oCol:nDataLen           := 15
                  oCol:nDataDec           := 2
               case AScan( { "AUTOINC", "ROWVERSION" }, aFldInfo[ 2 ] ) > 0
                  oCol:nDataLen           := 15
                  oCol:nDataDec           := 0
               otherwise
                  oCol:nDataLen           := 15
                  oCol:nDataDec           := 0
            endcase

         case oCol:cDataType == "D"
            if "TIME" $ aFldInfo[ 2 ]
               oCol:cDataType    := "T"
               oCol:cEditPicture := "@T"
            endif

         case oCol:cDataType $ "CM"
            if aFldInfo[ 2 ] = "IMAGE"
               oCol:cDataType    := "P"
            elseif aFldInfo[ 2 ] = "RAW"
               oCol:bStrData     := { || "<Binary>" }
            endif
         otherwise

      endcase
   endif


   if !( oCol:cDataType $ "CDLMNPT" )
      oCol:cDataType := ValType( uVal )
   endif



   do case
   case oCol:cDataType == "N"
      oCol:cEditPicture   := NumPict( oCol:nDataLen, oCol:nDataDec, .T. )
   case oCol:cDataType  == "D"
      oCol:cEditPicture   := "@D"

   endcase

   if oCol:oBrw:lOemAnsi .AND. oCol:cDataType $ "CM"

      oCol:bEditValue := { |x| If( x == nil, OemToAnsi( (oCol:oBrw:cAlias)->( FieldGet(nFld) ) ),  ( (oCol:oBrw:cAlias)->( FieldPut( nFld, AnsiToOem( x ) ), x ) ) ) }
   endif


   oCol:bOnPostEdit  := { |o,x,n| If( n <> 27 .AND. Eval( o:oBrw:bLock ),  o:Value := x, ) }


return oCol


static function AddOdbfCol( oBrw, cCol, aStruct )

   local oCol := oBrw:AddCol()
   local n

   oCol:cHeader         := cCol
   oCol:bEditValue      := { |x| If( x <> nil, oSend( oBrw:oDbf, "_" + cCol, x ), ), OSend( oBrw:oDbf, cCol ) }
   oCol:bOnPostEdit     := { |o,x,n| If( n <> 27, o:Value := x, ) }

   if aStruct <> nil
      if ( n := AScan( aStruct, { |a| Upper( Trim( a[ 1 ] ) ) == Upper( Trim( cCol ) ) } ) ) > 0
         oCol:cDataType    := aStruct[ n ][ 2 ]
         oCol:nDataLen     := aStruct[ n ][ 3 ]
         oCol:nDataDec     := aStruct[ n ][ 4 ]
      endif
   endif

return oCol












static function SetExcelLanguage( oExcel )

   local aEng     := { 1033, 2057, 10249, 4105, 9225, 14345, 6153, 8201, 5129, 13321, 7177, 11273, 12297 }

   local aSpanish := {3082,1034,11274,16394,13322,9226,5130,7178,12298,17418,4106,18442, 58378,2058,19466,6154,15370,10250,20490,21514,14346,8202}
   local aGerman  := {1031,3079,5127,4103,2055}
   local aFrench  := {1036,2060,11276,3084,9228,12300,15372,5132,13324,6156,14348,58380,8204,10252,4108,7180}

   if nxlLangID == nil
      if ( oExcel := ExcelObj() ) == nil
         nxlLangID := 0
         return nil
      endif

      nxlLangID := oExcel:LanguageSettings:LanguageID( 2 )
      do case
         case AScan( aEng, nxlLangID ) > 0
            cxlTrue     := "TRUE"
            cxlFalse    := "FALSE"
            cxlSum      := "SUBTOTAL(9,"
            lxlEnglish  := .T.

         case AScan( aSpanish, nxlLangID ) > 0
            cxlTrue     := "VERDADERO"
            cxlFalse    := "FALSO"
            cxlSum      := "SUBTOTALES(9;"

         case nxlLangID == 1040 .OR. nxlLangID == 2064
            cxlTrue     := "VERO"
            cxlFalse    := "FALSO"
            cxlSum      := "SOMMA("

         case AScan( aGerman, nxlLangID ) > 0
            cxlTrue     := "WAHR"
            cxlFalse    := "FALSCH"
            cxlSum      := "SUMME("

         case AScan( aFrench, nxlLangID ) > 0
            cxlTrue     := "VRAI"
            cxlFalse    := "FAUX"
            cxlSum      := "SOMME("

         case nxlLangID == 2070 .OR. nxlLangID == 1046
            cxlTrue     := "VERDADEIRO"
            cxlFalse    := "FALSO"
            cxlSum      := "SOMA("
         otherwise
            cxlTrue     := "=(1=1)"
            cxlFalse    := "=(1=0)"
      endcase
   endif

return nil



_HB_CLASS TXBrwColumn ; UTILITY FUNCTION TXBrwColumn(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TXBrwColumn" , { HBObject():Classh } ) ) ;














   _HB_MEMBER { oBrw, oDataFont, oHeaderFont, oDataFontBold, oGrpFont, oFooterFont, oDragWnd, oBtnList, oBtnElip, oEditGet, oEditLbx, oEditFont, bPopUp, oBrush} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBrw" , "oDataFont" , "oHeaderFont" , "oDataFontBold" , "oGrpFont" , "oFooterFont" , "oDragWnd" , "oBtnList" , "oBtnElip" , "oEditGet" , "oEditLbx" , "oEditFont" , "bPopUp" , "oBrush" }, .F., .F. ), )

   _HB_MEMBER { aBitmaps} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aBitmaps" }, .F., .F. ), )






   _HB_MEMBER { aEditListTxt, aEditListBound} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aEditListTxt" , "aEditListBound" }, .F., .F. ), )






   _HB_MEMBER { bStrData, bBmpData,  bIndent, bStrImage} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bStrData" , "bBmpData" , "bIndent" , "bStrImage" }, .F., .F. ), )







   _HB_MEMBER { bEditValue, bEditValid, bEditWhen, bGetChange, bOnChange, bEditBlock} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bEditValue" , "bEditValid" , "bEditWhen" , "bGetChange" , "bOnChange" , "bEditBlock" }, .F., .F. ), )

   _HB_MEMBER { bOnPostEdit} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPostEdit" }, .F., .F. ), )

    _HB_MEMBER { bOnPreEdit} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreEdit" }, .F., .F. ), )






   _HB_MEMBER { bLClickHeader, bRClickHeader, bLClickFooter, bRClickFooter, bLDClickData, bRClickData} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bLClickHeader" , "bRClickHeader" , "bLClickFooter" , "bRClickFooter" , "bLDClickData" , "bRClickData" }, .F., .F. ), )







   _HB_MEMBER { bClrHeader, bClrFooter, bClrGrad,  bClrStd, bClrSel, bClrSelFocus, bClrEdit} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bClrHeader" , "bClrFooter" , "bClrGrad" , "bClrStd" , "bClrSel" , "bClrSelFocus" , "bClrEdit" }, .F., .F. ), )

   _HB_MEMBER { bPaintText} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bPaintText" }, .F., .F. ), )

   _HB_MEMBER { bToolTip} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bToolTip" }, .F., .F. ), )












   _HB_MEMBER { cHeader, cExpr, cGrpHdr, cFooter, cEditPicture, cOrder, cSortOrder, cOrdBag,  cDataType,  cEditKeys,  bFooter,    cToolTip} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cHeader" , "cExpr" , "cGrpHdr" , "cFooter" , "cEditPicture" , "cOrder" , "cSortOrder" , "cOrdBag" , "cDataType" , "cEditKeys" , "bFooter" , "cToolTip" }, .F., .F. ), )






   _HB_MEMBER { nWidth, nDisplayCol, nCreationOrder, nResizeCol, nPos, nTotal} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nWidth" , "nDisplayCol" , "nCreationOrder" , "nResizeCol" , "nPos" , "nTotal" }, .F., .F. ), )

   _HB_MEMBER { nDataHeight} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .T., 32, 0 ), { "nDataHeight" }, .F., .F. ), )
   _HB_MEMBER { aRows} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .T., 32, 0 ), { "aRows" }, .F., .F. ), )

   _HB_MEMBER { nCount} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nCount" }, .F., .F. ), )
   _HB_MEMBER { nTotalSq} ; IIF( !.F., s_oClass:AddMultiData(, 0.0, nScope + IIF( .F., 32, 0 ), { "nTotalSq" }, .F., .F. ), )
   _HB_MEMBER { bSumCondition} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bSumCondition" }, .F., .F. ), )


   _HB_MEMBER { nGrpHeight} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nGrpHeight" }, .F., .F. ), )



   _HB_MEMBER { nDataLen, nDataDec, nDataLines} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDataLen" , "nDataDec" , "nDataLines" }, .F., .F. ), )



   _HB_MEMBER { nDataStrAlign, nHeadStrAlign, nFootStrAlign} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDataStrAlign" , "nHeadStrAlign" , "nFootStrAlign" }, .F., .F. ), )



   _HB_MEMBER { nDataBmpAlign, nHeadBmpAlign, nFootBmpAlign} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDataBmpAlign" , "nHeadBmpAlign" , "nFootBmpAlign" }, .F., .F. ), )

   _HB_MEMBER {AS NUMERIC nBtnBmp} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 0, nScope + IIF( .F., 32, 0 ), { "nBtnBmp" }, .F., .F. ), )



   _HB_MEMBER { nDataStyle, nHeadStyle, nFootStyle} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDataStyle" , "nHeadStyle" , "nFootStyle" }, .F., .F. ), )

   _HB_MEMBER {AS NUMERIC nArrayCol} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 0, nScope + IIF( .F., 32, 0 ), { "nArrayCol" }, .F., .F. ), )

   _HB_MEMBER { nHeadBmpNo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nHeadBmpNo" }, .F., .F. ), )



   _HB_MEMBER {AS NUMERIC nGrpBmpNo,  nFootBmpNo} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nGrpBmpNo" , "nFootBmpNo" }, .F., .F. ), )

   _HB_MEMBER {AS NUMERIC nAlphaLevelHeader} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 255, nScope + IIF( .F., 32, 0 ), { "nAlphaLevelHeader" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nAlphaLevelFooter} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 255, nScope + IIF( .F., 32, 0 ), { "nAlphaLevelFooter" }, .F., .F. ), )



   _HB_MEMBER {AS NUMERIC hEditType} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, 4 + IIF( .F., 32, 0 ), { "hEditType" }, .F., .F. ), )









   _HB_MEMBER {AS LOGICAL lAllowSizing, lEditBorder, lHide, lOnPostEdit, lBmpStretch} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL",, nScope + IIF( .F., 32, 0 ), { "lAllowSizing" , "lEditBorder" , "lHide" , "lOnPostEdit" , "lBmpStretch" }, .F., .F. ), )

   _HB_MEMBER {AS LOGICAL lCaseSensitive} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lCaseSensitive" }, .F., .F. ), )
   _HB_MEMBER { lBmpTransparent} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lBmpTransparent" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lBtnTransparent} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lBtnTransparent" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lAutoSave} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lAutoSave" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lColTransparent} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lColTransparent" }, .F., .F. ), )
   _HB_MEMBER { lDisplayZeros} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lDisplayZeros" }, .F., .F. ), )


   _HB_MEMBER {AS LOGICAL lProgBar} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lProgBar" }, .F., .F. ), )
   _HB_MEMBER { bClrProg} ; IIF( !.F., s_oClass:AddMultiData(, { || { ( 200 + ( 200 * 256 ) + ( 255 * 65536 ) ), 65535 } }, nScope + IIF( .F., 32, 0 ), { "bClrProg" }, .F., .F. ), )
   _HB_MEMBER { nProgTot} ; IIF( !.F., s_oClass:AddMultiData(, 1, nScope + IIF( .F., 32, 0 ), { "nProgTot" }, .F., .F. ), )

   _HB_MEMBER {AS LOGICAL lTotal} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lTotal" }, .F., .F. ), )
   _HB_MEMBER { hFooterType} ; IIF( !.F., s_oClass:AddMultiData(,, 4 + IIF( .F., 32, 0 ), { "hFooterType" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL hChecked} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "hChecked" }, .F., .F. ), )

   _HB_MEMBER { Cargo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "Cargo" }, .F., .F. ), )

   _HB_MEMBER { lMergeVert} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lMergeVert" }, .F., .F. ), )
   _HB_MEMBER { aMerge} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aMerge" }, .F., .F. ), )

   _HB_MEMBER { nHeaderType} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nHeaderType" }, .F., .F. ), )

   _HB_MEMBER { bAlphaLevel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bAlphaLevel" }, .F., .F. ), )
   _HB_MEMBER { hAlphaLevel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "hAlphaLevel" }, .F., .F. ), )

   _HB_MEMBER {AS LOGICAL lWillShowABtn} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lWillShowABtn" }, .F., .F. ), )



   _HB_MEMBER New( oBrw); IIF( .F., s_oClass:ModMethod( "New", @TXBrwColumn_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TXBrwColumn_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER End(); IIF( .F., s_oClass:ModMethod( "End", @TXBrwColumn_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "End", @TXBrwColumn_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Edit( nKey); IIF( .F., s_oClass:ModMethod( "Edit", @TXBrwColumn_Edit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Edit", @TXBrwColumn_Edit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));





   _HB_MEMBER EditDateTime( nKey); IIF( .F., s_oClass:ModMethod( "EditDateTime", @TXBrwColumn_EditDateTime(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "EditDateTime", @TXBrwColumn_EditDateTime(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER nEditType(); _HB_MEMBER _nEditType(); IIF( .F., s_oClass:ModMethod( "nEditType", @TXBrwColumn_nEditType(), 1 + 32, .F. ), s_oClass:AddMethod( "nEditType", @TXBrwColumn_nEditType(), 1 + 32, .F. ) ) ; IIF( .F., s_oClass:ModMethod( "_nEditType", @TXBrwColumn_nEditType() ), s_oClass:AddMethod( "_nEditType", @TXBrwColumn_nEditType() ) ) ;

   _HB_MEMBER nFooterType(); _HB_MEMBER _nFooterType(); IIF( .F., s_oClass:ModMethod( "nFooterType", @TXBrwColumn_nFooterType(), 1 + 32 , .F. ), s_oClass:AddMethod( "nFooterType", @TXBrwColumn_nFooterType(), 1 + 32 , .F. ) ); IIF( .F., s_oClass:ModMethod( "_nFooterType", @TXBrwColumn_nFooterType() ), s_oClass:AddMethod( "_nFooterType", @TXBrwColumn_nFooterType() ) );


   _HB_MEMBER AddBitmap(uBmp); IIF( .F., s_oClass:ModInline( "AddBitmap", {|Self,uBmp | Self, fnAddBitmap( Self, uBmp ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "AddBitmap", {|Self,uBmp | Self, fnAddBitmap( Self, uBmp ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER AddBmpFile(cBmpFile, nBmpNo); IIF( .F., s_oClass:ModInline( "AddBmpFile", {|Self,cBmpFile, nBmpNo | Self, ( ( nbmpNo := fnAddBitmap( Self, cBmpFile ) ) > 0 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "AddBmpFile", {|Self,cBmpFile, nBmpNo | Self, ( ( nbmpNo := fnAddBitmap( Self, cBmpFile ) ) > 0 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER AddResource(cnResource, nBmpNo); IIF( .F., s_oClass:ModInline( "AddResource", {|Self,cnResource, nBmpNo | Self, ( ( nbmpNo := fnAddBitmap( Self, cnResource ) ) > 0 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "AddResource", {|Self,cnResource, nBmpNo | Self, ( ( nbmpNo := fnAddBitmap( Self, cnResource ) ) > 0 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER AddBmpHandle(hBmp, nBmpNo); IIF( .F., s_oClass:ModInline( "AddBmpHandle", {|Self,hBmp, nBmpNo | Self, ( ( nbmpNo := fnAddBitmap( Self, hBmp) ) > 0 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "AddBmpHandle", {|Self,hBmp, nBmpNo | Self, ( ( nbmpNo := fnAddBitmap( Self, hBmp) ) > 0 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER aBitmap(n); IIF( .F., s_oClass:ModInline( "aBitmap", {|Self,n | Self, ( n := IfNil( n, 0 ),  If( n > 0, If( n <= Len( ::aBitmaps ), ::aBitmaps[ n ], ::oBrw:aBitmap( n ) ),  If( n < 0, ::oBrw:aBitmap( -n ), nil ) ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "aBitmap", {|Self,n | Self, ( n := IfNil( n, 0 ),  If( n > 0, If( n <= Len( ::aBitmaps ), ::aBitmaps[ n ], ::oBrw:aBitmap( n ) ),  If( n < 0, ::oBrw:aBitmap( -n ), nil ) ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER ChangeBitmap(); IIF( .F., s_oClass:ModMethod( "ChangeBitmap", @TXBrwColumn_ChangeBitmap(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ChangeBitmap", @TXBrwColumn_ChangeBitmap(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER DefStyle( nAlign, lSingleLine); IIF( .F., s_oClass:ModMethod( "DefStyle", @TXBrwColumn_DefStyle(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DefStyle", @TXBrwColumn_DefStyle(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));





   _HB_MEMBER Show(); IIF( .F., s_oClass:ModInline( "Show", {|Self | Self, ( ::lHide := .F., ::oBrw:GetDisplayCols(), ::oBrw:Refresh() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Show", {|Self | Self, ( ::lHide := .F., ::oBrw:GetDisplayCols(), ::oBrw:Refresh() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )



   _HB_MEMBER Hide(); IIF( .F., s_oClass:ModInline( "Hide", {|Self | Self, ( ::lHide := .T., ::oBrw:GetDisplayCols(), ::oBrw:Refresh() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Hide", {|Self | Self, ( ::lHide := .T., ::oBrw:GetDisplayCols(), ::oBrw:Refresh() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER nAlphaLevel(nLevel); _HB_MEMBER _nAlphaLevel(nLevel); IIF( .F., s_oClass:ModMethod( "nAlphaLevel", @TXBrwColumn_nAlphaLevel(), 1 + 32, .F. ), s_oClass:AddMethod( "nAlphaLevel", @TXBrwColumn_nAlphaLevel(), 1 + 32, .F. ) ) ; IIF( .F., s_oClass:ModMethod( "_nAlphaLevel", @TXBrwColumn_nAlphaLevel() ), s_oClass:AddMethod( "_nAlphaLevel", @TXBrwColumn_nAlphaLevel() ) ) ;



   _HB_MEMBER Adjust(); IIF( .F., s_oClass:ModMethod( "Adjust", @TXBrwColumn_Adjust(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Adjust", @TXBrwColumn_Adjust(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER HeaderHeight(); IIF( .F., s_oClass:ModMethod( "HeaderHeight", @TXBrwColumn_HeaderHeight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HeaderHeight", @TXBrwColumn_HeaderHeight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER HeaderWidth(); IIF( .F., s_oClass:ModMethod( "HeaderWidth", @TXBrwColumn_HeaderWidth(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HeaderWidth", @TXBrwColumn_HeaderWidth(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER FooterHeight(); IIF( .F., s_oClass:ModMethod( "FooterHeight", @TXBrwColumn_FooterHeight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FooterHeight", @TXBrwColumn_FooterHeight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER FooterWidth(); IIF( .F., s_oClass:ModMethod( "FooterWidth", @TXBrwColumn_FooterWidth(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FooterWidth", @TXBrwColumn_FooterWidth(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DataHeight(); IIF( .F., s_oClass:ModMethod( "DataHeight", @TXBrwColumn_DataHeight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DataHeight", @TXBrwColumn_DataHeight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DataWidth(); IIF( .F., s_oClass:ModMethod( "DataWidth", @TXBrwColumn_DataWidth(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DataWidth", @TXBrwColumn_DataWidth(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER nWidthChr(); _HB_MEMBER _nWidthChr(); IIF( .F., s_oClass:ModMethod( "nWidthChr", @TXBrwColumn_nWidthChr(), 1 + 32, .F. ), s_oClass:AddMethod( "nWidthChr", @TXBrwColumn_nWidthChr(), 1 + 32, .F. ) ) ; IIF( .F., s_oClass:ModMethod( "_nWidthChr", @TXBrwColumn_nWidthChr() ), s_oClass:AddMethod( "_nWidthChr", @TXBrwColumn_nWidthChr() ) ) ;

   _HB_MEMBER PaintHeader( nRow, nCol, nHeight, lInvert, hDC, nGrpWidth); IIF( .F., s_oClass:ModMethod( "PaintHeader", @TXBrwColumn_PaintHeader(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PaintHeader", @TXBrwColumn_PaintHeader(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DataCol(); IIF( .F., s_oClass:ModMethod( "DataCol", @TXBrwColumn_DataCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DataCol", @TXBrwColumn_DataCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER PaintData( nRow, nCol, nHeight, lHighLite, lSelected, nOrder, nPaintRow); IIF( .F., s_oClass:ModMethod( "PaintData", @TXBrwColumn_PaintData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PaintData", @TXBrwColumn_PaintData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER PaintCell( nRow, nCol, nHeight, lHighLite, lSelected, nOrder, nPaintRow); IIF( .F., s_oClass:ModMethod( "PaintCell", @TXBrwColumn_PaintCell(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PaintCell", @TXBrwColumn_PaintCell(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER EraseData( nRow, nCol, nHeight, hBrush, lFixHeight); IIF( .F., s_oClass:ModMethod( "EraseData", @TXBrwColumn_EraseData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "EraseData", @TXBrwColumn_EraseData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Box( nRow, nCol, nHeight, lDotted); IIF( .F., s_oClass:ModMethod( "Box", @TXBrwColumn_Box(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Box", @TXBrwColumn_Box(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER PaintFooter( nRow, nCol, nHeight, lInvert); IIF( .F., s_oClass:ModMethod( "PaintFooter", @TXBrwColumn_PaintFooter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PaintFooter", @TXBrwColumn_PaintFooter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER RefreshFooter(); IIF( .F., s_oClass:ModMethod( "RefreshFooter", @TXBrwColumn_RefreshFooter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RefreshFooter", @TXBrwColumn_RefreshFooter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER footerStr(); IIF( .F., s_oClass:ModMethod( "footerStr", @TXBrwColumn_footerStr(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "footerStr", @TXBrwColumn_footerStr(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER IsVisible(lComplete); IIF( .F., s_oClass:ModInline( "IsVisible", {|Self,lComplete | Self, ( ! ::lHide .AND. ::oBrw:IsDisplayPosVisible( ::nPos, lComplete ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "IsVisible", {|Self,lComplete | Self, ( ! ::lHide .AND. ::oBrw:IsDisplayPosVisible( ::nPos, lComplete ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER HeaderLButtonDown( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "HeaderLButtonDown", @TXBrwColumn_HeaderLButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HeaderLButtonDown", @TXBrwColumn_HeaderLButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER HeaderLButtonUp( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "HeaderLButtonUp", @TXBrwColumn_HeaderLButtonUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HeaderLButtonUp", @TXBrwColumn_HeaderLButtonUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER FooterLButtonDown( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "FooterLButtonDown", @TXBrwColumn_FooterLButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FooterLButtonDown", @TXBrwColumn_FooterLButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER FooterLButtonUp( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "FooterLButtonUp", @TXBrwColumn_FooterLButtonUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FooterLButtonUp", @TXBrwColumn_FooterLButtonUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER MouseMove( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "MouseMove", @TXBrwColumn_MouseMove(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MouseMove", @TXBrwColumn_MouseMove(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ResizeBeg( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "ResizeBeg", @TXBrwColumn_ResizeBeg(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ResizeBeg", @TXBrwColumn_ResizeBeg(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ResizeEnd( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "ResizeEnd", @TXBrwColumn_ResizeEnd(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ResizeEnd", @TXBrwColumn_ResizeEnd(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CreateButtons(); IIF( .F., s_oClass:ModMethod( "CreateButtons", @TXBrwColumn_CreateButtons(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateButtons", @TXBrwColumn_CreateButtons(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ShowBtnList(); IIF( .F., s_oClass:ModMethod( "ShowBtnList", @TXBrwColumn_ShowBtnList(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ShowBtnList", @TXBrwColumn_ShowBtnList(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER RunBtnAction(); IIF( .F., s_oClass:ModMethod( "RunBtnAction", @TXBrwColumn_RunBtnAction(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RunBtnAction", @TXBrwColumn_RunBtnAction(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER PostEdit(); IIF( .F., s_oClass:ModMethod( "PostEdit", @TXBrwColumn_PostEdit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PostEdit", @TXBrwColumn_PostEdit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetCheck( aBmps, uEdit, aPrompts); IIF( .F., s_oClass:ModMethod( "SetCheck", @TXBrwColumn_SetCheck(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetCheck", @TXBrwColumn_SetCheck(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER CheckToggle(); IIF( .F., s_oClass:ModMethod( "CheckToggle", @TXBrwColumn_CheckToggle(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CheckToggle", @TXBrwColumn_CheckToggle(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetProgBar( nProgTotal, nWidth, bClrProg); IIF( .F., s_oClass:ModMethod( "SetProgBar", @TXBrwColumn_SetProgBar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetProgBar", @TXBrwColumn_SetProgBar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetAlign( nAlign); IIF( .F., s_oClass:ModMethod( "SetAlign", @TXBrwColumn_SetAlign(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetAlign", @TXBrwColumn_SetAlign(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetOrder(); IIF( .F., s_oClass:ModMethod( "SetOrder", @TXBrwColumn_SetOrder(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetOrder", @TXBrwColumn_SetOrder(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SortArrayData(); IIF( .F., s_oClass:ModMethod( "SortArrayData", @TXBrwColumn_SortArrayData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SortArrayData", @TXBrwColumn_SortArrayData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ClpText(); IIF( .F., s_oClass:ModMethod( "ClpText", @TXBrwColumn_ClpText(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ClpText", @TXBrwColumn_ClpText(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Paste( cText); IIF( .F., s_oClass:ModMethod( "Paste", @TXBrwColumn_Paste(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Paste", @TXBrwColumn_Paste(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ToExcel( oSheet, nRow, nCol); IIF( .F., s_oClass:ModMethod( "ToExcel", @TXBrwColumn_ToExcel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ToExcel", @TXBrwColumn_ToExcel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER isEditKey( nKey); IIF( .F., s_oClass:ModMethod( "isEditKey", @TXBrwColumn_isEditKey(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "isEditKey", @TXBrwColumn_isEditKey(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Value(uVal); _HB_MEMBER _Value(uVal); IIF( .F., s_oClass:ModMethod( "Value", @TXBrwColumn_Value(), 1 + 32, .F. ), s_oClass:AddMethod( "Value", @TXBrwColumn_Value(), 1 + 32, .F. ) ) ; IIF( .F., s_oClass:ModMethod( "_Value", @TXBrwColumn_Value() ), s_oClass:AddMethod( "_Value", @TXBrwColumn_Value() ) ) ;
   _HB_MEMBER BlankValue(); IIF( .F., s_oClass:ModMethod( "BlankValue", @TXBrwColumn_BlankValue(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "BlankValue", @TXBrwColumn_BlankValue(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER VarGet(); IIF( .F., s_oClass:ModInline( "VarGet", {|Self | Self, ::Value }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "VarGet", {|Self | Self, ::Value }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER VarPut(uVal); IIF( .F., s_oClass:ModInline( "VarPut", {|Self,uVal | Self, If( ::bOnPostEdit == nil, nil, ( ::PostEdit( uVal,, .T. ), uVal ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "VarPut", {|Self,uVal | Self, If( ::bOnPostEdit == nil, nil, ( ::PostEdit( uVal,, .T. ), uVal ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER lEditable(); IIF( .F., s_oClass:ModInline( "lEditable", {|Self | Self, ( ::nEditType > 0 .AND. ::bOnPostEdit <> nil .AND.  ( ::bEditWhen == nil .OR. Eval( ::bEditWhen, Self ) ) ) }, 1, .F. ), s_oClass:AddInline( "lEditable", {|Self | Self, ( ::nEditType > 0 .AND. ::bOnPostEdit <> nil .AND.  ( ::bEditWhen == nil .OR. Eval( ::bEditWhen, Self ) ) ) }, 1, .F. ) )

   _HB_MEMBER SetColsAsRows( aCols); IIF( .F., s_oClass:ModMethod( "SetColsAsRows", @TXBrwColumn_SetColsAsRows(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetColsAsRows", @TXBrwColumn_SetColsAsRows(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER WorkMergeData(); IIF( .F., s_oClass:ModMethod( "WorkMergeData", @TXBrwColumn_WorkMergeData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "WorkMergeData", @TXBrwColumn_WorkMergeData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER HasBorder(); IIF( .F., s_oClass:ModMethod( "HasBorder", @TXBrwColumn_HasBorder(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HasBorder", @TXBrwColumn_HasBorder(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER MergeArea(); IIF( .F., s_oClass:ModMethod( "MergeArea", @TXBrwColumn_MergeArea(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MergeArea", @TXBrwColumn_MergeArea(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER RecalcTotal( nOldVal, nNewVal); IIF( .F., s_oClass:ModMethod( "RecalcTotal", @TXBrwColumn_RecalcTotal(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RecalcTotal", @TXBrwColumn_RecalcTotal(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SumOfCols( aCols, nType); IIF( .F., s_oClass:ModMethod( "SumOfCols", @TXBrwColumn_SumOfCols(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SumOfCols", @TXBrwColumn_SumOfCols(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SameColAs( u); IIF( .F., s_oClass:ModMethod( "SameColAs", @TXBrwColumn_SameColAs(), 4 + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SameColAs", @TXBrwColumn_SameColAs(), 4 + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   IIF( .F., s_oClass:ModInline( "==", {|Self, u | Self, ::SameColAs( u ) }, nScope ), s_oClass:AddInline( "==", {|Self, u | Self, ::SameColAs( u ) }, nScope ) )
   IIF( .F., s_oClass:ModInline( "<>", {|Self, u | Self, ! ::SameColAs( u ) }, nScope ), s_oClass:AddInline( "<>", {|Self, u | Self, ! ::SameColAs( u ) }, nScope ) )

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TXBrwColumn ;



UTILITY STATIC function TXBrwColumn_New( oBrw) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   ::oBrw  := oBrw

   ::aBitmaps := {}

   ::cHeader := ""
   ::cFooter := ""
   ::cOrder  := ""

   ::nDisplayCol    := 0
   ::nCreationOrder := Len( oBrw:aCols ) + 1

   ::lAllowSizing := .T.
   ::lBmpStretch  := .F.

return Self



UTILITY STATIC function TXBrwColumn_End() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nFor

   if ::oBtnList <> nil
      ::oBtnList:End()
   endif

   if ::oBtnElip <> nil
      ::oBtnElip:End()
   endif

   if ::oEditGet <> nil
      ::oEditGet:End()
   endif

   for nFor := 1 to Len( ::aBitmaps )
      PalBmpFree( ::aBitmaps[ nFor, 1 ], ::aBitmaps[ nFor, 2 ] )
   next

return nil



UTILITY STATIC function TXBrwColumn_Adjust() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nWid, tmp, aToken, cOrder, cType

   IIF( ::cOrder == nil, ::cOrder := "", ) ;

   if ::cEditPicture == nil .AND. ::cDataType == "T"
      ::cEditPicture := "@T"
   endif

   if ValType( ::oBrw:aArrayData ) == "A"
      if ::bEditValue == nil
         if ::nArrayCol > 0


            ::bEditValue   :=  { |x| If( x == nil, ::oBrw:ArrCell( ::oBrw:nArrayAt, ::nArrayCol ),  ::oBrw:ArrCellSet( ::oBrw:nArrayAt, ::nArrayCol, x ) ) }
            if ValType( ::bBmpData) == "N"
               tmp                     := ::bBmpData
               ::bBmpData              := { || ::oBrw:aRow[ tmp ] }
            elseif ::bStrData == nil .AND. ! ::hChecked


               ::bStrData     :=  { || ::oBrw:ArrCell( ::oBrw:nArrayAt, ::nArrayCol, ::cEditPicture,  ::lDisplayZeros ) }
            endif
         endif
      endif

   elseif ValType( ::oBrw:aArrayData ) == "H"
         IIF( ::nWidth == nil, ::nWidth := 100, ) ;
   endif

   if ::bEditValue <> nil

      if Empty( ::cDataType ) .OR. ::cDataType $ "CU"
         ::cDataType := ValType( ::Value )
      endif


      if ::cEditPicture == nil .AND. ::cDataType == "N" .AND.  ::nDataLen <> nil .AND. ::oBrw:nDataType <> 2
         ::cEditPicture := NumPict( ::nDataLen, ::nDataDec, .T. )
      endif


      if ::cDataType == "T"
         IIF( ::cEditPicture == nil, ::cEditPicture := "@D", ) ;
      endif

      if ::cDataType $ "DT"

         IIF( ::nDataStrAlign == nil, ::nDataStrAlign := 1, ) ; IIF( ::nHeadStrAlign == nil, ::nHeadStrAlign := 1, );
      endif

      if ::cDataType == "N"


         IIF( ::nDataStrAlign == nil, ::nDataStrAlign := 1, ) ; IIF( ::nHeadStrAlign == nil, ::nHeadStrAlign := 1, ); IIF( ::nFootStrAlign == nil, ::nFootStrAlign := 1, );
      else
         ::lTotal := .F.
      endif

      if ::bStrData == nil .AND. !( ::cDataType $ "PF" )

         ::bStrData  := { || cValToStr( ::Value, ::cEditPicture,,  IfNil( ::lDisplayZeros, ::oBrw:lDisplayZeros ) ) }
      elseif ValType( ::bStrData ) <> "B"
         ::bStrData  := nil
      endif

      IIF( ::bOnPostEdit == nil, ::bOnPostEdit := { |o,x,n| If( n <> 27, ::Value := x,) }, ) ;

      if ::cSortOrder <> nil
         if ValType( ::cSortOrder ) <> "B"
            if ( ::oBrw:nDataType == 1 )

               if Empty( ::cOrdBag ) .OR. ( ValType( ::cOrdBag ) == "C" .AND.  (::oBrw:cAlias)->( OrdNumber( ::cSortOrder, ::cOrdBag ) ) == 0 )
                  ::cOrdBag    := (::oBrw:cAlias)->( OrdBagName( ::cSortOrder ) )
               endif
               if EQ( (::oBrw:cAlias)->( OrdSetFocus() ), ::cSortOrder )
                  ::cOrder       := "A"
               endif
            elseif ( ::oBrw:nDataType == 4 )
               if EQ( ::oBrw:oRs:Sort, ::cSortOrder )
                  ::cOrder       := "A"
               endif
            elseif ( ::oBrw:nDataType == 64 )
               if ::oBrw:oMysql:IsKindOf( "TDOLPHINQRY" )
                  aToken := HB_ATokens( ::oBrw:oMySql:cOrder, " " )
                  IF Len( aToken ) == 1
                     AAdd( aToken, "ASC" )
                  ENDIF
                  cOrder = AllTrim( Lower( aToken[ 1 ] ) )
                  cType = aToken[ 2 ]
                  if EQ( cOrder, ::cSortOrder )
                     IF Upper( cType ) == "ASC"
                        ::cOrder = "A"
                     ELSE
                        ::cOrder = "D"
                     ENDIF
                  endif
               else
                  if EQ( ::oBrw:oMysql:cSort, ::cSortOrder )
                     ::cOrder       := "A"
                  endif
               endif
            elseif ( ::oBrw:nDataType == 16 )
               if EQ( ::oBrw:oDbf:SetOrder, ::cSortOrder )
                  ::cOrder       := "A"
               endif
            endif
         endif
      endif
   endif

   if ::nEditType == -1 .OR. ::bStrImage <> nil
      ::cDataType        := "F"
   endif

   if ValType( tmp := ::Value ) == "C" .AND. IsBinaryData( tmp )
      if IfNil( FITypeFromMemory( tmp ), -1 ) >= 0
         ::cDataType    := "P"
      endif
   endif

   IIF( ::cDataType == nil, ::cDataType := "C", ) ;

   if ::cDataType $ "PF"
      ::oBrw:lExcelCellWise   := .T.
      IIF( ::lBmpTransparent == nil, ::lBmpTransparent := .F., ) ;
   elseif ::cDataType == "M"
      IIF( ::nWidth == nil, ::nWidth := 200, ) ;
   endif

   IIF( ::lBmpTransparent == nil, ::lBmpTransparent := .T., ) ;


   if ( ::bStrData == nil .OR. Eval( ::bStrData ) == nil ) .AND.  ( ::bBmpData <> nil .OR. ::cDataType $ "PF")

      IIF( ::nDataBmpAlign == nil, ::nDataBmpAlign := 2, ) ;

   endif

   if ! Empty( ::hFooterType )
      IIF( ::nTotal == nil, ::nTotal := 0, ) ;
   endif
   if ValType( ::nTotal ) == "N"
      IIF( ::hFooterType == nil, ::hFooterType := 1, ) ;
   endif






   IIF( ::oDataFont == nil, ::oDataFont := ::oBrw:oFont, ) ; IIF( ::oHeaderFont == nil, ::oHeaderFont := ::oBrw:oFont, ); IIF( ::oDataFontBold == nil, ::oDataFontBold := ::oBrw:oFont, ); IIF( ::oFooterFont == nil, ::oFooterFont := ::oBrw:oFont, ); IIF( ::oGrpFont == nil, ::oGrpFont := ::oDataFontBold, ); IIF( ::oEditFont == nil, ::oEditFont := ::oBrw:oFont, );






   IIF( ::nDataStrAlign == nil, ::nDataStrAlign := 0, ) ; IIF( ::nDataBmpAlign == nil, ::nDataBmpAlign := 0, ); IIF( ::nHeadStrAlign == nil, ::nHeadStrAlign := 0, ); IIF( ::nFootStrAlign == nil, ::nFootStrAlign := 0, ); IIF( ::nHeadBmpAlign == nil, ::nHeadBmpAlign := 0, ); IIF( ::nFootBmpAlign == nil, ::nFootBmpAlign := 0, );







   IIF( ::bClrHeader == nil, ::bClrHeader := ::oBrw:bClrHeader, ) ; IIF( ::bClrFooter == nil, ::bClrFooter := ::oBrw:bClrFooter, ); IIF( ::bClrGrad == nil, ::bClrGrad := ::oBrw:bClrGrad, ); IIF( ::bClrStd == nil, ::bClrStd := ::oBrw:bClrStd, ); IIF( ::bClrSel == nil, ::bClrSel := ::oBrw:bClrSel, ); IIF( ::bClrSelFocus == nil, ::bClrSelFocus := ::oBrw:bClrSelFocus, ); IIF( ::bClrEdit == nil, ::bClrEdit := ::bClrStd, );



   IIF( ::nWidth == nil, ::nWidth := Max( Max( ::HeaderWidth(), ::FooterWidth() ), ::DataWidth() ) + 6, ) ;



   IIF( ::nDataStyle == nil, ::nDataStyle := ::DefStyle( ::nDataStrAlign, ( ::oBrw:nDataLines == 1 ) ), ) ; IIF( ::nHeadStyle == nil, ::nHeadStyle := ::DefStyle( ::nHeadStrAlign, ( ::oBrw:nHeaderLines == 1 ) ), ); IIF( ::nFootStyle == nil, ::nFootStyle := ::DefStyle( ::nFootStrAlign, ( ::oBrw:nFooterLines == 1 ) ), );

   if ! Empty( ::cGrpHdr ) .AND. Empty( ::nGrpHeight )
      ::nGrpHeight   := FontHeight( ::oBrw, ::oGrpFont )
   endif

   ::CreateButtons()

   if ::lMergeVert
      ::oBrw:lMergeVert := .T.
      ::WorkMergeData()
   endif

return nil



UTILITY STATIC function TXBrwColumn_Value(uNew) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local uVal

   if PCount() > 0 .AND. ::bEditValue <> nil

      TRY
         uVal   := Eval( ::bEditValue )
      CATCH
      END
      if ! ( ValType( uVal ) == ValType( uNew ) .AND. uVal == uNew )
         TRY
            Eval( ::bEditValue, uNew )
            ::oBrw:lEdited    := .T.
         CATCH
         END
      endif

   endif

   uVal     := nil
   if ::bEditValue == nil .AND. ::nArrayCol > 0

      uVal     := ::oBrw:ArrCell( ::oBrw:nArrayAt, ::nArrayCol )
   elseif ::bEditValue <> nil
      TRY
         uVal  := Eval( ::bEditValue )
      CATCH
         uVal  := ::BlankValue()
      END
   elseif ::bStrData <> nil
      TRY
         uVal  := Eval( ::bStrData )
      CATCH
         uVal  := ""
      END
   endif

return uVal



UTILITY STATIC function TXBrwColumn_BlankValue() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local uVal  := ""

   if ::cDataType == "N"
      uVal     := 0
   elseif ::cDataType == "D"
      uVal     := CToD( "" )
   elseif ::cDataType == "L"
      uVal     := .F.
   else
      uVal     := Space( If( Empty( ::nDataLen ), ::nWidthChr, ::nDataLen ) )
   endif

return uVal



UTILITY STATIC function TXBrwColumn_SameColAs( u) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local lRet  := .F.
   local cParType := ValType( u )
   local cHeader, cHead

   if cParType == "O"
      lRet  :=  ( u:IsKindOf( "TXBRWCOLUMN" ) .AND. ::nCreationOrder == u:nCreationOrder )
   elseif cParType == "N"
      lRet  :=  ( ::nCreationOrder == u )

   elseif cParType == "C" .AND. ValType( ::cHeader ) == "C" .AND.  ! Empty( ::cHeader ) .AND. ! Empty( u )

      u        := Upper( u )
      cHeader  := Upper( ::cHeader )
      cHead    := CharRem( Chr(9) + Chr(10) + Chr(13) + Chr(32), cHeader )
      if cHeader == u .OR. cHead == u
         lRet  := .T.
      elseif ! Empty( ::cGrpHdr )
         if Upper( ::cGrpHdr ) + "_" + cHeader == u
            lRet  := .T.
         elseif Upper( ::cGrpHdr ) + "_" + cHead == u
            lRet  := .T.
         endif
      endif
   endif

return lRet



UTILITY STATIC function TXBrwColumn_nAlphaLevel(uNew) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   if uNew <> NIL
      ::hAlphaLevel := uNew
   else
      if ::bAlphaLevel <> NIL
         ::hAlphaLevel = eval( ::bAlphaLevel, Self )
      endif
   endif

return ::hAlphaLevel



UTILITY STATIC function TXBrwColumn_SetCheck( aBmps, uEdit, aPrompts) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nBmpOn, nBmpOff := 0, nBmpNull := 0
   local LogiVal := .F.

   if Empty( aBmps )
      aBmps    := { FWBmpOn(), FWBmpOff() }
   elseif ValType( aBmps ) == "A" .AND. Len( aBmps ) < 2
      AAdd( aBmps, FWBmpOff() )
   endif
   nBmpOn   := ::AddBitmap( aBmps[ 1 ] )
   nBmpOff  := ::AddBitmap( aBmps[ 2 ] )
   if Len( aBmps ) > 2
      nBmpNull := ::AddBitmap( aBmps[ 3 ] )
   endif

   ::bBmpData  := { | u | If( ValType( u := ::Value ) == "L", If( u, nBmpOn, nBmpOff ), nBmpNull ) }
   ::bStrData  := .F.
   ::hChecked  := .T.
   if ValType( uEdit ) == "B"
      ::bOnPostEdit  := uEdit
      ::nEditType    := 1
   elseif ValType( uEdit ) == "N"
      ::nEditType    := uEdit
   elseif ValType( uEdit ) == "L"
      ::nEditType    := If( uEdit, 1, 0 )
   endif
   if ValType( aPrompts ) == "A"
      if Len( aPrompts ) < 3
         ASize( aPrompts, 3 )
      endif
      AEval( aPrompts, { |c, i| If( ValType( c ) <> "C", aPrompts[ i ] := "", ) } )

      ::bStrData  := { | u | If( ValType( u := ::Value ) == "L",  If( u, aPrompts[ 1 ], aPrompts[ 2 ] ), aPrompts[ 3 ] ) }
   endif

return nil



UTILITY STATIC function TXBrwColumn_CheckToggle() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local uVal  := IfNil( ::Value, .F. )

   if ValType( uVal ) == "L"
      ::PostEdit( ! uVal )
   endif

return Self



UTILITY STATIC function TXBrwColumn_SetProgBar( nProgTotal, nWidth, bClrProg) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   ::lProgBar        := .T.
   if nProgTotal <> nil
      ::nProgTot     := nProgTotal
   endif
   if ValType( bClrProg )  == "B"
      ::bClrProg     := bClrProg
   endif

   ::nDataStrAlign := ::nHeadStrAlign := 2

   if nWidth <> nil
      ::nWidth       := nWidth
   endif

return nil



UTILITY STATIC function TXBrwColumn_SetAlign( nAlign) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   if ValType( nAlign ) == "N"
      nAlign      := Min( Max( nAlign, 0 ), 2 )
      if nAlign <> ::nDataStrAlign
         ::nDataStrAlign      := nAlign
         ::nDataStyle         := ::DefStyle( nAlign, ::oBrw:nDataLines == 1 )
         ::oBrw:Refresh()
      endif
   endif

Return Self



UTILITY STATIC function TXBrwColumn_HeaderHeight( lGrpHdr) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nHeight := 0
   local aBitmap

   IIF( lGrpHdr == nil, lGrpHdr := .F., ) ;

   if lGrpHdr
      if ! Empty( ::cGrpHdr )
         nHeight  := ( FontHeight( ::oBrw, IfNil( ::oGrpFont, ::oHeaderFont ) ) + 2 ) * MLCount( ::cGrpHdr ) + 2
      endif
      if ! Empty( aBitmap := ::aBitmap( ::nGrpBmpNo ) )
         nHeight := Max( nHeight, aBitmap[ 4 ] + 2 )
      endif
   else

      nHeight := FontHeight( ::oBrw, ::oBrw:oWnd:oFont )
      if ! Empty( ::cHeader ) .AND. ::oHeaderFont <> nil

         nHeight := FontHeight( ::oBrw, ::oHeaderFont ) * MLCount( ::cHeader )
         if FontEsc( ::oHeaderFont ) % 1800  == 900
            nHeight := Max( nHeight, ::oBrw:GetWidth( ::cHeader, ::oHeaderFont ) + 6 )
         endif
      endif

      if ! Empty( aBitmap := ::aBitmap( If( ValType( ::nHeadBmpNo ) == "B", Eval( ::nHeadBmpNo ), ::nHeadBmpNo ) ) )
         nHeight := Max( nHeight, aBitmap[ 4 ] + 2 )
      endif
      if Empty( ::cGrpHdr )
         ::nGrpHeight   := 0
      else
         nHeight  += ::nGrpHeight + 1
      endif

   endif

return nHeight



UTILITY STATIC function TXBrwColumn_HeaderWidth() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local cText, cLine
   local nWidth, nFrom, nLen, nFor, nTemp
   local aBitmap

   cText  := ::cHeader
   nWidth := 0
   nFrom  := 1

   if !Empty( cText )
      if FontEsc( ::oHeaderFont ) % 1800 == 900
         nWidth   := FontHeight( ::oBrw, ::oHeaderFont ) + 6
      else
          nLen  := Len( cText )
          While nFrom <= nLen
            cLine  := ExtractLine( cText, @nFrom )
            nWidth := Max( nWidth, ::oBrw:GetWidth( cLine, ::oHeaderFont ) )
          enddo
      endif
   endif

   if ! Empty( aBitmap := ::aBitmap( If( ValType( ::nHeadBmpNo ) == "B", Eval( ::nHeadBmpNo ), ::nHeadBmpNo ) ) )
      nWidth   += aBitmap[ 3 ] + 5
   elseif ! Empty( ::cSortOrder )
      nWidth += ::oBrw:aSortBmp[ 1 ][ 3 ] + 5
   endif

return Max( nWidth, 16 )



UTILITY STATIC function TXBrwColumn_FooterHeight() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nHeight
   local cFooter
   local aBitmap

   nHeight := FontHeight( ::oBrw, ::oBrw:oWnd:oFont )

   cFooter := ::footerStr()

   if cFooter <> nil .AND. ::oFooterFont <> nil
      nHeight := FontHeight( ::oBrw, ::oFooterFont )
   endif

   if ! Empty( aBitmap := ::aBitmap( ::nFootBmpNo ) )
      nHeight := Max( nHeight, aBitmap[ 4 ] )
   endif

return nHeight



UTILITY STATIC function TXBrwColumn_FooterWidth() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local cText, cLine
   local nWidth, nFrom, nLen
   local aBitmap

   cText  := ::footerStr()
   nWidth := 0
   nFrom  := 1

   if !Empty( cText )
       nLen  := Len( cText )
       While nFrom <= nLen
         cLine  := ExtractLine( cText, @nFrom )
         nWidth := Max( nWidth, ::oBrw:GetWidth( cLine, ::oFooterFont ) )
       enddo
   endif

   if ! Empty( aBitmap := ::aBitmap( ::nFootBmpNo ) )
      nWidth := Max( nWidth, aBitmap[ 3 ] ) + 5
   endif

return Max( nWidth, 16 )



UTILITY STATIC function TXBrwColumn_DataHeight() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nHeight, nBmp, nBmpHeight, cData

   nHeight := FontHeight( ::oBrw, ::oBrw:oWnd:oFont )

   if ::bStrData <> nil .AND. ::oDataFont <> nil
      if ValType( ::oDataFont ) == "B"
         nHeight := FontHeight( ::oBrw, Eval( ::oDataFont, Self ) )
      else
         nHeight := FontHeight( ::oBrw, ::oDataFont )
      endif
   endif

   if ::bBmpData <> nil

      nBmpHeight   := 0
      AEval( ::aBitmaps, { |a| nBmpHeight := Max( nBmpHeight, a[ 4 ] ) } )
      nHeight  := Max( nHeight, nBmpHeight )

   endif

   if ::cDataType $ "PF"

      if ::cDataType == "F" .AND. File( ::Value )
         nBmp     := FILoadImg( ::Value )
      else
         nBmp     := FILoadFromMemory( ::Value )
      endif
      nHeight     := Int( GetSysMetrics( 1 ) / 10 )
      if nBmp > 0
         nHeight  := Min( nBmpHeight( nBmp ) + 4, nHeight )
      endif
      DeleteObject( nBmp )
      if ::oBrw:nDataLines > 1
         nheight  := Round( nHeight / ::oBrw:nDataLines, 0 )
      endif
   endif

   if ::nEditType == 6
      nHeight  := Max( 24, nHeight )
   endif

   ::nDataHeight  := nHeight

return nHeight



UTILITY STATIC function TXBrwColumn_DataWidth() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local cText, cLine, oFont
   local nWidth, nFrom, nBmp, nLen
   local nBmpWidth

   nWidth := 0
   nFrom  := 1

   if ::bStrData <> nil
      cText := Eval( ::bStrData )
      nLen  := Len( cText )
      if ValType ( ::oDataFont ) == "B"
         oFont = Eval( ::oDataFont, Self )
      else
         oFont = ::oDataFont
      endif
      while nFrom <= nLen
        cLine  := ExtractLine( cText, @nFrom )
        cLine  := Replicate( "B", Len( cLine ) )
        nWidth := Max( nWidth, ::oBrw:GetWidth( cLine, oFont ) )
      enddo

      if ::nDataLen <> nil .AND. ::bEditValue <> nil .AND. ::cEditPicture == nil
         nWidth   := Max( nWidth, ::oBrw:GetWidth( Replicate( "B", ::nDataLen ), oFont ) )
      endif

   endif

   if ::bBmpData <> nil
      nBmpWidth   := 0
      AEval( ::aBitmaps, { |a| nBmpWidth := Max( nBmpWidth, a[ 3 ] ) } )
      nWidth   += nBmpWidth + 5
   endif

   if ::cDataType $ "PF"

      if ::cDataType == "F" .AND. File( ::Value )
         nBmp     := FILoadImg( ::Value )
      else
         nBmp     := FILoadFromMemory( ::Value )
      endif
      nWidth      := Int( GetSysMetrics( 0 ) / 10 )
      if nBmp > 0
         nWidth   := Min( nBmpWidth( nBmp ) + 4, nWidth )
      endif
      DeleteObject( nBmp )
   endif





   if ::nEditType > 1
      nWidth += 15
   endif

return nWidth



UTILITY STATIC function TXBrwColumn_nWidthChr(nChars) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local oFont
   local n


   oFont    := If( ValType( ::oDataFont ) == "B", Eval( ::oDataFont, Self ),  ::oDataFont )
   if PCount() == 0
      n        := ::oBrw:GetWidth( Replicate( "B", 100 ), oFont )
      nChars   := If( ::nWidth == nil, 10, Int( ::nWidth * 100 /  n ) )
   else
      nChars   := Max( 3, nChars )
      ::nWidth  := ::oBrw:GetWidth( Replicate( "B", nChars ), oFont )
   endif

return nChars



UTILITY STATIC function TXBrwColumn_PaintHeader( nRow, nCol, nHeight, lInvert, hDC, nGrpWidth, aBitmap) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local hBrush
   local oFont
   local aColors
   local cHeader
   local nWidth, nBmpRow, nBmpCol, nBmpNo, nBmpAlign
   local lOwnDC, nBottom, nStyle

   IIF( lInvert == nil, lInvert := .F., ) ;

   if ::bClrHeader == nil
      ::Adjust()
   endif

   if nCol <> nil
      if nCol <> 0
         ::nDisplayCol := nCol
      endif
   else
      nCol := ::nDisplayCol
   endif

   if ! lInvert
      aColors := Eval( ::bClrHeader )
   else
      aColors := { If( ::oBrw:l2007, 0, 16777215 ), 8388608 }
   endif

   if hDC == nil
      hDC := ::oBrw:GetDC()
      lOwnDC := .F.
   else
      lOwnDC := .T.
   endif

   if nGrpWidth == nil

      nWidth   := ::nWidth
      if ::cHeader == nil

         ::cHeader := ""
      endif
      cHeader  := ::cHeader
      nRow     := nRow + ::nGrpHeight
      nHeight  := nHeight - ::nGrpHeight
      oFont    := ::oHeaderFont
      nStyle   := ::DefStyle( ::nHeadStrAlign, ! ( Chr(13)+Chr(10) $ cHeader ) )
      nBmpNo   := If( ValType( ::nHeadBmpNo ) == "B", Eval( ::nHeadBmpNo ), ::nHeadBmpNo )
      if ! Empty( ::cOrder )
         aBitmap     := ::oBrw:aSortBmp[ If( ::cOrder == "A", 1, 2 ) ]
         nBmpAlign   := 1
      elseif !Empty( aBitmap := ::aBitmap( nBmpNo ) )
         nBmpAlign   := ::nHeadBmpAlign
      endif
   else

      nWidth   := nGrpWidth
      cHeader  := ::cGrpHdr
      nHeight  := ::nGrpHeight
      oFont    := ::oGrpFont
      nStyle   := ::DefStyle( 2, ! ( Chr(13)+Chr(10) $ cHeader ) )
      if Empty( aBitmap )
         nBmpNo         := ::nGrpBmpNo
         aBitmap     := ::aBitmap( nBmpNo )
      endif
      nBmpAlign   := 0
   endif

   if ::oBrw:l2007

      GradientFill( hDC, nRow - 1, nCol, nRow + nHeight - 1, nCol + nWidth,  Eval( ::bClrGrad, lInvert ) )
   else
      hBrush  := CreateSolidBrush( aColors[ 2 ] )
      FillRect( hDC, { nRow, nCol, nRow + nHeight, nCol + nWidth }, hBrush )
      DeleteObject( hBrush )
   endif

   nCol    += ( 6 / 2 )
   nWidth  -=  6
   nRow    += ( 4 / 2 )
   nHeight -=  4












   if ! Empty( aBitmap )

      nWidth         -= aBitmap[ 3 ]
      if Empty(cHeader)
         nBmpCol := nCol + nwidth / 2
      elseif nBmpAlign == 0
         nBmpCol     := nCol
         nCol        += aBitmap[ 3 ] + 5
      else
         nBmpCol := nCol + nWidth
      endif
      nWidth         -= 5
      nBmpRow        := nRow + ( nHeight - aBitmap[ 4 ] ) / 2
      if SetAlpha() .AND. aBitmap[ 6 ]
         ABPaint( hDC, nBmpCol, nBmpRow, aBitmap[ 1 ], ::nAlphaLevelHeader )
      elseif ::oBrw:l2007
         IIF( aBitmap[ 5 ] == nil, aBitmap[ 5 ] := GetZeroZeroClr( hDC, aBitmap[ 1 ] ), ) ;
         SetBkColor( hDC, nRGB( 255, 255, 255 ) )


         TransBmp( aBitmap[ 1 ], aBitmap[ 3 ], aBitmap[ 4 ], aBitmap[ 5 ], hDC, nBmpCol, nBmpRow, nBmpWidth( aBitmap[ 1 ] ), nBmpHeight( aBitmap[ 1 ] ) )
      else





         PalBmpDraw( hDC, nBmpRow, nBmpCol, aBitmap[ 1 ], aBitmap[ 2 ], aBitmap[ 3 ], aBitmap[ 4 ] ,, .T., aColors[ 2 ] )
      endif
   endif

   if Empty( cHeader )
      ::oBrw:ReleaseDC()
      return nil
   endif

   oFont:Activate( hDC )
   SetTextColor( hDC, aColors[ 1 ] )
   SetBkColor( hDC, aColors[ 2 ] )
   SetBkMode ( hDC, 1 )

   if FontEsc( oFont ) % 3600 == 900

      nBottom  := nRow + nHeight / 2
      nBottom  += ( ::oBrw:GetWidth( cHeader, ::oHeaderFont ) / 2 )
      nCol     := nCol + nWidth / 2
      nCol     -= FontHeight( ::oBrw, ::oHeaderFont ) / 2



      DrawTextEx( hDC, cHeader, { nBottom, nCol, nRow, nCol + nWidth },  0x00000000 + 0x00000004 )

   elseif FontEsc( oFont ) % 3600  == 2700

      nBottom  := nRow + nHeight / 2
      nBottom  += ( ::oBrw:GetWidth( cHeader, ::oHeaderFont ) / 2 )
      nCol     := nCol + nWidth / 2
      nCol     += FontHeight( ::oBrw, ::oHeaderFont ) / 2



      DrawTextEx( hDC, cHeader, { nRow, nCol, nBottom, nCol - nWidth / 2 },  0x00000000 + 0x00000004 )

   else
      nBottom  := nRow + nHeight
      DrawTextEx( hDC, cHeader, { nRow, nCol, nBottom, nCol + Min( nWidth, ::oBrw:nWidth - 50 ) }, nStyle )
   endif

   oFont:Deactivate( hDC )

   if !lOwnDC
      ::oBrw:ReleaseDC()
   endif

return nil



UTILITY STATIC function TXBrwColumn_nFooterType(nType) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   if PCount() > 0

      if ValType( nType ) == "N" .AND.  AScan( { 1, 4, 2, 8, 1 + 8, 1 + 8 + 16, 1 + 8 + 16 + 32 }, nType ) > 0
         if ValType( ::nTotal ) <> "N"
            ::nTotal := 0.0
         endif
         ::hFooterType  := nType
         ::lTotal       := .T.
      else
         ::hFooterType  := nil
         ::nTotal       := nil
         ::lTotal       := .F.
      endif
   endif

RETURN ::hFooterType



UTILITY STATIC function TXBrwColumn_footerStr() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local cFooter := "", cType

   if ::bFooter <> nil
      cFooter  := Eval( ::bFooter, Self )
      IIF( cFooter == nil, cFooter := "", ) ;
   elseif ::nTotal <> nil .OR. ! Empty( ::nFooterType )
      IIF( ::nFooterType == nil, ::nFooterType := 1, ) ; IIF( ::nTotal == nil, ::nTotal := 0.0, );
      if ::nFooterType >= 1 + 8 + 16
         if ::nCount > 0
            cFooter  := ::nTotalSq - ( ::nTotal * ::nTotal / ::nCount )
            cFooter  /= ::nCount - If( ::nFooterType == 1 + 8 + 16 + 32, 0, 1 )
            cFooter  ^= 0.5
         else
            cFooter  := 0
         endif
      elseif ::nFooterType == 1 + 8
         cFooter  := If( ::nCount > 0, ::nTotal / ::nCount, 0 )
      elseif ::nFooterType == 8
         cFooter  := ::nCount
      else
         cFooter  := ::nTotal
      endif
   elseif ::cFooter <> nil
      cFooter  := ::cFooter
   endif

   cType    := ValType( cFooter )
   if cType <> "C"
      if cType == ::cDataType .AND. ::cEditPicture <> nil

         cFooter  := cValToStr( cFooter, ::cEditPicture,,  IfNil( ::lDisplayZeros, ::oBrw:lDisplayZeros ) )
      else
         cFooter := cValToChar( cFooter )
      endif
   endif

return cFooter



UTILITY STATIC function TXBrwColumn_PaintFooter( nRow, nCol, nHeight, lInvert) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local hDC, hBrush
   local oFont
   local aColors, aBitmap
   local cFooter
   local nWidth, nBmpRow, nBmpCol, nBmpNo, nBottom

   IIF( lInvert == nil, lInvert := .F., ) ;

   if nCol <> nil
      ::nDisplayCol := nCol
   else
      nCol := ::nDisplayCol
   endif

   if !lInvert
      aColors := Eval( ::bClrFooter )
   else
      aColors := { 16777215, 8388608 }
   endif

   hDC     := ::oBrw:GetDC()
   oFont   := ::oFooterFont
   cFooter := ::footerStr()
   nWidth  := ::nWidth
   nBmpNo  := ::nFootBmpNo

   nBottom = nRow + ( nHeight / 3 )
   if ::oBrw:l2007

      GradientFill( hDC, nRow - 1, nCol, nRow + nHeight - 1, nCol + nWidth,  Eval( ::bClrGrad, lInvert ) )

   else
      hBrush  := CreateColorBrush( aColors[ 2 ] )
      FillRect( hDC, {nRow, nCol, nRow + nHeight, nCol + nWidth}, hBrush )
      DeleteObject( hBrush )
   endif

   nCol    += ( 6 / 2 )
   nWidth  -=  6
   nRow    += ( 4 / 2 )
   nHeight -=  4

   if !Empty( aBitmap := ::aBitmap( nBmpNo ) )
      nWidth  -= aBitmap[ 3 ]
      if Empty(cFooter)
         nBmpCol := nCol + nWidth / 2
      elseif ::nFootBmpAlign == 0
         nBmpCol := nCol
         nCol    += aBitmap[ 3 ] + 5
      else
         nBmpCol := nCol + nWidth
      endif
      nWidth  -= 5
      nBmpRow := nRow + ( nHeight - aBitmap[ 4 ] ) / 2 + 2
      if ! ::oBrw:l2007
         if SetAlpha() .AND. aBitmap[ 6 ]
            ABPaint( hDC, nBmpCol, nBmpRow, aBitmap[ 1 ], ::nAlphaLevelFooter )
         else






            PalBmpDraw( hDC, nBmpRow, nBmpCol, aBitmap[ 1 ], aBitmap[ 2 ], aBitmap[ 3 ], aBitmap[ 4 ] ,, .T., aColors[ 2 ] )
         endif
      else
         if SetAlpha() .AND. aBitmap[ 6 ]
            ABPaint( hDC, nBmpCol, nBmpRow, aBitmap[ 1 ], ::nAlphaLevelFooter )
         else

            IIF( aBitmap[ 5 ] == nil, aBitmap[ 5 ] := GetZeroZeroClr( hDC, aBitmap[ 1 ] ), ) ;
            SetBkColor( hDC, nRGB( 255, 255, 255 ) )


            TransBmp( aBitmap[ 1 ], aBitmap[ 3 ], aBitmap[ 4 ], aBitmap[ 5 ], hDC, nBmpCol, nBmpRow, nBmpWidth( aBitmap[ 1 ] ), nBmpHeight( aBitmap[ 1 ] ) )
         endif
      endif
   endif

   if Empty( cFooter )
      ::oBrw:ReleaseDC()
      return nil
   endif

   oFont:Activate( hDC )
   SetTextColor( hDC, aColors[ 1 ] )
   SetBkColor( hDC, aColors[ 2 ] )
   SetBkMode ( hDC, 1 )


   DrawTextEx( hDC, cFooter, {nRow, nCol, nRow + nHeight, nCol + nWidth}, ::nFootStyle )
   oFont:Deactivate( hDC )

   ::oBrw:ReleaseDC()

return nil



UTILITY STATIC function TXBrwColumn_RefreshFooter() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   if ! Empty( ::oBrw:nFooterHeight ) .AND. ::IsVisible()
      ::PaintFooter(::oBrw:FooterRow()+1,nil,::oBrw:nFooterHeight-4)
   endif

return nil



UTILITY STATIC function TXBrwColumn_DataCol() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nCol  := ::nDisplayCol
   local aBitmap

   if ::bIndent <> nil
      nCol     += IfNil( Eval( ::bIndent, Self ), 0 )
   endif
   if ::nDataBmpAlign == 0 .AND. ::bBmpData <> nil
      aBitmap  := ::aBitmap( Eval( ::bBmpData ) )
      if !Empty( aBitmap )
         nCol  += aBitmap[ 3 ] + 5
      endif
   endif

return nCol




UTILITY STATIC function TXBrwColumn_SetColsAsRows( ...) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn



   local aCols := HB_AParams()

   if ! Empty( aCols )
      if ValType( aCols[ 1 ] ) == "A"
         aCols    := aCols[ 1 ]
      endif
      ::aRows     := {}
      AEval( aCols, { |u| AAdd( ::aRows, ::oBrw:oCol( u ) ) } )
      AEval( ::aRows, { |o| o:lHide := .T. }, 2 )
      WITH OBJECT ATail( ::aRows )
         :nDataStyle := :DefStyle( :nDataStrAlign, .F. )
      END
   endif

return Self



UTILITY STATIC function TXBrwColumn_PaintData( nRow, nCol, nHeight, lHighLite, lSelected, nOrder, nPaintRow) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local oCol, n, nDataHeight

   if nCol <> nil
      ::nDisplayCol := nCol
   else
      nCol := ::nDisplayCol
   endif

   nDataHeight    := If( Empty( ::aRows ), nHeight, ::nDataHeight )
   ::PaintCell( nRow, nCol, nDataHeight, lHighLite, lSelected, nOrder, nPaintRow )

   if ! Empty( ::aRows )
      for n := 2 to Len( ::aRows )
         nHeight        -= nDataHeight
         nRow           += nDataHeight
         oCol           := ::aRows[ n ]
         nDataHeight    := If( n == Len( ::aRows ), nHeight, oCol:nDataHeight )
         oCol:PaintCell( nRow, nCol, nDataHeight, lHighLite, lSelected, nOrder, nPaintRow )
      next

   endif

return nil



UTILITY STATIC function TXBrwColumn_PaintCell( nRow, nCol, nHeight, lHighLite, lSelected, nOrder, nPaintRow) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local hDC, oBrush, hBrush, nOldColor, hBmp
   local oBrush1, oBrush2, hBrush1, hBrush2, aColor2, nWidth1
   local oFont
   local aColors, aBitmap, aBmpPal
   local cData, nTxtHeight, aRect

   local nWidth, nTop, nBottom, nBmpRow, nBmpCol, nBmpNo, nButtonRow, nButtonCol,nBtnWidth, nRectWidth, nRectCol, nStyle, nType, nIndent, nBtnBmp, nFontHeight
   local lTransparent := .F.
   local lStretch     := .F.
   local lBrush       := .F.
   local cImagen, nBmpW, nBmpH



   IIF( lHighLite == nil, lHighLite := .F., ) ; IIF( lSelected == nil, lSelected := .F., ); IIF( nOrder == nil, nOrder := 0, );

   nBtnBmp := 0

   if ( ::oEditGet <> nil .AND. nPaintRow == ::oBrw:nRowSel ) .OR. ::oEditLbx <> nil .OR. ::oBrw:nLen == 0
      return nil
   endif

   if nCol <> nil
      ::nDisplayCol := nCol
   else
      nCol := ::nDisplayCol
   endif

   if ::bStrData <> nil
      cData := Eval( ::bStrData )
      if ValType( cData ) <> "C"
         cData := cValToChar( cData )
      endif
      if ! Empty( ::nDataStrAlign )
         cData := AllTrim( cData )
      endif
      if isrtf( cData )
         cData := "<RichText>"
      elseif isGtf( cData )
         cData := GtfToTxt( cData )
      endif
   else
      cData := ""
   endif

   if ::bBmpData <> nil
      nBmpNo := Eval( ::bBmpData, ::Value() )
   else
      nBmpNo := 0
   endif

   if lHighLite
      if ::oBrw:hWnd == GetFocus()
         if lSelected
            if nOrder == ::oBrw:nColSel
               aColors  := Eval( ::bClrSelFocus )
            else
               aColors := Eval( If( ::oBrw:bClrRowFocus <> nil, ::oBrw:bClrRowFocus, ::bClrSelFocus ) )
            endif
          else
            aColors := Eval( If( ::oBrw:bClrRowFocus <> nil, ::oBrw:bClrRowFocus, ::bClrSelFocus ) )
          endif
      else
         aColors := Eval( ::bClrSel )
      endif
   else
      aColors := Eval( ::bClrStd )
      lTransparent := ::oBrw:lTransparent
   endif

   hDC     := ::oBrw:GetDC()
   oFont   := ::oDataFont
   if ValType( oFont ) == "B"
      oFont = Eval( oFont, Self )
   endif
   nWidth  := ::nWidth

   if ::oBrush <> nil
      if ValType( ::oBrush ) == "B"
         oBrush   := Eval( ::oBrush, Self )
      else
         oBrush   := ::oBrush
      endif
   endif

   if oBrush <> nil
      hBrush      := oBrush:hBrush
      lBrush      := .T.
      lTransparent:= .F.
   elseif ! lTransparent .AND. !::lColTransparent
      hBrush  := CreateColorBrush( aColors[ 2 ] )
   elseif ::lColTransparent
         hBrush := CreateColorBrush( 0 )
         lTransparent := .T.
   endif

   nStyle  := ::oBrw:nColDividerStyle
   nType   := ::nEditType

   if nStyle == 0
      nRectWidth := nWidth + 2
      nRectCol   := nCol
   elseif nStyle < 5 .AND. nOrder > 1
      nRectWidth := nWidth + 1
      nRectCol   := nCol - 1
   else
      nRectWidth := nWidth
      nRectCol   := nCol
   endif

   nBottom  := nRow + nHeight
   if ! lTransparent
      nTop        := nRow
      if ::lMergeVert .AND. lHighLite .AND. lSelected .AND. nOrder == ::oBrw:nColSel
         ::MergeArea( @nTop, @nBottom, nPaintRow )
      endif
      if ValType( aColors[ 2 ] ) == "A"
         GradientFill( hDC, nTop, nRectCol, nBottom-1, Min( nRectCol + nRectWidth, ::oBrw:BrwWidth() ), aColors[ 2 ], .T. )
      else
         FillRect( hDC, { nTop, nRectCol, nBottom, Min( nRectCol + nRectWidth, ::oBrw:BrwWidth() ) }, hBrush )
      endif
   endif

   if ::bIndent <> nil
      nIndent  := Eval( ::bIndent, Self )
      if ! Empty( nIndent )
         nCol   += nIndent
         nWidth -= nIndent
      endif
   endif

   nCol    += ( 6 / 2 )
   nWidth  -=  6
   nRow    += ( 4 / 2 )
   nHeight -=  4







   if nType > 1
      if ! Empty( aBitmap := ::aBitmap( ::nBtnBmp ) )
         nBtnWidth      := aBitMap[ 3 ] + 1
         aBitmap        := nil
      else
         nBtnWidth      :=    10
      endif
      nButtonRow := nRow
      nButtonCol := nCol + nWidth - nBtnWidth
      nWidth -= ( nBtnWidth + 5 )
   else
      if ::lWillShowABtn
         nWidth -= 15
      endif
   endif

   if ::lProgBar
      aColor2  := Eval( ::bClrProg )
      hBrush1  := CreateColorBrush( aColor2[ 1 ] )
      hBrush2  := CreateColorBrush( aColor2[ 2 ] )


      nWidth1  := Min( ::Value() * nWidth /  Max( 1, If( ValType( ::nProgTot ) == "B", Eval( ::nProgTot, Self ), ::nProgTot ) ),  nWidth )

      FillRect( hDC, { nRow, nCol, nRow + nHeight, Min( nCol + nWidth1, ::oBrw:BrwWidth() - 4 ) }, hBrush1 )

      if nCol + nWidth1 < ::oBrw:BrwWidth() - 4

         FillRect( hDC, { nRow, nCol + nWidth1 + 1, nRow + nHeight,  Min( nCol + nWidth, ::oBrw:BrwWidth() - 4 ) }, hBrush2 )
      endif
      DeleteObject( hBrush1 )
      DeleteObject( hBrush2 )

   endif

   if !Empty( aBitmap := ::aBitmap( nBmpNo ) )
      nWidth  -= aBitmap[ 3 ]
      if ::bStrData == nil .OR. ::nDataBmpAlign == 2
         nBmpCol  := Max( 0, nCol + nWidth / 2 )
         lStretch := ::lBmpStretch

      elseif ::nDataBmpAlign == 0
         nBmpCol := nCol
         nCol    += aBitmap[ 3 ] + 5
      else
         nBmpCol := nCol + nWidth
      endif
      nWidth  -= 5
      nBmpRow := nRow + ( ( nHeight - aBitmap[ 4 ] ) / 2 )

      if ::lMergeVert
         nTop     := nRow
         nBottom  := nRow + nHeight - 1
         ::MergeArea( @nTop, @nBottom, nPaintRow )
         nBmpRow := nTop + ( ( ( nBottom - nTop + 1 ) - aBitmap[ 4 ] ) / 2 )
      endif

 aBitmap[ 5 ] := GetZeroZeroClr( hDC, aBitmap[ 1 ] )

      if lStretch

         if SetAlpha() .AND. aBitmap[ 6 ]
            hBmp := ResizeImg( aBitmap[ 1 ], Min( nRectWidth,::oBrw:BrwWidth() - nRectCol - 4 ), nBottom - nRow )
            ABPaint( hDC, nRectCol, nRow, hBmp, ::nAlphaLevel() )
         else
            nOldColor  := SetBkColor( hDC, nRGB( 255, 255, 255 ) )


            TransBmp( aBitmap[ 1 ], aBitmap[ 3 ], aBitmap[ 4 ], aBitmap[ 5 ], hDC, nRectCol, nRow, Min( nRectWidth,::oBrw:BrwWidth() - nRectCol - 4 ),  nBottom - nRow )
            SetBkColor( hDC, nOldcolor )
         endif

      else
         if SetAlpha() .AND. aBitmap[ 6 ]
            ABPaint( hDC, nBmpCol, nBmpRow,aBitmap[ 1 ], ::nAlphaLevel() )
         else
            if ::oBrw:lTransparent .OR. ValType( aColors[ 2 ] ) == "A"
                nOldColor := SetBkColor( hDC, nRGB( 255, 255, 255 ) )



                TransBmp( aBitmap[ 1 ], aBitmap[ 3 ], aBitmap[ 4 ], aBitmap[ 5 ], hDC, nBmpCol, nBmpRow, aBitmap[ 3 ],  aBitmap[ 4 ] )

                SetBkColor( hDC, nOldColor )
             else





                PalBmpDraw( hDC, nBmpRow, nBmpCol, aBitmap[ 1 ], aBitmap[ 2 ], aBitmap[ 3 ], aBitmap[ 4 ] ,, ::lBmpTransparent, aColors[ 2 ] )

            endif
         endif
      endif
   endif

   if ! Empty( cData ) .AND. IsBinaryData( cData )
      if IfNil( FITypeFromMemory( cData ), -1 ) >= 0
         cImagen  := cData
         cData    := ""
      else
         cData    := "<binary>"
      endif
   endif

   if ! Empty( cImagen ) .OR. ::cDataType $ "FP"
      if ! Empty( cImagen )
         hBmp     := FILoadFromMemory( cImagen )
      else
         if ::bStrImage == NIL
            cImagen := ::Value()
         else
            cImagen := Eval( ::bStrImage, Self, ::oBrw )
         endif
         if ::cDataType == "F" .AND. File( cImagen )
            hBmp     := FILoadImg( cImagen )
         else
            hBmp     := FILoadFromMemory( IfNil( cImagen, "" ) )
         endif
      endif

      aBmpPal     := { hBmp, 0 }
      if aBmpPal[ 1 ] == 0
         aBmpPal := PalBmpLoad( cImagen )
      endif

      if aBmpPal[ 1 ] <> 0
         Aadd(aBmpPal, nBmpWidth( aBmpPal[ 1 ] ) )
         Aadd(aBmpPal, nBmpHeight( aBmpPal[ 1 ] ) )
         Aadd(aBmpPal, if ( ::lBmpTransparent, GetZeroZeroClr( hDC, aBmpPal[ 1 ] ),0) )
         Aadd(aBmpPal, HasAlpha( aBmpPal[ 1 ] ) )

         if ::lBmpStretch
            nBmpW       := nWidth - 2
            nBmpH       := nBottom - nRow - 2
            nBmpCol     := nCol + 1
            nBmpRow     := nRow + 1
         else
            nBmpW       := aBmpPal[ 3 ]
            nBmpH       := aBmpPal[ 4 ]
            if nBmpW > ( nWidth - 4 )
               nBmpH    *= ( ( nWidth - 4 ) / nBmpW )
               nBmpW    := nWidth - 4
            endif
            if nBmpH > ( nBottom - nRow - 4 )
               nBmpW    *= ( ( nBottom - nRow - 4 ) / nBmpH )
               nBmpH    := ( nBottom - nRow ) - 4
            endif
            nBmpRow     := nRow + ( nHeight - nBmpH ) / 2 + 2
            nBmpCol     := nCol + 2

            if ::nDataBmpAlign == 2
               nBmpCol  := nCol + ( nWidth - nBmpW ) / 2
            elseif ::nDataBmpAlign == 1
               nBmpCol  := nCol + nWidth - nBmpW
            endif

         endif

         if SetAlpha() .AND. aBmpPal[ 6 ]

            hBmp := ResizeImg( aBmpPal[ 1 ], nBmpW, nBmpH )
            ABPaint( hDC, nBmpCol, nBmpRow, hBmp, ::nAlphaLevel() )
            DeleteObject( hBmp )

         elseif ::lBmpTransparent

            nOldColor := SetBkColor( hDC, nRGB( 255, 255, 255 ) )

            TransBmp( aBmpPal[ 1 ], aBmpPal[ 3 ], aBmpPal[ 4 ], aBmpPal[ 5 ], hDC, nBmpCol, nBmpRow, nBmpW, nBmpH )
            SetBkColor( hDC, nOldColor )

         else

            if nBmpW <> aBmpPal[ 3 ] .OR. nBmpH <> aBmpPal[ 4 ]
               hBmp := ResizeImg( aBmpPal[ 1 ], nBmpW, nBmpH )
               DrawBitmap( hDC, hBmp, nBmpRow, nBmpCol )
               DeleteObject( hBmp )
            else
               DrawBitmap( hDC, aBmpPal[ 1 ], nBmpRow, nBmpCol )
            endif

         endif

      endif

   endif

   if ! Empty( cData ) .AND. ! ( ::cDataType $ "PF" )
      oFont:Activate( hDC )
      nFontHeight := GetTextHeight( ::oBrw:hWnd, hDC )
      if ::oBrw:lTransparent .AND. ::oBrw:lContrastClr


         SetTextColor( hDC, ContrastColor( hDC, nCol, nRow,  Min( nWidth, ::oBrw:BrwWidth() - nCol ),  nHeight, aColors[ 1 ] ) )
      else
         SetTextColor( hDC, aColors[ 1 ] )
      endif
      if lTransparent .OR. lBrush .OR. ::lProgBar .OR. ValType( aColors[ 2 ] ) == "A"
         SetBkMode( hDC, 1 )
      else
         nOldColor := SetBkColor( hDC, aColors[ 2 ] )
      endif

      nTop     := nRow
      nBottom  := nRow + nHeight

      if ::lMergeVert
         ::MergeArea( @nTop, @nBottom, nPaintRow )
      endif

      aRect       := { nTop, nCol, nBottom, Min( nCol + nWidth, ::oBrw:BrwWidth() - 5 ) }
      if ::bPaintText == nil

         nStyle      := ::nDataStyle


         if ::oBrw:nDataType == 2 .AND.  ::nDataStrAlign == 0 .AND.  ValType( ::Value ) $ "ND"

            nStyle   := ::DefStyle( 1, .T. )
         endif












         if ::cDataType <> nil .AND. ::cDataType $ "CM" .AND. lAnd( nStyle, 0x00000020 ) .AND.  ::oBrw:nRowHeight > 2 * nFontHeight + 2

            cData    := Trim( cData )

            if ( nTxtHeight := DrawTextEx( hDC, cData, aRect, nOr( 0x00000400, 0x00000010 ) ) ) >  DrawTextEx( hDC, cData, aRect, nOr( 0x00000400, 0x00000020 ) )

               nStyle      := nOr( nAnd( nStyle, nNot( 0x00000020 ) ), 0x00000010 )
               aRect[ 1 ]  += Max( 0, Int( ( nHeight - nTxtHeight ) / 2 ) )

               if ::nDataLines == nil .AND. ::cDataType == "M"
                  ::nDataLines   := 2
               endif

            endif
         endif

         DrawTextEx( hDC, cData, aRect, nStyle )
      else
         Eval( ::bPaintText, Self, hDC, cData, aRect, aColors, lHighLite )
      endif
      if nOldColor <> nil
         SetBkcolor( hDC, nOldColor )
         nOldColor := nil
      endif
      oFont:Deactivate( hDC )
   else
      aRect       := { nRow, nCol, nRow + nHeight, Min( nCol + nWidth, ::oBrw:BrwWidth() - 5 ) }
      if ::bPaintText <> nil
         Eval( ::bPaintText, Self, hDC, "", aRect, aColors, lHighLite )
      endif
   endif

   if nType > 1 .AND. nType < 6
      if lSelected
         if !::lBtnTransparent

               WndBoxRaised(hDC, nButtonRow -1 , nButtonCol - 1, nButtonRow + nHeight, nButtonCol + nBtnWidth + 1 )
         endif

         if nType == 2 .OR. nType == 4
           ::oBtnElip:Hide()
           ::oBtnList:Move( nButtonRow, nButtonCol, nBtnWidth + 1, nHeight, .F.)
           ::oBtnList:Show()
           ::oBtnList:GetDC()
           if ::lBtnTransparent
              ::oBtnList:SetColor( aColors[ 1 ],aColors[ 2 ] )
           else

              FillRect( hDC, {nButtonRow, nButtonCol, nButtonRow + nHeight , nButtonCol + nBtnWidth + 1 } , ::oBtnList:oBrush:hBrush  )
           endif
           ::oBtnList:Paint()
           ::oBtnList:ReleaseDC()
         else
            ::oBtnList:Hide()
            ::oBtnElip:Move( nButtonRow, nButtonCol, nBtnWidth + 1, nHeight, .F.)
            ::oBtnElip:Show()
            ::oBtnElip:GetDC()
           if ::lBtnTransparent
              ::oBtnElip:SetColor( aColors[ 1 ],aColors[ 2 ] )
           else

              FillRect( hDC, {nButtonRow, nButtonCol, nButtonRow + nHeight , nButtonCol + nBtnWidth + 1 }, ::oBtnElip:oBrush:hBrush )
           endif
            ::oBtnElip:Paint()
            ::oBtnElip:ReleaseDC()
         endif
      endif
   endif

   if hBrush <> nil .AND. ! lBrush
      DeleteObject( hBrush )
   endif
   if aBmpPal <> nil
      DeleteObject( aBmpPal[ 1 ]  )
   endif
   ::oBrw:ReleaseDC()

return nil



UTILITY STATIC function TXBrwColumn_EraseData( nRow, nCol, nHeight, hBrush, lFixHeight) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local hDC
   local aColors
   local nWidth
   local lCreated

   IIF( lFixHeight == nil, lFixHeight := .F., ) ;

   lCreated := .F.

   if nCol <> nil
      ::nDisplayCol := nCol
   else
      nCol := ::nDisplayCol
   endif

   if hBrush == nil
      aColors  := Eval( ::bClrStd )
      hBrush   := CreateColorBrush( aColors[ 2 ] )
      lCreated := .T.
   endif

   hDC     := ::oBrw:GetDC()
   nWidth  := ::nWidth

   if ::oBrw:nColDividerStyle < 5
      nCol--
      nWidth++
   endif

   if ::oBrw:nColDividerStyle == 0
      nWidth += 2
   endif

   if !lFixHeight .AND. ::oBrw:nRowDividerStyle > 0
      nHeight --
   endif

   if !lFixHeight .AND. ::oBrw:nRowDividerStyle >= 5
      nHeight --
   endif

   FillRect( hDC, {nRow, nCol, nRow + nHeight, nCol + nWidth}, hBrush )

   if lCreated
      DeleteObject( hBrush )
   endif

return nil



UTILITY STATIC function TXBrwColumn_Box( nRow, nCol, nHeight, nType) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local hDC
   local nWidth

   IIF( nType == nil, nType := 1, ) ;

   if nCol <> nil
      ::nDisplayCol := nCol
   else
      nCol := ::nDisplayCol
   endif

   hDC     := ::oBrw:GetDC()
   nWidth  := ::nWidth

   if ::nPos > 1 .AND. ::oBrw:nColDividerStyle < 5
      nCol--
      nWidth++
   endif

   do case
   case nType == 1
      DrawFocusRect( hDC, nRow, nCol, nRow + nHeight - 1, nCol + nWidth - 1 )
   case nType == 2
      WndBox( hDC, nRow, nCol, nRow + nHeight - 1, nCol + nWidth - 1 )
   case nType == 3
      WndBoxRaised( hDC, nRow, nCol, nRow + nHeight - 1, nCol + nWidth - 1 )
   endcase

return nil



UTILITY STATIC function TXBrwColumn_DefStyle( nAlign, lSingleLine) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nStyle

   nStyle := nOr( 0x00010000, 0x00002000, 0x00000800 )

   do case
   case nAlign == 0
      nStyle  := nOr( nStyle, 0x00000000 )
   case nAlign == 1
      nStyle  := nOr( nStyle, 0x00000002 )
   case nAlign == 2
      nStyle  := nOr( nStyle, 0x00000001 )
   end

   if lSingleLine
      nStyle := nOr( nStyle, 0x00000020, 0x00000004)
   else
      nStyle := nOr( nStyle, 0x00000010)
   endif

return nStyle



UTILITY STATIC function TXBrwColumn_HeaderLButtonDown( nMRow, nMCol, nFlags) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn



   if ::oBrw:nCaptured == 0 .AND.  ( ::oBrw:lAllowColSwapping .OR. ! Empty( ::cSortOrder ) .OR.  ::bLClickHeader <> nil )

      ::oBrw:oCapCol   := Self
      ::oBrw:nCaptured := 1
      ::oBrw:Capture()
      ::PaintHeader( 2, nil, ::oBrw:nHeaderHeight - 3, .T. )
   endif

return nil



UTILITY STATIC function TXBrwColumn_HeaderLButtonUp( nMRow, nMCol, nFlags) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local oCol
   local nCol
   local lDragged

   lDragged := .F.

   if ::oDragWnd <> nil
      ::oDragWnd:End()
      ::oDragWnd := nil
      lDragged := .T.
   endif

   ::PaintHeader( 2, nil, ::oBrw:nHeaderHeight - 3 )

   if !lDragged


      if nMRow <= ::oBrw:nHeaderHeight   .AND. nMCol <= ( ::nWidth + ::nDisplayCol )

         if ::SetOrder()
            ::oBrw:Refresh()
            ::oBrw:oWnd:Update()
         else
            ::PaintHeader( 2, nil, ::oBrw:nHeaderHeight - 3 )
         endif

         if ::bLClickHeader <> nil
            Eval( ::bLClickHeader, nMRow, nMCol, nFlags, Self )
            ::PaintHeader( 2, nil, ::oBrw:nHeaderHeight - 3 )
         endif

      endif

   else

      nCol := ::oBrw:MouseColPos( nMCol )
      if nCol > 0
         oCol := ::oBrw:ColAtPos( nCol )
         if oCol:nCreationOrder <> ::nCreationOrder

            ::oBrw:MoveCol( Self, oCol, .T., .T. )
         endif
      endif

   endif

return nil



UTILITY STATIC function TXBrwColumn_FooterLButtonDown( nMRow, nMCol, nFlags) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   if ::oBrw:nCaptured == 0 .AND. ::blClickFooter <> nil
      ::oBrw:oCapCol   := Self
      ::oBrw:nCaptured := 2
      ::oBrw:Capture()
      ::PaintFooter( ::oBrw:FooterRow()+ 1 , nil, ::oBrw:nFooterHeight - 4, .T. )
   endif

return nil



UTILITY STATIC function TXBrwColumn_FooterLButtonUp( nMRow, nMCol, nFlags) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   ::PaintFooter( ::oBrw:FooterRow()+ 1 , nil, ::oBrw:nFooterHeight - 4)





   if ::bLClickFooter <> nil .AND.  nMRow >= ::oBrw:FooterRow() .AND.  nMRow <= ( ::oBrw:FooterRow() + ::oBrw:nFooterHeight - 3 ) .AND.  nMCol >= ::nDisplayCol .AND.  nMCol <= ( ::nWidth + ::nDisplayCol )
      Eval( ::bLClickFooter, nMRow, nMCol, nFlags, Self )
   endif

return nil



UTILITY STATIC function TXBrwColumn_ResizeBeg( nMRow, nMCol, nFlags) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nCol, nWidth

   if ::oBrw:nCaptured == 0
      ::oBrw:oCapCol   := Self
      ::oBrw:nCaptured := 3
      ::oBrw:Capture()
      nCol   := ::nDisplayCol + ::nWidth
      nWidth := nCol + iif( ::oBrw:nColDividerStyle >= 5, 3, 1)
      ::nResizeCol := nCol
      InvertRect( ::oBrw:GetDC(), { 0, nCol - 1 , ::oBrw:BrwHeight(),  nWidth + 1} )
      ::oBrw:ReleaseDC()
   endif

return nil



UTILITY STATIC function TXBrwColumn_ResizeEnd( nMRow, nMCol, nFlags) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nWidth

   if ::nResizeCol <> nil
      nWidth := ::nResizeCol + iif( ::oBrw:nColDividerStyle >= 5, 3, 1)
      InvertRect( ::oBrw:GetDC(), { 0, ::nResizeCol - 1, ::oBrw:BrwHeight(),  nWidth + 1 } )
      ::oBrw:ReleaseDC()
      if Abs( nMCol - ::nDisplayCol - ::nWidth ) > 2
         ::nWidth := Max( nMCol - ::nDisplayCol, 10 )
         ::oBrw:ColStretch()
         ::oBrw:Refresh()
      endif
      ::nResizeCol := nil
   endif

return nil



UTILITY STATIC function TXBrwColumn_MouseMove( nMRow, nMCol, nFlags) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nRow, nCol, nWidth
   local hDC

   do case
   case ::oBrw:nCaptured == 1



      if ::oDragWnd == nil .AND.  nMRow <= ::oBrw:nHeaderHeight  .AND.  nMCol <= ( ::nWidth + ::nDisplayCol ) .AND.  nMCol >= ::nDisplayCol
         return nil
      endif

      if !::oBrw:lAllowColSwapping
         return nil
      endif

      nRow := 0
      nCol := nMCol - ( ::nWidth / 2 )

      if ::oDragWnd == nil
         ::PaintHeader( 2, nil, ::oBrw:nHeaderHeight - 3 )
         ::oDragWnd := TWindow():New(,,,,, 1073741824,,,, ::oBrw,,,,,,, !.F., !.F., !.F., !.F., .F. )

         ::oDragWnd:bPainted := {| hDC | ::PaintHeader( 0, 0, ::oBrw:nHeaderHeight, .T., hDC ), WndRaised( ::oDragWnd:hWnd, hDC ) }
         ::oDragWnd:Move(nRow, nCol, ::nWidth, ::oBrw:nHeaderHeight)
         ::oDragWnd:Activate(, ::oDragWnd:bLClicked, ::oDragWnd:bRClicked, ::oDragWnd:bMoved, ::oDragWnd:bResized, ::oDragWnd:bPainted, ::oDragWnd:bKeyDown, ::oDragWnd:bInit,,,,,,,,,,, ::oDragWnd:bLButtonUp )
      else
         ::oDragWnd:Move(nRow, nCol, ::nWidth, ::oBrw:nHeaderHeight, .T.)
      endif

   case ::oBrw:nCaptured == 3
      CursorWE()
      if nMCol > ( ::nDisplayCol + 10 ) .AND. nMCol < ( ::oBrw:BrwWidth() - 10 )
         hDC    := ::oBrw:GetDC()
         nWidth := iif( ::oBrw:nColDividerStyle >= 5, 3, 1)
         if ::nResizeCol <> nil
            InvertRect( hDC, { 0, ::nResizeCol - 1 , ::oBrw:BrwHeight(),  ::nResizeCol + nWidth + 1 } )
         endif
         ::nResizeCol := nMCol
         InvertRect( hDC, { 0, nMCol - 1, ::oBrw:BrwHeight(),  nMCol + nWidth + 1} )
         ::oBrw:ReleaseDC()
      endif

   endcase

return nil



UTILITY STATIC function TXBrwColumn_CreateButtons() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local aColors

    if ::oBtnList <> nil .AND. ::oBtnElip <> nil
        ::oBtnList:Hide()
        ::oBtnElip:Hide()
        return nil
    endif

   if ::oBrw:lCreated

      aColors := Eval( ::bClrHeader )

      if ::oBtnList <> nil
         ::oBtnList:End()
      endif
      if ::oBtnElip <> nil
         ::oBtnElip:End()
      endif

      ::oBtnList := TBtnBmp():New( 0, 0, 0, 0, "",,,,, ::oBrw,,, .F., .F.,,,,, !.T.,, .F.,,, .F.,, !.F.,, .F., .F. )
      ::oBtnList:hBitmap1 := FwDArrow()
      ::oBtnList:bAction := { || ::ShowBtnList() }
      ::oBtnList:SetFont( If( ValType( ::oDataFont ) == "B", Eval( ::oDataFont, Self ), ::oDataFont ) )
      ::oBtnList:SetColor( aColors[ 1 ], aColors[ 2 ] )

      ::oBtnElip := TBtnBmp():New( 0, 0, 0, 0,,,,,, ::oBrw,,, .F., .F.,,,,, !.T.,, .F.,,, .F.,, !.F.,, .F., .F. )
      ::oBtnElip:cCaption := "..."
      ::oBtnElip:bAction := {|| ::RunBtnAction() }
      ::oBtnElip:SetFont( If( ValType( ::oDataFont ) == "B", Eval( ::oDataFont, Self ), ::oDataFont ) )
      ::oBtnElip:SetColor( aColors[ 1 ], aColors[ 2 ] )

         if ::nBtnBmp > 0 .AND. !empty( ::aBitMaps )
            if ::nBtnBmp > len( ::aBitMaps )
               ::nBtnBmp := len( ::aBitMaps )
            endif
               ::ChangeBitMap( )
         endif

      ::oBtnList:Hide()
      ::oBtnElip:Hide()

   endif

return nil



UTILITY STATIC function TXBrwColumn_ChangeBitmap() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   if ::nBtnBmp > 0 .AND. len( ::aBitmaps ) >= ::nBtnBmp
      ::oBtnElip:hBitmap1 := ::aBitMaps[::nBtnBmp, 1 ]
      ::oBtnList:hBitmap1 := ::aBitMaps[::nBtnBmp, 1 ]
      ::oBtnElip:cCaption := ""
  else
   ::oBtnElip:hBitmap1 := 0
      ::oBtnList:hBitmap1 := 0
      ::oBtnElip:cCaption := "..."
  endif

  ::oBrw:refresh()

return nil



UTILITY STATIC function TXBrwColumn_nEditType(nType) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   if nType <> nil
      ::hEditType := ntype
      ::CreateButtons()
   endif

return ::hEditType



UTILITY STATIC function TXBrwColumn_isEditKey( cKey) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local lEditKey := .F.
   local cDataType

   if ValType( cKey ) == "N"
      cKey     := Upper( Chr( cKey ) )
   endif

   if ::cEditKeys <> nil
      if cKey $ ::cEditKeys
         lEditKey := .T.
      endif
   else
      cDataType      := ::cDataType
      if cDataType == nil
         cDataType   := ValType( ::Value )
      endif
      if cDataType == "N"
         if IsDigit( cKey ) .OR. cKey == "-" .OR. cKey == "." .OR. ( cKey == "=" .AND. ::oBrw:lFormulaEdit )
            lEditKey := .T.
         endif
      elseif cDataType $ "DT"
         lEditKey := IsDigit( cKey )
      else
         if IsAlpha( cKey ) .OR. IsDigit( cKey )
            lEditKey := .T.
         endif
      endif
   endif

return lEditKey



UTILITY STATIC function TXBrwColumn_Edit( nKey) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local aColors
   local uValue, cPic
   local nRow, nCol, nWidth, nHeight, nBtnWidth
   local hBrush
   local lCenter, lRight
   local oFont

   if ::cDataType <> nil .AND. ::cDataType $ "FP"
      return nil
   endif

   if ValType ( ::oEditFont ) == "B"
         oFont = Eval( ::oEditFont, Self )
    else
         oFont = ::oEditFont
   endif

   nBtnWidth := 10

   if ::bOnPostEdit == nil

      MsgStop( "oCol:bOnPostEdit not defined", "Fivewin: Class TXBrwColumn" )
      return .F.
   endif

   if ::nEditType == 2
      return ::ShowBtnList( nKey )
    endif

    if ::nEditType == 3
        return ::RunBtnAction( nKey )
    endif

    if ::oEditGet <> nil
        ::oEditGet:End()
    endif





   cPic    := ::cEditPicture
   IIF( cPic == nil, cPic := "", ) ;

   uValue  := IfNil( ::Value, ::BlankValue() )
   if ValType( uValue ) == "D"
      if !Empty( cPic ) .AND. Left( cPic, 1 ) <> "@"
         cPic  := "@D"
      endif
      if cPic == "@T"
         cPic  := "@D"
      endif

   endif

   if ::nEditType >= 6
      return ::EditDateTime( nKey )
   endif

   aColors := Eval( ::bClrEdit )
   lCenter := ( ::nDataStrAlign == 2 )
   lRight  := ( ::nDataStrAlign == 1 )

   nRow    := ( ( ::oBrw:nRowSel - 1 ) * ::oBrw:nRowHeight ) + ::oBrw:HeaderHeight()

   hBrush := CreateColorBrush( aColors[ 2 ] )
   ::EraseData( nRow, ::nDisplayCol, ::oBrw:nRowHeight  , hBrush )
   DeleteObject( hBrush )


   if ValType( uValue ) == "C" .AND. IfNil( ::nDataLines, ::oBrw:nDataLines ) > 1 .AND.  Empty( cPic )

      if isRtf( uValue ) .OR. isGtf( uValue )
         return nil
      else


         ::oEditGet := TMultiGet():New( 0,0,{ | u | If(PCount()==0,uValue,uValue:= u ) }, ::oBrw,0,0,oFont,.F.,aColors[ 1 ],aColors[ 2 ] ,,.F.,,.F.,,lCenter,lRight,.F.,,,.F.,.T.,.F. )
      endif
   else

      if ValType( uValue ) $ "AHO"
         XBrowse( uValue, ::cHeader, nil, nil, nil, nil, nil, .T. )
         return .F.
      else
         if nKey == Asc( "=" )
            uValue   := Space( 128 )
            cPic     := "@KS" + LTrim( Str( ::nWidthChr() ) )
         endif



         ::oEditGet := TGet():New( 0,0,{ | u | If(PCount()==0,uValue,uValue:= u ) }, ::oBrw,0,0,cPic,,aColors[ 1 ],aColors[ 2 ] ,oFont,.F.,,.F.,,.F.,,lCenter,lRight,,.F.,.F.,.T.,,.F.,,,,)
      endif
   endif

   nRow    := ( ( ::oBrw:nRowSel - 1  ) * ::oBrw:nRowHeight ) + ::oBrw:HeaderHeight() + 2

   nCol     := ::DataCol()

   if ::nBtnBmp > 0 .AND. len( ::aBitmaps ) >= ::nBtnBmp
      nBtnWidth      :=    ::aBitMaps[ ::nBtnBmp, 3 ]
   else
      nBtnWidth      :=    4
   endif

   nWidth  := ::nWidth - nBtnWidth

   nHeight := ::oBrw:nRowHeight - 4

   if ::nEditType > 2
      nWidth -= 13
   endif

   if nKey == Asc( "=" )
     ::oEditGet:bValid  := <  | oGet |
                              local lValid, cBuf

                              oGet:lValidating := .T.
                              cBuf        := SubStr( oGet:VarGet(), 2 )
                              lValid      := Type( StrTran( cBuf, "%", "/100" ) ) == "N"
                              if lValid
                                 oGet:VarPut( &( StrTran( cBuf, "%", "/100" ) ) )
                                 if ::bEditValid <> nil
                                    if ! ( lValid := Eval( ::bEditValid, oGet, Self ) )
                                       oGet:VarPut( "=" + cBuf )
                                    endif
                                 endif
                              endif
                              if lValid
                                 oGet:bValid := nil
                              else
                                 oGet:SetFocus()
                              endif
                              oGet:lValidating := .F.
                              return lValid
                              >
   else

   if ::bEditValid <> nil









      ::oEditGet:bValid := { | oGet, lRet | oGet:lValidating := .T.,  lRet := Eval( ::bEditValid, oGet, Self ), oGet:lValidating := .F.,  If( lRet, oGet:bValid := nil, oGet:SetFocus() ), lRet }

   endif

   endif

   ::oEditGet:bKeyDown   := { | nKey | EditGetkeyDown( Self, nKey ) }

   ::oEditGet:bLostFocus := { | oGet, hWndFocus | EditGetLostFocus( oGet, hWndFocus, ::oBrw, ::oEditGet, Self ) }

   if ::bGetChange <> nil
      ::oEditGet:bChange   := { | k, f, o | ::oBrw:nLastKey := k, Eval( ::bGetChange, k, f, o, Self ) }
   else
      ::oEditGet:bChange    := { | k, f, o | ::oBrw:nLastKey := k, .T. }
   endif

   ::oEditGet:nLastKey := 0

   ::oEditGet:Move( nRow, nCol, nWidth, nHeight, .T. )
   ::oEditGet:SetFocus()
   ::oEditGet:SelectAll()

   ::oBrw:lEditMode := .T.

   if ::oBtnElip <> nil
      ::oBtnElip:Refresh()
   endif

   if ::oBtnList <> nil
      ::oBtnList:Refresh()
   endif

    if ::lEditBorder
      WndBoxIn( ::oBrw:GetDC(), nRow-1, nCol-1, nRow + nHeight + 1, nCol + nWidth + 1)
       ::oBrw:ReleaseDC()
   endif

    if nKey <> nil
      PostMessage( ::oEditGet:hWnd, 258, nKey )
    endif

   ::oBrw:nLastEditCol := ::nPos

   if ::bOnPreEdit <> nil
      Eval( ::bOnPreEdit, Self )
   endif

return .T.



static function fnAddBitmap( o, uBmp )

   local nBmpNo := 0, aBmpPal, hBmp, oBrw

   if ValType( uBmp ) == "A"
      AEval( uBmp, { |u| nBmpNo := fnAddBitmap( o, u ) } )
      return nBmpNo
   endif

   if ValType( uBmp ) == "N" .AND. uBmp <> 0
      if IsGdiObject( uBmp )
         hBmp                     := uBmp
         aBmpPal                  := { hBmp, 0, 0, 0, nil, .F. }
      else
         aBmpPal := PalBmpLoad( uBmp )
      endif
   elseif ValType( uBmp ) == "C"
      uBmp     := AllTrim( uBmp )
      if Lower( Right( uBmp, 4 ) ) == ".bmp"
         if file( uBmp )
            oBrw     := If( o:IsKindOf( "TXBROWSE" ), o, o:oBrw )
            aBmpPal := PalBmpRead( oBrw:GetDC(), uBmp )
            oBrw:ReleaseDC()
         endif
      elseif !( "." $ uBmp )
         aBmpPal := PalBmpLoad( uBmp )
      endif
   endif

   if ! Empty( aBmpPal ) .AND. ( hBmp := aBmpPal[ 1 ] ) <> 0
      ASize( aBmpPal, 6 )
      aBmpPal[ 3  ] := nBmpWidth(  hBmp )
      aBmpPal[ 4 ] := nBmpHeight( hBmp )
      aBmpPal[ 6  ] := HasAlpha(   hBmp )
      AAdd( o:aBitmaps, aBmpPal )
      nBmpNo   := Len( o:aBitmaps )
   endif

return nBmpNo



static function EditGetLostFocus( oGet, hWndFocus, oBrw, oEditGet, oCol )

   local oWnd



   if ( oWnd := oWndFromHwnd( hWndFocus ) ) <> nil .AND. ! ( oWnd == oBrw ) .AND.  Upper( oWnd:ClassName() ) <> "TGET"
      oBrw:CancelEdit()
      SetFocus( hWndFocus )
      return nil
   endif


   if GetWindowThreadProcessId( hWndFocus ) <> GetWindowThreadProcessId( oBrw:hWnd )
      if !oCol:lAutoSave
         oBrw:CancelEdit()
      endif
      return nil
   endif

   if oEditGet <> nil .AND. !oEditGet:lValidating
      oCol:PostEdit()
   endif

return nil



static function EditGetkeyDown( Self, nKey )

   local lExit
   lExit := .F.

   do case
      case nKey == 27
           lExit := .T.
           ::oEditGet:bValid = nil

      case nKey == 13
           if Empty( ::cEditPicture ) .AND. ::oBrw:nDataLines > 1
              if ! GetKeyState( 17 )
                 lExit := .T.
              endif
           else
              lExit := .T.
           endif

      case nKey == 40 .OR. nKey == 38
           if !( Empty( ::cEditPicture ) .AND. ::oBrw:nDataLines > 1 )
              lExit := .T.
           endif



      case ::oBrw:lExitGetOnTypeOut .AND.  ( nKey == 32 .OR. ( nKey > 47 .AND. nKey < 96 ) ) .AND.  ::oEditGet:oGet:TypeOut .AND. !Set( 27 )

           lExit    := .T.
           ::oEditGet:nLastKey := 13
           ::oEditGet:End()
           ::PostEdit()
           if ::oBrw:lFastEdit
              PostMessage( ::oBrw:hWnd, 256, nKey )
           endif

           return nil

   endcase

   If lExit .AND. ::nEditType <> 6
      if ::oEditGet <> nil
         ::oEditGet:nLastKey := nKey
         ::oEditGet:End()
      endif
   else
      if lExit
         ::PostEdit()
      endif
   Endif

return nil



UTILITY STATIC function TXBrwColumn_EditDateTime( nKey) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn
local aColors
local lCenter, lRight
local nRow, nCol, nWidth, nHeight
local hBrush
local oFont
local uValue

   if ValType ( ::oEditFont ) == "B"
         oFont = Eval( ::oEditFont, Self )
    else
         oFont = ::oEditFont
   endif

   uValue  := ::Value

   aColors := Eval( ::bClrEdit )
   lCenter := ( ::nDataStrAlign == 2 )
   lRight  := ( ::nDataStrAlign == 1 )

   nRow    := ( ( ::oBrw:nRowSel - 1 ) * ::oBrw:nRowHeight ) + ::oBrw:HeaderHeight()

   hBrush := CreateColorBrush( aColors[ 2 ] )
   ::EraseData( nRow, ::nDisplayCol, ::oBrw:nRowHeight , hBrush )
   DeleteObject( hBrush )

   if ::nEditType == 6

      ::oEditGet := TDatePick():New( 0, 0, { | u | If(PCount()==0,uValue,uValue:= u ) }, ::oBrw, 0, 0, , aColors[ 1 ], aColors[ 2 ], oFont, .F., , , , .F., , , ::cEditPicture )
   else

      ::oEditGet := TTimePick():New( 0, 0, { | u | If(PCount()==0,uValue,uValue:= u ) }, ::oBrw, 0, 0, , aColors[ 1 ], aColors[ 2 ], oFont, .F., , , , .F., , , )
      ::oEditGet:SetTime( uValue )
   endif

   nRow    := ( ( ::oBrw:nRowSel - 1 ) * ::oBrw:nRowHeight ) + ::oBrw:HeaderHeight() + 2
   nCol    := ::nDisplayCol + 3

   nWidth  := ::nWidth - 4

   nHeight := ::oBrw:nRowHeight - 4

   if ::bEditValid <> nil
      ::oEditGet:bValid := { | oGet, lRet | oGet:lValidating := .T., lRet := Eval( ::bEditValid, oGet, Self ), oGet:lValidating := .F., If( ! lRet, oGet:SetFocus(),), lRet }
   endif

   ::oEditGet:bKeyDown   := { | nKey | EditGetkeyDown( Self, nKey ) }

   if ::nEditType <> 6
      ::oEditGet:bLostFocus := { | oGet, hWndFocus | EditGetLostFocus( oGet, hWndFocus, ::oBrw, ::oEditGet, Self ) }
   endif

   ::oEditGet:nLastKey := 0

   ::oEditGet:Move( nRow, nCol, nWidth, nHeight, .T. )
   ::oEditGet:SetFocus()
   ::oEditGet:SelectAll()

   ::oBrw:lEditMode := .T.

    if ::lEditBorder
      WndBoxIn( ::oBrw:GetDC(), nRow-1, nCol-1, nRow + nHeight + 1, nCol + nWidth + 1)
       ::oBrw:ReleaseDC()
   endif

    if nKey <> nil
      PostMessage( ::oEditGet:hWnd, 258, nKey )
    endif

   ::oBrw:nLastEditCol := ::nPos

RETURN .T.



UTILITY STATIC function TXBrwColumn_ShowBtnList( nKey) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local aBound
   local xValue
   local hBrush
   local nAt, nRow, nCol, nWidth, nHeight, aColors, oFont

   if ::aEditListTxt == nil
      MsgStop( "oCol:aEditListTxt not defined", "Fivewin: Class TXBrwColumn" )
      return .F.
   endif

   if ::bOnPostEdit == nil

      MsgStop( "oCol:bOnPostEdit not defined", "Fivewin: Class TXBrwColumn" )
      return .F.
   endif

   ::oBrw:nColSel := ::nPos

   if ::bEditValue == nil
      ::bEditValue := ::bStrData
   endif

   nAt     := Ascan( ::aEditListBound, Eval( ::bEditValue ) )
   nRow    := ( ::oBrw:nRowSel * ::oBrw:nRowHeight ) + ::oBrw:HeaderHeight() - 1
   nCol    := ::nDisplayCol - 2
   nWidth  := ::nWidth + 3
   nHeight := Len( ::aEditListTxt ) * ( FontHeight( ::oBrw, ::oBrw:oFont ) ) + 2

   If nRow + nHeight > ::oBrw:BrwHeight()
      If (::oBrw:BrwHeight() - nRow) < ::oBrw:nRowHeight
         while ( nRow -  nHeight - ::oBrw:nRowHeight + 1 ) < 0
            nHeight -= FontHeight( ::oBrw, ::oBrw:oFont )
         enddo
         nRow :=  nRow - nHeight - ::oBrw:nRowHeight + 1
      else
         nHeight := ::oBrw:BrwHeight() - nRow
      Endif
   Endif

   if ::aEditListBound == nil
      aBound := Array( Len( ::aEditListTxt ) )
      AEval( aBound, {|v,e| aBound[ e ] := ::aEditListTxt[ e ] } )

   else
      aBound := ::aEditListBound
   endif

   if ::oEditGet <> nil
      ::oEditGet:End()
      ::oEditGet := nil
      hBrush := CreateColorBrush( Eval( ::bClrSel )[ 2 ] )

      ::EraseData( ( ( ::oBrw:nRowSel - 1 ) * ::oBrw:nRowHeight ) + ::oBrw:HeaderHeight(), ::nDisplayCol, ::oBrw:nRowHeight , hBrush )
      DeleteObject( hBrush )
   endif

   aColors  := Eval( ::bClrEdit )
   oFont    := If( ValType( ::oEditFont ) == "B", Eval( ::oEditFont ), ::oEditFont )

   ::oEditLbx := TListBox():New( 0, 0, { | u | If( PCount()==0, nAt, nAt:= u ) }, ::aEditListTxt, 0, 0,, ::oBrw,, aColors[ 1 ], aColors[ 2 ], .F., .F.,, oFont,, .F.,,,, .F., .F. )

   ::oEditLbx:bLostFocus := { | oLbx, hWndFocus | ::PostEdit( aBound[ Max( 1, nAt ) ], .T. ) }


   ::oEditLbx:bLButtonUp := {|| ::oEditLbx:Change(), ::oEditLbx:nLastKey := 13, ::PostEdit( aBound[ nAt ], .T. ) }

   IF ::oBrw:oWnd:IsKindOf( "TDIALOG" )
      ::oEditLbx:nDlgCode = 4
      ::oEditLbx:bKeyDown   := {|k| ::oEditLbx:nLastKey := k, nil }

   ELSE


      ::oEditLbx:bKeyDown   := {|k| ::oEditLbx:nLastKey := k,  If( k == 13 .AND. nAt > 0,  xValue := aBound[ nAt ], ), If( k == 13 .OR. k == 27, ::PostEdit( xValue, .T. ), ) }
   ENDIF

   ::oEditLbx:Move( nRow, nCol, nWidth, nHeight, .T. )
   ::oEditLbx:SetFocus()

   ::oBrw:lEditMode := .T.

   if nKey <> nil
      PostMessage( ::oEditLbx:hWnd, 258, nKey )
   endif

   ::oBrw:nLastEditCol := ::nPos

return .T.



UTILITY STATIC function TXBrwColumn_RunBtnAction( nKey) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nRow, nCol
   local hBrush

   if ::bEditBlock == nil
      MsgStop( "oCol:bEditBlock not defined", "Fivewin: Class TXBrwColumn")
      return .F.
   endif

   ::oBrw:nColSel := ::nPos

   if ::oEditGet <> nil
      ::oEditGet:End()
      ::oEditGet := nil
      hBrush := CreateColorBrush( Eval( ::bClrSel )[ 2 ] )

      ::EraseData( ( ( ::oBrw:nRowSel - 1 ) * ::oBrw:nRowHeight ) + ::oBrw:HeaderHeight(), ::nDisplayCol, ::oBrw:nRowHeight , hBrush )
      DeleteObject( hBrush )
   endif

   nRow := ( ::oBrw:nRowSel * ::oBrw:nRowHeight ) + ::oBrw:HeaderHeight() - 3
   nCol := ::nDisplayCol

   ::oBrw:lEditMode := .T.
   ::PostEdit( Eval( ::bEditBlock, nRow, nCol, Self, nKey ), .T. )
   ::oBrw:nLastEditCol := ::nPos

return .T.



UTILITY STATIC function TXBrwColumn_PostEdit( xValue, lButton, lDirectAssign) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local lGoNext := .F.
   local uOriginal    := ::Value()

   local nLastKey := 0
   If ::lOnPostEdit
      return nil
   Endif

   ::lOnPostEdit := .T.

   IIF( lButton == nil, lButton := .F., ) ; IIF( lDirectAssign == nil, lDirectAssign := .F., );

   do case
      case xValue <> nil .AND. ( ::nEditType == 1 .OR. lDirectAssign )
         Eval( ::bOnPostEdit, Self, xValue, 13 )
      case ::nEditType == 1 .OR. ::nEditType >= 6
         if ::oEditGet <> nil
            Eval( ::bOnPostEdit, Self, Eval( ::oEditGet:bSetGet ), ::oEditGet:nLastKey )
            nLastKey := ::oEditGet:nLastKey
            lGoNext := ( AScan( { 13, 40, 38, 9 }, ::oEditGet:nLastKey ) > 0 )
            ::oEditGet:End()
            ::oEditGet := nil
         endif

      case ::nEditType == 2

           if xValue <> nil
              Eval( ::bOnPostEdit, Self, xValue, If( ::oEditLbx <> nil, ::oEditLbx:nLastKey, 0 ) )
              nLastKey   := If( ::oEditLbx <> nil, ::oEditLbx:nLastKey, 0 )
              lGoNext    := ( nLastKey == 13 )
           endif
           if ::oEditLbx <> nil .AND. IsWindow( ::oEditLbx:hWnd )
              ::oEditLbx:End()
              ::oEditLbx := nil
           endif

      case ::nEditType == 3
           if ::bOnPostEdit <> nil
              if xValue <> nil
                 Eval( ::bOnPostEdit, Self, xValue, 0 )
              endif
              lGoNext   := .T.
              nLastKey := 13
           endif

      case ::nEditType == 4
           if ::oEditLbx <> nil .AND. IsWindow( ::oEditLbx:hWnd )
              ::oEditLbx:End()
              ::oEditLbx := nil
           endif
           if ! lButton
              if ::oEditGet <> nil
                 Eval( ::bOnPostEdit, Self, Eval( ::oEditGet:bSetGet ), ::oEditGet:nLastKey )
                 lGoNext := ( ::oEditGet:nLastKey == 13 )
                 ::oEditGet:End()
                 ::oEditGet := nil
              endif
           elseif xValue <> nil
              Eval( ::bOnPostEdit, Self, xValue, 0 )
           endif

      case ::nEditType == 5
           if ! lButton
              if ::oEditGet <> nil
                 Eval( ::bOnPostEdit, Self, Eval( ::oEditGet:bSetGet ), ::oEditGet:nLastKey )
                 lGoNext := ( ::oEditGet:nLastKey == 13 )
                 ::oEditGet:End()
                 ::oEditGet := nil
              endif
           elseif xValue <> nil
              if ::bOnPostEdit <> nil
                 Eval( ::bOnPostEdit, Self, xValue, 0 )
              endif
           endif
   endcase

   ::oBrw:SetFocus()
   if Empty( ::cOrder )
      ::oBrw:DrawLine( .T. )
   else
      if ::oBrw:nDataType == 2
         ::cOrder    := If( ::cOrder == "A", "D", "A" )
         ::SetOrder()
      endif
      ::oBrw:Refresh()
   endif


   if ! Empty( ::nFooterType ) .OR.  ( ::cDataType == "N" .AND. ( ::cFooter <> nil .OR. ::bFooter <> nil .OR. ::nTotal <> nil ) )
      ::RecalcTotal( uOriginal, ::Value )
      ::RefreshFooter()
   endif

   ::lOnPostEdit := .F.
   ::oBrw:lEditMode := .F.

   if ::bOnChange <> nil .AND. ! EQ( ::Value, uOriginal )
      Eval( ::bOnChange, Self, uOriginal )
   endif

   If lGoNext
      ::oBrw:nLastKey   := nLastKey
      ::oBrw:GoNextCtrl()
   Endif

return nil



UTILITY STATIC function TXBrwColumn_RecalcTotal( nOldVal, nNewVal) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   if ! EQ( nOldVal, nNewVal )

      if ::bFooter <> nil
         Eval( ::bFooter, Self, If( ValType( nNewVal ) == "N", nNewVal, 0 ) - If( ValType( nOldVal ) == "N", nOldVal, 0 ) )
      elseif ::nTotal <> nil .OR. ! Empty( ::nFooterType )
         IIF( ::nFooterType == nil, ::nFooterType := 1, ) ;
         if ::nTotal == nil
            if ::nFooterType == 8
               if nOldVal == nil .OR. nNewVal == nil
                  if nOldVal == nil
                     ::nCount++
                  else
                     ::nCount--
                  endif
               endif
            endif
         else
            if ::nFooterType == 4
               if ValType( nNewVal ) == "N" .AND. nNewVal > ::nTotal
                  ::nTotal := nNewVal
               elseif ValType( nOldVal ) == "N" .AND. nOldVal == ::nTotal
                  ::oBrw:MakeTotals( Self )
               endif
            elseif ::nFooterType == 2
               if ValType( nNewVal ) == "N" .AND. nNewVal < ::nTotal
                  ::nTotal := nNewVal
               elseif ValType( nOldVal ) == "N" .AND. nOldVal == ::nTotal
                  ::oBrw:MakeTotals( Self )
               endif
            else
               if ValType( nOldVal ) == "N"
                  ::nCount--
                  ::nTotal    -= nOldVal
                  if ! Empty( ::nTotalSq )
                     ::nTotalSq  -= ( nOldVal * nOldVal )
                  endif
               endif
               if ValType( nNewVal ) == "N"
                  ::nCount++
                  ::nTotal    += nNewVal
                  if ! Empty( ::nTotalSq )
                     ::nTotalSq  += ( nNewVal * nNewVal )
                  endif
               endif
            endif
         endif
      endif

   endif

return nil



UTILITY STATIC function TXBrwColumn_SumOfCols( aCols, nType) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nSum, nSumSq, nCount
   local u, n, oCol

   IIF( nType == nil, nType := 1, ) ;

   if ValType( aCols ) == "C"

      u     := Upper( aCols )
      aCols := {}

      for each oCol in ::oBrw:aCols
         if ! Empty( oCol:cGrpHdr ) .AND. Upper( oCol:cGrpHdr ) == u
            AAdd( aCols, oCol )
         endif
      next

   endif

   nCount   := 0
   if nType <> 2 .AND. nType <> 4
      nSum := nSumSq := 0
   endif
   if ! Empty( aCols )
      for each oCol in aCols
         if ValType( oCol ) <> "O"
            oCol     := ::oBrw:oCol( oCol )
         endif
         if oCol <> nil .AND. oCol <> Self
            if ValType( n := oCol:Value() ) == "N"
               if nType == 2
                  nSum  := If( nSum == nil, n, Min( n, nSum ) )
               elseif nType == 4
                  nSum  := If( nSum == nil, n, Max( n, nSum ) )
               else
                  nSum     += n
                  nCount++
                  if lAnd( nType, 1 + 8 + 16 )
                     nSumSq   += ( n * n )
                  endif
               endif
            endif
         endif
      next
   endif

   if nType == 8
      nSum  := nCount
   elseif nType == 1 + 8
      nSum  := If( nCount > 0, nSum / nCount, 0 )
   elseif nType >= 1 + 8 + 16
      if nCount > 0
         nSum  := nSumSq - ( nSum * nSum / nCount )
         if nType == 1 + 8 + 16 + 32 .OR. nCount == 1
            nSum  /= nCount
         else
            nSum  /= ( nCount - 1 )
         endif
         nSum  ^= 0.5
      else
         nSum  := 0
      endif
   endif

return nSum



UTILITY STATIC function TXBrwColumn_SetOrder() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   LOCAL   lSorted   := .F.
   LOCAL   n, oCol, cSort, uRet
   LOCAL   aToken
   LOCAL   cType, cOrder
   LOCAL   cOrdBag   := If( ValType( ::cOrdBag ) == "B", Eval( ::cOrdBag ), ::cOrdBag )

   if ::cSortOrder <> nil

      if ValType( ::cSortOrder ) == "B"
         uRet  := Eval( ::cSortOrder, Self )
         lSorted := ( ValType( uRet ) == "C" .AND. Upper( uRet ) $ "AD" )
         if lSorted
            ::oBrw:cOrders := " "
            ::cOrder       := Upper( uRet )
         endif

      elseif ::oBrw:nDataType == 2
         ::SortArrayData()


      elseif nAnd( ::oBrw:nDataType, 4 ) == 4 .AND.  ::oBrw:oRs <> nil

         n       := If( ::oBrw:oRs:RecordCount > 0, ::oBrw:oRs:BookMark, nil )
         cSort   := Upper( ::oBrw:oRs:Sort )
         cSort   := TRIM( StrTran( StrTran( cSort, "DESC", "" ), "ASC", "" ) )
         if EQ( cSort, ::cSortOrder )

            if ::cOrder == "D"
               ::oBrw:oRs:Sort   := ::cSortOrder
               ::cOrder          := "A"
            else
               ::oBrw:oRs:Sort   := ::cSortOrder + " DESC"
               ::cOrder          := "D"
            endif
            lSorted      := .T.
         else

            ::oBrw:oRs:Sort      := ::cSortOrder
            ::oBrw:cOrders       := " "
            ::cOrder             := "A"
            lSorted              := .T.
         endif
         if lSorted .AND. n <> nil
            ::oBrw:oRs:BookMark  := n
         endif

      elseif nAnd( ::oBrw:nDataType, 64 ) == 64 .AND.  ::oBrw:oMysql <> nil
         if ::oBrw:oMysql:IsKindOf( "TDOLPHINQRY" )

            aToken := HB_ATokens( ::oBrw:oMysql:cOrder, " " )

            IF Len( aToken ) == 1
               AAdd( aToken, "ASC" )
            ENDIF

            cOrder = AllTrim( Lower( aToken[ 1 ] ) )
            cType = aToken[ 2 ]

            AEval( ::oBrw:aCols, {| o | o:cOrder := " " } )
            IF Lower( AllTrim( ::cSortOrder ) ) == cOrder
               IF Upper( cType ) == "ASC"
                  cType = "DESC"
                  ::cOrder = "D"
               ELSE
                  cType = "ASC"
                  ::cOrder = "A"
               ENDIF
            ELSE
               cOrder = ::cSortOrder
               cType = "ASC"
               ::cOrder = "A"
            ENDIF
            ::oBrw:oMysql:SetOrder( cOrder + " " + cType )

         else
            cSort   := Upper( ::oBrw:oMysql:cSort )
            cSort   := TRIM( StrTran( StrTran( cSort, "DESC", "" ), "ASC", "" ) )
            if EQ( cSort, ::cSortOrder )

               if ::cOrder == "D"
                  ::oBrw:oMysql:cSort := ::cSortOrder
                  ::cOrder            := "A"
               else
                  ::oBrw:oMysql:cSort := ::cSortOrder + " DESC"
                  ::cOrder            := "D"
               endif
               lSorted      := .T.
            else

               ::oBrw:oMysql:Sort      := ::cSortOrder
               ::oBrw:cOrders       := " "
               ::cOrder             := "A"
               lSorted              := .T.
            endif
         endif

      elseif nAnd( ::oBrw:nDataType, 16 ) == 16 .AND.  ValType( ::cSortOrder ) == "C"

         if ::oBrw:oDbf:IsKindOf( "TDATABASE" )

            IIF( cOrdBag == nil, cOrdBag := ::oBrw:oDbf:IndexBagName(), ) ;

            if ::oBrw:oDbf:SetOrder() == Upper( ::cSortOrder )
               if !Empty( ::cOrder ) .AND. ::oBrw:oDbf:IndexBagName() == Upper( cOrdBag )
                  ::oBrw:oDbf:OrdDescend( nil, nil, ::cOrder == "A" )
                  ::cOrder       := If( ::cOrder == "A", "D", "A" )
                  lSorted        := .T.
               else
                  ::oBrw:oDbf:SetOrder( ::cSortOrder, cOrdBag )
                  lSorted        := .T.
                  ::oBrw:cOrders := " "
                  ::cOrder       := "A"
               endif
            else
               ::oBrw:oDbf:SetOrder( ::cSortOrder, cOrdBag )
               lSorted  := .T.
               ::oBrw:cOrders     := " "
               ::cOrder           := "A"
            endif















         endif
      elseif ValType( ::oBrw:cAlias ) == "C" .AND. ValType( ::cSortOrder ) == "C"

         IIF( cOrdBag == nil, cOrdBag := ( ::oBrw:cAlias )->( OrdBagName() ), ) ;

         if (::oBrw:cAlias)->( OrdSetFocus() ) == Upper( ::cSortOrder )
            if !Empty( ::cOrder ) .AND. Upper( cOrdBag ) == ( ::oBrw:cAlias )->( OrdBagName() )


            else
               (::oBrw:cAlias)->( OrdSetFocus( ::cSortOrder, cOrdBag ) )
               ::cOrder          := "A"
            endif
            lSorted              := .T.

         else

            (::oBrw:cAlias)->( OrdSetFocus( ::cSortOrder, cOrdBag ) )
            lSorted   := .T.
            ::oBrw:cOrders     := " "


         endif

      endif

   endif

   if lSorted
      ::oBrw:Seek()
   endif

return lSorted



UTILITY STATIC function TXBrwColumn_SortArrayData() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local aCols
   local cOrder
   local nAt, nFor, nLen
   local uSave, cType

   aCols  := ::oBrw:aCols
   cOrder := ::cOrder
   nLen   := Len( aCols )
   nAt    := If( ValType( ::cSortOrder ) == "N", ::cSortOrder, ::nArrayCol )
   if Empty( nAt ) .OR. ValType( nAt ) <> "N"
      nAt   := 1
   endif

   if Len( ::oBrw:aArrayData ) > 0

      for nFor := 1 to nLen
         if aCols[ nFor ]:nArrayCol <> ::nArrayCol
            aCols[ nFor ]:cOrder := ""
         endif
      next

      uSave    := ::oBrw:aArrayData[ ::oBrw:nArrayAt ]
      if cOrder == "A"
         ::oBrw:aArrayData := Asort( ::oBrw:aArrayData,,::oBrw:nLen, {|x,y| ACompare( x, y, nAt, ::lCaseSensitive ) < 0 } )
         ::cOrder     := "D"
      else
         ::oBrw:aArrayData := Asort( ::oBrw:aArrayData,,::oBrw:nLen, {|x,y| ACompare( x, y, nAt, ::lCaseSensitive ) > 0 } )
         ::cOrder     := "A"
      endif
      ::oBrw:nArrayAt   := AScan( ::oBrw:aArrayData, { |a| a == uSave } )
      ::oBrw:Refresh()

   endif

return self



static function ACompare( x, y, nAt, lCaseSensitive )

   local nRet := -1
   local xVal, yVal, xType, yType
   local aType := "ULNPDCHO"

   if ValType( x ) <> "A"
      x     := { x }
   endif
   xVal     := If( nAt <= Len( x ), x[ nAt ], nil )
   xType    := ValType( xVal )

   if ValType( y ) <> "A"
      y     := { y }
   endif
   yVal     := If( nAt <= Len( y ), y[ nAt ], nil )
   yType    := ValType( yVal )

   if xType == yType .AND. xType $ "CDLN"
      if xType == "C" .AND. ! lCaseSensitive
         xVal  := Upper( xVal )
         yVal  := Upper( yVal )
      endif
   else
      xVal  := At( xType, aType )
      yVal  := At( yType, aType )
   endif

   nRet  := If( xVal == yVal, 0, If( xVal < yVal, 1, -1 ) )

return nRet



UTILITY STATIC function TXBrwColumn_ClpText() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local RetVal    := ""
   local cDtFmt, cTmFmt

   if nxlLangID == nil
      SetExcelLanguage()
   endif

   if ::bEditValue == nil
      if ::bStrData == nil
         RetVal   := ""
      else
         RetVal   := AllTrim( Eval( ::bStrData ) )
      endif
   else
      RetVal       := ::Value()
      if ::cDataType == "P" .OR. ::nEditType < 0
         RetVal    := ""
      elseif ::cDataType == "D"

         cDtFmt    := Set( 4 )
         Set( 4, "YYYY-MM-DD" )
         RetVal   := DTOC( RetVal )
         Set(4, cDtFmt )


      elseif ::cDataType == "T"

         cDtFmt    := Set( 4 )
         cTmFmt    := Set( 207 )
         Set( 4, "YYYY-MM-DD" )
         Set( 207, "HH:MM:SS" )
         RetVal   := TTOC( RetVal )
         Set( 207, cTmFmt )
         Set( 4, cDtFmt )


      elseif ::cDataType == "L"

         RetVal    := If( RetVal == nil, "", If( RetVal, cxlTrue, cxlFalse ) )

      else

         RetVal    := Trim( cValToChar( RetVal ) )

      endif

   endif

return RetVal



UTILITY STATIC function TXBrwColumn_ToExcel( oSheet, nRow, nCol) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local uVal     := ::Value
   local hBmp, hBmp2, nHeight, nWidth, oClp

   if uVal <> nil
      if ::cDataType $ "PF"
         if ::cDataType == "F" .AND. File( uVal )
            hBmp     := FILoadImg( uVal )
         else
            hBmp     := FILoadFromMemory( uVal )
         endif
         if hBmp <> 0
            nHeight  := nBmpHeight( hBmp )
            nWidth   := nBmpWidth(  hBmp )
            if nWidth > ::nWidth .OR. nHeight > ::oBrw:nRowHeight
               if nWidth > ::nWidth
                  nHeight  *= ( ::nWidth / nWidth )
                  nWidth   := ::nWidth
               endif
               if nHeight > ::oBrw:nRowHeight
                  nWidth   *= ( ::oBrw:nRowHeight / nHeight )
                  nHeight  := ::oBrw:nRowHeight
               endif
               hBmp2       := hBmp
               hBmp        := ResizeImg( hBmp2, nWidth, nHeight )
               DeleteObject( hBmp2 )
            endif

            oClp     := TClipBoard():New( 2, ::oBrw:oWnd )
            oClp:Open()
            oClp:Empty()
            SetClipboardData( 2, hBmp )
            oClp:Close()
            oSheet:Cells( nRow, nCol ):Select()
            oSheet:Paste()
            oClp:Clear()
            oClp:End()
         endif
         DeleteObject( hBmp )

      else
         if ValType( uVal ) $ "DT"
            if ! Empty( uVal ) .AND. Year( uVal ) < 1900
               uVal  := DToC( uVal )
            endif
         endif
         oSheet:Cells( nRow, nCol ):Value := uVal
      endif
   endif

return Self



UTILITY STATIC function TXBrwColumn_Paste( cText) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local uNew, cType

   if ::cDataType $  "CM"
      if Eval( ::oBrw:bLock )
         ::Value     := Trim( cText )
      endif
   else
      uNew        := uCharToVal( cText, @cType )
      if uNew <> nil
         if ::cDataType == nil .OR. ::cDataType == cType
            if EVal( ::oBrw:bLock )
               ::Value  := uNew
            endif
         endif
      endif
   endif

return nil



UTILITY STATIC function TXBrwColumn_WorkMergeData() ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nKount   := 0
   local uPrev, uVal, nAt
   local nLen     := Eval( ::oBrw:bKeyCount )

   ::aMerge    := {}

   Eval( ::oBrw:bGoTop )
   for nAt  := 1 to nLen
      uVal  := ::Value()
      if uVal == nil
         msgStop( "Column value is nil" )
         __Quit()
      endif
      if uVal == uPrev
         nKount++
      else
         nKount  := 0
         uPrev := uVal
      endif
      AAdd( ::aMerge, { nKount, 0, ::oBrw:KeyNo() } )
      ::oBrw:Skip(1)
   next
   Eval( ::oBrw:bGoTop )

   nKount   := 0
   for nAt := nLen to 1 step -1
      ::aMerge[ nAt ][ 2 ] := nKount
      nKount++
      if ::aMerge[ nAt ][ 1 ] == 0
         nKount   := 0
      endif
   next

return nil



UTILITY STATIC function TXBrowse_HandleEvent( nMsg, nWParam, nLParam) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   if nMsg == 675
      return ::MouseLeave( nHiWord( nLParam ), nLoWord( nLParam ), nWParam )
   endif
return ::TControl:HandleEvent( nMsg, nWParam, nLParam )



UTILITY STATIC function TXBrwColumn_HasBorder( nRowPos) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local lBorder     := .T.
   local nDataRows   := If( Empty( ::oBrw:nDataRows ), ::oBrw:RowCount(), ::oBrw:nDataRows )
   local nAt

   if ::lMergeVert .AND. nRowPos < nDataRows
      nAt   := nRowPos - ::oBrw:nRowSel + ::oBrw:KeyNo()
      lBorder  := ( ::aMerge[ nAt ][ 2 ] == 0 )
   endif

return lBorder



UTILITY STATIC function TXBrwColumn_MergeArea( nTop, nBottom, nRowPos) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nAt, uVal, nRowOffset, nPos
   local aData
   local nFirstRow, nLastRow
   local n1, n2
   local nDataRows   := If( Empty( ::oBrw:nDataRows ), ::oBrw:Rowcount(), ::oBrw:nDataRows )
   if ::lMergeVert
      nAt         := ::oBrw:KeyNo()
      n1          := Min( nRowPos - 1, ::aMerge[ nAt ][ 1 ] )
      n2          := Min( nDataRows - nRowPos, ::aMerge[ nAt ][ 2 ] )
      nTop        -= n1 * ::oBrw:nRowHeight
      nBottom     += n2 * ::oBrw:nRowHeight
   endif

return nTop







static function GetZeroZeroClr( hDC, hBmp )

    local hDCMem, hOldBmp, nZeroZeroClr

    hDCMem = CreateCompatibleDC( hDC )
    hOldBmp = SelectObject( hDCMem, hBmp )
    nZeroZeroClr = GetPixel( hDCMem,0,0)
    SelectObject( hDCMem, hOldBmp )
    DeleteDC( hDCMem )

return nZerozeroClr



static function FontHeight( oBrw, oFont )

   local hDC
   local nHeight

   hDC := oBrw:GetDC()
   oFont:Activate( hDC )
   nHeight := GetTextHeight( oBrw:hWnd, hDC )
   oBrw:ReleaseDC()

return nHeight



function ExtractLine( cText, nFrom )

  local cLine, nAt

  nAt := At( Chr(13)+Chr(10), SubStr( cText, nFrom ) )

  if nAt > 0
    cLine := Substr( cText, nFrom, nAt - 1 )
    nFrom += nAt + 1
  else
    cLine := Substr( cText, nFrom )
    nFrom := Len( cText ) + 1
  endif

return cLine



Function EQ( uFirst, uSecond, lExact )

   local c

   IIF( lExact == nil, lExact := .T., ) ;

   if ( c := Valtype( uFirst ) ) == Valtype( uSecond )
      if c == "C"
         if lExact
            if Upper( AllTrim( uFirst ) ) == Upper( AllTrim( uSecond ) )
               return .T.
            endif
         else
            if Upper( AllTrim( uFirst ) ) = Upper( AllTrim( uSecond ) )
               return .T.
            endif
         endif
      else
         if uFirst == uSecond
            return .T.
         endif
      endif
   endif

return .F.



static function clp2xlnumpic( cPic )

   local cFormat, aPic, c, lEnglish := lxlEnglish

   if cPic == nil
      cFormat  := If( FWNumFormat()[ 2 ], If( lEnglish, "#,##0", "#.##0" ), "0" )
   else
      cPic     := StrTran( cPic, "#", "9" )
      aPic     := HB_ATokens( cPic, " " )

      cFormat  := ""
      for each c in aPic
         if Left( c, 1 ) == "@"





         else
            if "9" $ c
               if Left( c, 1 ) == "$"
                  cFormat  += "$"
               endif
               cFormat  += If( FWNumFormat()[ 2 ] .OR. ",9" $ cPic, If( lEnglish, "#,##0", "#.##0" ), "0" )
               if ".9" $ c
                  cFormat  += If( lEnglish, ".", "," )
                  cFormat  += StrTran( SubStr( c, At( ".", c ) + 1 ), "9", "0" )

               endif
               cFormat  += " "
            else
               cFormat  += ( '"' + c + '" ' )
            endif
         endif
      next
   endif

return Trim( cFormat )


static function FontEsc( oFont )

   local nEsc := 0

   if oFont <> nil .AND. ValType( oFont:nEscapement ) == "N"
      nEsc = Abs( oFont:nEscapement )
   endif

return nEsc



static function ClipTextAsArray( cText )

   local aText, n

   cText       := StrTran( cText, Chr(13)+Chr(10), Chr(10) )






   aText       := hb_aTokens( cText, Chr(10) )
   for n := 1 to Len( aText )
      aText[ n ]  := hb_aTokens( aText[ n ], Chr(9) )
   next

return aText



static function ArrayResize( aData, nSize )

   local aBlank   := {}
   local n

   if nSize < Len( aData )
      ASize( aData, nSize )
   elseif nSize > Len( aData )
      for n := 1 to Len( aData[ 1 ] )
         AAdd( aBlank, uValBlank( aData [ 1 ][ n ] ) )
      next
      for n := Len( aData ) + 1 to nSize
         AAdd( aData, AClone( aBlank ) )
      next
   endif

return aData














function XbrowseNew( oWnd, nRow, nCol, nWidth, nHeight, aFlds, aHeaders, aColSizes,   bChange, bLDblClick, bRClick,  oFont, oCursor, nClrFore, nClrBack,  cMsg, lUpdate, cDataSrc, bWhen,  lDesign, bValid, lPixel, nResID, lAutoSort, lAddCols,  aPics, aCols, aJust, aSort, lFooter, lFastEdit,  lCell, lLines, aRows, uBack, cBckMode, bClass, lTransparent, lNoBorder )

   local oBrw, n, i, oCol, oClass

   IIF( lTransparent == nil, lTransparent := .F., ) ;
   IIF( oWnd == nil, oWnd := If( GetWndDefault() == nil, TWindow():New(), GetWndDefault() ), ) ;




   if ValType( bClass ) == "B"
      oClass      := Eval( bClass )
   endif
   if oClass <> nil .AND. oClass:IsKindOf( "TXBROWSE" )
      oBrw        := oClass:New( oWnd )
   else
      oBrw        := TXBrows():New( oWnd )
      if oClass <> nil .AND. oClass:IsKindOf( "TXBRWCOLUMN" )
         oBrw:bColClass := bClass
      endif
   endif

   oBrw:lAutoSort  := lAutoSort
   oBrw:bLDblClick := bLDblClick
   oBrw:bRClicked  := bRClick

   aFlds          := CheckArray( aFlds )
   aHeaders       := CheckArray( aHeaders )
   aColSizes      := CheckArray( aColSizes )
   aPics          := CheckArray( aPics )
   aCols          := CheckArray( aCols )
   aJust          := CheckArray( aJust )
   aSort          := CheckArray( aSort )

   if aCols <> nil
      aCols          := ASize( ArrTranspose( aCols ), 6 )
   endif


   XbrwSetDataSource( oBrw, cDataSrc, lAddCols, lAutoSort,  If( aCols == nil, nil, aCols[ 1 ] ), aRows, aHeaders  )

   IIF( aHeaders == nil, aHeaders := {}, ) ; IIF( aPics == nil, aPics := {}, ); IIF( aColSizes == nil, aColSizes := {}, ); IIF( aSort == nil, aSort := {}, );

   if aCols <> nil
      aHeaders       := ArrMerge( aCols[ 2 ], aHeaders )
      aPics          := ArrMerge( aCols[ 3 ], aPics )
      aColSizes      := ArrMerge( aCols[ 4 ], aColSizes )
      aJust          := ArrMerge( aCols[ 5 ], aJust )
      aSort          := ArrMerge( aCols[ 6 ], aSort )
   endif

   if ! Empty( aFlds )
      for n := 1 to Len( aFlds )
         oBrw:AddCol():bEditValue   := aFlds[ n ]
      next
   endif

   for i := 1 to Len( oBrw:aCols )
      oCol  := oBrw:aCols[ i ]
      if Len( aPics ) >= i .AND. aPics[ i ] <> nil
         if ValType( aPics[ i ] ) == "A"
            oCol:SetCheck( aPics[ i ] )
         elseif !Empty( aPics[ i ] )
            oCol:cEditPicture := aPics[ i ]
         endif
      endif
      if Len( aHeaders ) >= i .AND. aHeaders[ i ] <> nil
        oCol:cHeader   := cValToChar( aHeaders[ i ] )
      endif
      if Len( aColSizes ) >= i
         if aColSizes[ i ] <> nil .AND. aColSizes[ i ] < 0
            n              := -aColSizes[ i ]
            oCol:nDataLen  := Int( n )
            if n > oCol:nDataLen
               n           := Int( 10 * ( n - oCol:nDataLen ) )
               oCol:nDataDec  := n
            endif
         else
            oCol:nWidth    := aColSizes[ i ]
         endif
      endif
      if Len( aSort ) >= i .AND. ! Empty( aSort[ i ] )
         oCol:cSortOrder := aSort[ i ]
      endif
   next

   if valtype( nClrFore ) == "N"
      IIF( nClrBack == nil, nClrBack := 16777215, ) ;
      oBrw:bClrStd      := {|| { nClrFore, nClrBack } }
      oBrw:SetColor( nClrFore, nClrBack )
   endif

   if ValType( uBack ) $ "ACNO"
      if ValType( uBack ) == "A"
         n     := If( ValType( cBckMode ) == "C", ( cBckMode <> "HORIZONTAL" ), .T. )
      else
         n     := If( ValType( cBckMode ) == "C", AScan( { "TILED","STRETCH","FILL" }, cBckMode ), 0 )

         n     := If( n > 0, n - 1, nil )
      endif
      oBrw:SetBackGround( uBack, n )
   endif

   oBrw:bChange       := bChange
   if oFont <> nil
      oBrw:oFont      := oFont
   endif
   if bWhen <> nil
      oBrw:bWhen      := bWhen
   endif
   if bValid <> nil
      oBrw:bValid     := bValid
   endif
   if oCursor <> nil
      oBrw:oCursor    := oCursor
   endif
   if cMsg <> nil
      oBrw:cMsg       := cMsg
   endif

   oBrw:lDesign       := lDesign

   if ! Empty( aJust )
      oBrw:aJustify  := aJust
   endif

   oBrw:lFooter   := lFooter
   oBrw:lFastEdit := lFastEdit

   if lLines
      oBrw:nColDividerStyle         := 1
      oBrw:nRowDividerStyle         := 1
      oBrw:lColDividerComplete      := .T.
   endif

   if lCell
      oBrw:nMarqueeStyle            := 3
   endif

   if ValType( nResID ) == "N"
      oBrw:CreateFromResource( nResID )
   else
      if nRow <> nil
         oBrw:nTop       := nRow * If( lPixel, 1, 14 )
      endif

      if nCol <> nil
         oBrw:nLeft      := nCol * If( lPixel, 1, 8 )
      endif

      if nWidth <> nil
         if nWidth <= 0
            oBrw:nRightMargin := -nWidth
            if oWnd:IsKindOf( "TDIALOG" )
               oBrw:nRightMargin *= 2
            endif
         else
            oBrw:nRight     := oBrw:nLeft + nWidth - 1
         endif
      endif

      if nHeight <> nil
         if nHeight <= 0
            oBrw:nBottomMargin    := -nHeight
            if oWnd:IsKindOf( "TDIALOG" )
               oBrw:nBottomMargin *= 2
            endif
         else
            oBrw:nBottom    := oBrw:nTop + nHeight - 1
         endif
      endif

      if lNoBorder == .T. .AND. lAnd( oBrw:nStyle, 8388608 )
         oBrw:nStyle       -= 8388608
      endif
      if lTransparent
         oBrw:lTransparent := .T.
      endif
      oBrw:lUpdate      := lUpdate
   endif

return oBrw



static function CheckArray( aArray )



   if ValType( aArray ) == "A" .AND.  Len( aArray ) == 1 .AND.  ValType( aArray[ 1 ] ) == "A"

      aArray   := aArray[ 1 ]
   endif

return aArray



function XbrwSetDataSource( oBrw, uDataSrc, lAddCols, lAutoSort, aCols, aRows, aHeaders  )




   local cType    := ValType( uDataSrc ), lSet := .F.

   if ! Empty( aCols )
      lAddCols    := .T.
   endif

   do case
   case cType == "C"

      if Select( uDataSrc ) > 0
         oBrw:cAlias    := uDataSrc
         oBrw:nDataType := 1
         if lAddCols .OR. ! Empty( aCols )
            oBrw:SetRDD( lAddCols, lAutoSort, aCols, aRows )
         elseif ! Empty( aRows )
            oBrw:SetRDD( .F., lAutoSort, nil, aRows )
         endif
      endif

   case cType == "A"
      oBrw:nDataType    := 2
      oBrw:aArrayData   := uDataSrc
      if lAddCols .OR. ! Empty( aCols )
         oBrw:SetArray( uDataSrc, lAutoSort, nil, aCols )
      else
         oBrw:SetArray( uDataSrc, nil, nil, .F. )
      endif

   case cType == "H"
      oBrw:aArrayData   := uDataSrc
      oBrw:nDataType    := 2
      oBrw:SetArray( uDataSrc, nil, nil, lAddCols )

   case cType == "O"

      if IsRecordSet( uDataSrc )
         oBrw:nDataType := 4
         oBrw:oRs       := uDataSrc
         if lAddCols .OR. ! Empty( aCols )
            oBrw:SetADO( uDataSrc, lAddCols, lAutoSort, aCols )
         endif
         lSet  := .T.
      elseif IsXlRange( uDataSrc )
         oBrw:nDataType := 128
         oBrw:oRs       := uDataSrc
         oBrw:SetExcelRange( uDataSrc, Empty( aHeaders ), aCols )
         lSet  := .T.
      elseif __ObjHasMethod( uDataSrc, "ISKINDOF" )
         if uDataSrc:IsKindOf( "TMYSQLQUERY" )
            oBrw:nDataType := 64
            oBrw:oMysql       := uDataSrc
            if lAddCols .OR. ! Empty( aCols )
               oBrw:SetMysql( uDataSrc, lAddCols, lAutoSort, aCols )
            endif
            lSet  := .T.
         elseif  uDataSrc:IsKindOf( "TDOLPHINQRY" )
            oBrw:nDataType := 64
            oBrw:oMysql       := uDataSrc
            if lAddCols .OR. ! Empty( aCols )
               oBrw:SetDolphin( uDataSrc, lAddCols, lAutoSort, aCols )
            endif
            lSet  := .T.

         elseif uDataSrc:IsKindOf( "TLINKLIST" )
            oBrw:SetTree( uDataSrc, , , If( aCols == nil, lAddCols, aCols ) )
            lSet  := .T.

         elseif uDataSrc:IsKindOf( "TSTRUCT" )
            oBrw:SetArray( aObjStructure( uDataSrc ), .F., nil, { 1, 2 } )
            oBrw:aCols[ 1 ]:cHeader := "Member"
            WITH OBJECT oBrw:aCols[ 2 ]
               :cHeader    := "Value"
               :nEditType  := 1



               :bOnPostEdit:= { |o,x,n| If( n <> 27,  ( OSend( uDataSrc, "_" + oBrw:aRow[ 1 ], x ),     o:Value := OSend( uDataSrc, oBrw:aRow[ 1 ] ) ),  nil ) }
            END
            oBrw:lFastEdit := .T.
            lSet = .T.

         elseif XBrowsableObj( uDataSrc )
            oBrw:SetoDbf( uDataSrc, aCols, lAutoSort, lAddCols, aRows )
            lSet  := .T.
         endif
      endif

      if ! lSet

         oBrw:SetArray( aObjData( uDataSrc ), .F., nil, { 1, 2, 3 } )
         oBrw:aCols[ 1 ]:cHeader := "Num"
         oBrw:aCols[ 2 ]:cHeader := "Data"
         WITH OBJECT oBrw:aCols[ 3 ]
            :cHeader    := "Value"
            :nEditType  := 1
            :bEditWhen  := { || oBrw:aArrayData[ oBrw:nArrayAt, 4 ] }



            :bOnPostEdit:= { |o,x,n| If( n <> 27,  ( OSend( uDataSrc, "_" + oBrw:aRow[ 2 ], x ),     o:Value := OSend( uDataSrc, oBrw:aRow[ 2 ] ) ),  nil ) }
         END
         oBrw:lFastEdit := .T.
         lSet  := .T.
      endif
   otherwise

   endcase

return nil



static function IsRecordSet( o )

   local lRecSet  := .F.


   lRecSet  := ( o:IsDerivedFrom( "TOLEAUTO" ) .AND. "RECORDSET" $ Upper( o:cClassName ) )










return lRecSet



static function IsXlRange( o )

   local lXlRange  := .F.


   lXlRange  := ( o:IsDerivedFrom( "TOLEAUTO" ) .AND. "EXCEL" $ Upper( o:cClassName ) )










return lXlRange



function XBrowsableObj( oObj )









   return  __ObjHasMethod( oObj, "SETXBROWSE" ) .OR.  ( AScan( { "GOTOP", "GOBOTTOM", "BOF", "EOF", "SKIPPER", "RECCOUNT" },  { |c| ! __ObjHasMethod( oObj, c ) }  ) == 0 .AND.  ( __ObjHasMethod( oObj, "BOOKMARK" ) .OR.  (__ObjHasMsg( oObj, "RECNO" ) .AND. __ObjHasMethod( oObj, "GOTO" ) )  )  )



static function aObjData( obj )

   local n, v, l, aData := AOData( obj )

   for n := 1 to Len( aData )
      TRY
         v  := OSend( obj, aData[ n ] )
         l  := .T.
      CATCH
         v  := "<protected>"
         l  := .F.
      END


      aData[ n ]  := Lower( Left( aData[ n ], 1 ) ) +  SubStr( aData[ n ], 2 , 1 ) +  Lower( SubStr( aData[ n ], 3 ) )
      aData[ n ]  := { n, aData[ n ], V, l }
   next

return aData



static function aObjStructure( obj )
   local n, aData := {}

   for n = 1 to len( obj:aMembers )
      AAdd( aData, { obj:aMembers[ n ][ 1 ], obj:GetMember( n ) } )
   next

return aData



function XbrJustify( oBrw, aJust )
return   ( oBrw:aJustify := aJust )



function xbrNumFormat(...)
return   HB_ExecFromArray( "FWNumFormat", HB_AParams() )



function TXBrows( bChild )

   if bXBrowse == nil
      bXBrowse    := { || TXBrowse() }
   endif



   if ValType( bChild ) == "B" .AND.  ValType( Eval( bChild ) ) == "O" .AND.  Eval( bChild ):IsKindOf( TXBrowse() )

      bXBrowse    := bChild
   endif

return Eval( bXBrowse )



function SetXBrowse( bChild )

   local bPrev

   if bXBrowse == nil
      bXBrowse    := { || TXBrowse() }
   endif

   bPrev          := bXBrowse



   if ValType( bChild ) == "B" .AND.  ValType( Eval( bChild ) ) == "O" .AND.  Eval( bChild ):IsKindOf( TXBrowse() )

      bXBrowse    := bChild
   endif

return bPrev



_HB_CLASS TXbrRow ; UTILITY STATIC FUNCTION TXbrRow(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TXbrRow" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { oBrw} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBrw" }, .F., .F. ), )


   _HB_MEMBER { nRecNo,  nKeyNo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nRecNo" , "nKeyNo" }, .F., .F. ), )

   _HB_MEMBER { aHeaders} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aHeaders" }, .F., .F. ), )
   _HB_MEMBER { aOriginals} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aOriginals" }, .F., .F. ), )
   _HB_MEMBER { aValues} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aValues" }, .F., .F. ), )
   _HB_MEMBER { bSave} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bSave" }, .F., .F. ), )

   _HB_MEMBER New( oBrw, nRecNo, nKeyNo, aHeaders, aValues); IIF( .F., s_oClass:ModMethod( "New", @TXbrRow_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TXbrRow_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Save(); IIF( .F., s_oClass:ModMethod( "Save", @TXbrRow_Save(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Save", @TXbrRow_Save(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Undo(); IIF( .F., s_oClass:ModInline( "Undo", {|Self | Self, ACopy( ::aOriginals, ::aValues ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Undo", {|Self | Self, ACopy( ::aOriginals, ::aValues ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER Modified(); IIF( .F., s_oClass:ModMethod( "Modified", @TXbrRow_Modified(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Modified", @TXbrRow_Modified(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER onError(); s_oClass:SetOnError( @TXbrRow_onError() ) ;

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TXbrRow ;



UTILITY STATIC function TXbrRow_New( oBrw, nRecNo, nKeyNo, aHeaders, aValues) ; local Self AS CLASS TXbrRow := QSelf() AS CLASS TXbrRow

   ::oBrw      := oBrw
   ::nRecNo    := nRecNo
   ::nKeyNo    := nKeyNo
   ::aHeaders  := AClone( aHeaders )
   ::aValues   := aValues
   ::aOriginals:= AClone( aValues )

return Self



UTILITY STATIC function TXbrRow_Save() ; local Self AS CLASS TXbrRow := QSelf() AS CLASS TXbrRow

   local lSaved   := .F.
   local uBm      := Eval( ::oBrw:bBookMark )
   local oCol, n

   Eval( ::oBrw:bBookMark, ::nRecNo )
   if ::oBrw:bLock == nil .OR. Eval( ::oBrw:bLock )
      for n := 1 to Len( ::aHeaders )
         if ::aOriginals[ n ] <> ::aValues[ n ]
            oCol     := ::oBrw:oCol( ::aHeaders[ n ] )
            if oCol:bOnPostEdit == nil
               if oCol:bEditValue <> nil
                  Eval( oCol:bEditValue, ::aValues[ n ] )
               endif
            else
               Eval( oCol:bOnPostEdit, oCol, ::aValues[ n ], 13 )
            endif
         endif
      next
      if ::bSave <> nil
         Eval( ::bSave, Self )
      endif
      if ::oBrw:bUnlock <> nil
         Eval( ::oBrw:bUnlock )
      endif
      if ::oBrw:bOnRowLeave <> nil
         Eval( ::oBrw:bOnRowLeave )
      endif
      lSaved   := .T.
      ACopy( ::aValues, ::aOriginals )
   endif
   if uBm == Eval( ::oBrw:bBookMark )
      ::oBrw:RefreshCurrent()
   else
      Eval( ::oBrw:bBookMark, uBm )
      ::oBrw:Refresh()
   endif

return lSaved



UTILITY STATIC function TXbrRow_Modified() ; local Self AS CLASS TXbrRow := QSelf() AS CLASS TXbrRow

Return ( AScan( ::aValues, { |u,i| u <> ::aOriginals[ i ] } ) > 0 )



UTILITY STATIC function TXbrRow_onError(uParam1) ; local Self AS CLASS TXbrRow := QSelf() AS CLASS TXbrRow

   local cMsg   := __GetMessage()
   local nError := If( SubStr( cMsg, 1, 1 ) == "_", 1005, 1004 )
   local nCol
   local lAssign := .F.

   if Left( cMsg, 1 ) == "_"
      lAssign     := .T.
      nError      := 1005
      cMsg        := SubStr( cMsg, 2 )
   endif
   nCol           := AScan( ::aHeaders, { |c| Upper( c ) == Upper( cMsg ) } )

   if nCol > 0
      if lAssign
         ::aValues[ nCol ] := uParam1
      endif
      return ::aValues[ nCol ]
   endif

    _ClsSetError( _GenError( nError, ::ClassName(), cMsg ) )

return nil



static function SameDbfStruct( oBrw, cAlias )

   local aStr1, aStr2
   local lSame    := .T.

   if ! Empty( oBrw:cAlias ) .AND. Select( oBrw:cAlias ) > 0
      aStr1    := ( oBrw:cAlias )->( dbStruct() )
      aStr2    := ( cAlias )->( dbStruct() )
      if Len( aStr1 ) == Len( aStr2 )


         lSame := ( AScan( aStr1, { |a,i| Upper( a[ 1 ] ) <> Upper( aStr2[ i ][ 1 ] ) .OR.  a[ 2 ] <> aStr2[ i ][ 2 ] } ) == 0 )
      else
         lSame := .F.
      endif
   else
      lSame    := .F.
   endif

return lSame



static function SameAdoStruct( oBrw, oRs )

   local lSame    := .T.
   local n, nFlds, oFld

   nFlds := oBrw:oRs:Fields:Count()
   if nFlds == oRs:Fields:Count()
      for n := 0 to nFlds - 1
         if Upper( oBrw:oRs:Fields( n ):Name ) <> Upper( oRs:Fields( n ):Name )
            lSame := .F.
            exit
         endif
         if Upper( oBrw:oRs:Fields( n ):Type ) <> Upper( oRs:Fields( n ):Type )
            lSame := .F.
            exit
         endif
      next
   else
      lSame    := .F.
   endif

return lSame



function ContrastColor( hDC, nCol, nRow, nWidth, nHeight, nDefClr )

   local nClr, nLuma, nLuma0, nContrast, n, k

   IIF( nDefClr == nil, nDefClr := 0, ) ;
   nContrast        := nDefClr

   nRow     += Int( nHeight / 2 )
   nLuma    := 0
   k        := 0
   for n    := Int( nCol ) + 10 to nCol + nWidth step 10
      nClr  := GetPixel( hDC, n, nRow )
      nLuma += ( 0.299 * nRGBRed( nClr ) + 0.587 * nRGBGreen( nClr ) + 0.114 * nRGBBlue( nClr ) )
      k++
   next

   if k > 0
      nLuma /= k
      nLuma0   := 0.299 * nRGBRed( nDefClr ) + 0.587 * nRGBGreen( nDefClr ) + 0.114 * nRGBBlue( nDefClr )
      if Abs( nLuma - nLuma0 ) < 150
         nContrast   := If( nLuma < 150, 16777215, 0 )
      endif
   endif

return nContrast



static function CreateColorBrush( uClr )

   if ValType( uClr ) == "A"
      uClr     := uClr[ 1 ][ 2 ]
   endif

return CreateSolidBrush( uClr )



static function MakeBlock( uVar )
return { || uVar }



function DrawPen( hDC, aFromRC, aUptoRC, hPen )

   MoveTo( hDC, aFromRC[ 2 ], aFromRC[ 1 ] )
   LineTo( hDC, aUptoRC[ 2 ], aUptoRC[ 1 ], hPen )

return nil



function DrawHorz( hDC, nRow, nLeft, nRight, hPen )
return   DrawPen(  hDC, { nRow, nLeft }, { nRow, nRight }, hPen )



function DrawVert( hDC, nCol, nTop, nBottom, hPen )
return   DrawPen(  hDC, { nTop, nCol }, { nBottom, nCol }, hPen )



function SetKinetic( lOnOff )

   local lOldStatus

   static lStatus := .T.

   lOldStatus = lStatus

   if PCount() == 1 .AND. ValType( lOnOff ) == "L"
      lStatus = lOnOff
   endif

return lOldStatus



function ArrTranspose( aArray, lSquare )

   local nRows, nCols, nRow, nCol, nWidth
   local aNew

   IIF( lSquare == nil, lSquare := .F., ) ;

   nRows          := Len( aArray )
   if lSquare
      nCols       := Len( aArray[ 1 ] )
   else
      nCols       := 1
      for nRow := 1 to nRows
         if ValType( aArray[ nRow ] ) == "A"
            nCols    := Max( nCols, Len( aArray[ nRow ] ) )
         endif
      next
   endif

   aNew           := Array( nCols, nRows )
   for nRow := 1 to nRows
      if ValType( aArray[ nRow ] ) == "A"
         nWidth  := Len( aArray[ nRow ] )
         for nCol := 1 to nWidth
            aNew[ nCol, nRow ]   := aArray[ nRow, nCol ]
         next
      else
         aNew[ 1, nRow ]      := aArray[ nRow ]
      endif
   next

return aNew



static function ArrMerge( aArray1, aArray2 )

   local n, nLen

   if Empty( aArray1 )
      aArray1    := aArray2
   elseif ! Empty( aArray2 )
      if Len( aArray1 ) < Len( aArray2 )
         ASize( aArray1, Len( aArray2 ) )
      endif
      AEval( aArray2, { |u,i| If( u == nil, , aArray1[ i ] := u ) } )
   endif

return aArray1



static function FieldInExpr( cStr, aStruct )

   local cFld  := ""
   local aTokens  := GetTokens( cStr )
   local cToken

   IIF( aStruct == nil, aStruct := DbStruct(), ) ;
   FOR EACH cToken IN aTokens
      cToken   := Upper( cToken )
      if AScan( aStruct, { |a| a[ 1 ] == cToken } ) > 0
         cFld  := cToken
         EXIT
      endif
   NEXT

return cFld



static function OrderTagInfo( aStruct, nCol )

   local nFor, nAt, i, nOrders, aTokens, lCond, aCond, aPos


   IIF( aStruct == nil, aStruct := DbStruct(), ) ; IIF( nCol == nil, nCol := 8, );

   aCond       := Array( Len( aStruct ) ); AFill( aCond, .F. )
   aPos        := Array( Len( aStruct ) ); AFill( aPos,   0  )

   for nFor := 1 to Len( aStruct )
      if Len( aStruct[ nFor ] ) < nCol
         ASize( aStruct[ nFor ], nCol )
      endif
   next

   nOrders     := OrdCount()
   for nFor := 1 to nOrders

      lCond    := ! Empty( OrdFor() )

      aTokens  := GetTokens( OrdKey( nFor ) )
      for i := 1 to Len( aTokens )
         nAt   := AScan( aStruct, { |aFld| aFld[ 1 ] == aTokens[ i ] } )
         if nAt > 0

            if aStruct[ nAt ][ nCol ] == nil .OR. ( aCond[ nAt ] .AND. ! lCond ) .OR.  ( aPos[  nAt ] > i )
               aStruct[ nAt ][ nCol ] := Upper( OrdName( nFor ) )
               aCond[ nAt ]   := lCond
               aPos[  nAt ]   := i
            endif
            EXIT
         endif
      next

   next

return aStruct



static function GetTokens( cStr )

   local aTokens  := {}
   local n,c,sep

   cStr  := Upper( cStr )
   cStr  := StrTran( StrTran( cStr, "->", "!" ), "=", " " )
   for n := 1 to 10
      c  := Token( cStr, nil, n, nil, nil, @sep )
      if Empty( c )
         exit
      endif
      if sep <> "!" .AND. sep <> "("
         AAdd( aTokens, c )
      endif
   next

return aTokens



function FW_Decode(...)

   local xDefault, xVal, xRet, n
   local aSearch  := HB_aParams()
   local nLen     := Len( aSearch )

   if nLen == 1 .AND. ValType( aSearch[ 1 ] ) == "A" .AND. Len( aSearch[ 1 ] ) > 0
      aSearch     := aSearch[ 1 ]
      nLen        := Len( aSearch[ 1 ] )
   endif

   if nLen > 1

      xVal     := aSearch[ 1 ]
      aSearch  := ADel( aSearch, 1, .T. )
      nLen--

      if nLen <= 2
         if ValType( aSearch[ 1 ] ) $ "AH"
            if nLen == 2
               xDefault := aSearch[ 2 ]
            endif
            aSearch     := aSearch[ 1 ]
            nLen        := Len( aSearch )
         elseif nLen == 1
            xDefault    := aSearch[ 1 ]
            nLen        := 0
         endif
      else
         if nLen % 2 == 1
            xDefault    := aSearch[ nLen ]
            nLen--
         endif
      endif
      if ValType( aSearch ) == "H"
         if HHasKey( aSearch, xVal )
            xRet     := aSearch[ xVal ]
         endif
      elseif nLen > 1
         nLen--
         for n := 1 to nLen step 2

            if ValType( xVal ) == ValType( aSearch[ n ] ) .AND.  aSearch[ n ] == xVal

               xRet     := aSearch[ n + 1 ]
               exit
            endif
         next
      endif
   endif

return IfNil( xRet, xDefault )
