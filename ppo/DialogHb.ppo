#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 42 ".\Prg\DialogHb.prg"
extern Set



_HB_CLASS TDialog ; UTILITY FUNCTION TDialog(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TDialog" , {TWindow():classh} ) ) ; ;

   _HB_MEMBER {AS LOGICAL lRegistered} ; IIF( !.F., s_oClass:AddMultiClsData("LOGICAL",, nScope + IIF( .F., 32, 0 ) + 64, { "lRegistered" }, .F. ), )

   _HB_MEMBER { cResName, cResData} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cResName" , "cResData" }, .F., .F. ), )
   _HB_MEMBER { hResources} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "hResources" }, .F., .F. ), )
   _HB_MEMBER { lCentered, lModal, lModify} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lCentered" , "lModal" , "lModify" }, .F., .F. ), )
   _HB_MEMBER { bStart} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bStart" }, .F., .F. ), )
   _HB_MEMBER { lHelpIcon} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lHelpIcon" }, .F., .F. ), )
   _HB_MEMBER { lResize16} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lResize16" }, .F., .F. ), )
   _HB_MEMBER { lTransparent} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lTransparent" }, .F., .F. ), )

   _HB_MEMBER {AS ARRAY aFastKeys} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aFastKeys" }, .F., .F. ), )
   _HB_MEMBER { bTmpValid} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bTmpValid" }, .F., .F. ), )



   _HB_MEMBER New( nTop, nLeft, nBottom, nRight, cCaption, cResName, hResources, lVbx, nStyle, nClrText, nClrBack, oBrush, oWnd, lPixels, oIco, oFont, nHelpId, nWidth, nHeight, lTransparent) AS CLASS TDialog; IIF( .F., s_oClass:ModMethod( "New", @TDialog_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TDialog_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER Define( nTop, nLeft, nBottom, nRight, cCaption, nStyle, nClrText, nClrPane, oBrush) AS CLASS TDialog; IIF( .F., s_oClass:ModMethod( "Define", @TDialog_Define(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Define", @TDialog_Define(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER Activate( bClicked, bMoved, bPainted, lCentered, bValid, lModal, bInit, bRClicked, bWhen, lResize16); IIF( .F., s_oClass:ModMethod( "Activate", @TDialog_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Activate", @TDialog_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AdjTop(); IIF( .F., s_oClass:ModInline( "AdjTop", {|Self | Self, WndAdjTop( ::hWnd ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "AdjTop", {|Self | Self, WndAdjTop( ::hWnd ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER ChangeFocus(); IIF( .F., s_oClass:ModInline( "ChangeFocus", {|Self | Self, PostMessage( ::hWnd, 1024+1040 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ChangeFocus", {|Self | Self, PostMessage( ::hWnd, 1024+1040 ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Close( nResult); IIF( .F., s_oClass:ModMethod( "Close", @TDialog_Close(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Close", @TDialog_Close(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Command( nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "Command", @TDialog_Command(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Command", @TDialog_Command(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CtlColor( hWndChild, hDCChild); IIF( .F., s_oClass:ModMethod( "CtlColor", @TDialog_CtlColor(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CtlColor", @TDialog_CtlColor(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER cToChar( hActiveWnd); IIF( .F., s_oClass:ModMethod( "cToChar", @TDialog_cToChar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "cToChar", @TDialog_cToChar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DefControl( oControl); IIF( .F., s_oClass:ModMethod( "DefControl", @TDialog_DefControl(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DefControl", @TDialog_DefControl(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Destroy(); IIF( .F., s_oClass:ModInline( "Destroy", {|Self | Self, ::TWindow:Destroy(), If( ! ::lModal, .T., nil ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Destroy", {|Self | Self, ::TWindow:Destroy(), If( ! ::lModal, .T., nil ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )



   _HB_MEMBER Display(); IIF( .F., s_oClass:ModInline( "Display", {|Self | Self, ::BeginPaint(), ::Paint(), ::EndPaint(), If( ::bStart <> nil, Eval( ::bStart, ::bStart := nil ),), .F. }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Display", {|Self | Self, ::BeginPaint(), ::Paint(), ::EndPaint(), If( ::bStart <> nil, Eval( ::bStart, ::bStart := nil ),), .F. }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER End( nResult); IIF( .F., s_oClass:ModMethod( "End", @TDialog_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "End", @TDialog_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER EraseBkGnd( hDC); IIF( .F., s_oClass:ModMethod( "EraseBkGnd", @TDialog_EraseBkGnd(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "EraseBkGnd", @TDialog_EraseBkGnd(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GetHotPos( nChar, hCtrlAt); IIF( .F., s_oClass:ModMethod( "GetHotPos", @TDialog_GetHotPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetHotPos", @TDialog_GetHotPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GetItem(nId); IIF( .F., s_oClass:ModInline( "GetItem", {|Self,nId | Self, GetDlgItem( ::hWnd, nId ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetItem", {|Self,nId | Self, GetDlgItem( ::hWnd, nId ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER GotFocus(); IIF( .F., s_oClass:ModInline( "GotFocus", {|Self | Self, ::lFocused := .T., If( ::bGotFocus <> nil, Eval( ::bGotFocus ), nil ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GotFocus", {|Self | Self, ::lFocused := .T., If( ::bGotFocus <> nil, Eval( ::bGotFocus ), nil ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )





   _HB_MEMBER HandleEvent( nMsg, nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "HandleEvent", @TDialog_HandleEvent(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HandleEvent", @TDialog_HandleEvent(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER Help( nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "Help", @TDialog_Help(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Help", @TDialog_Help(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Initiate( hWndFocus, hWnd); IIF( .F., s_oClass:ModMethod( "Initiate", @TDialog_Initiate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Initiate", @TDialog_Initiate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER KeyChar( nKey, nFlags); IIF( .F., s_oClass:ModMethod( "KeyChar", @TDialog_KeyChar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "KeyChar", @TDialog_KeyChar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER KeyDown( nKey, nFlags); IIF( .F., s_oClass:ModMethod( "KeyDown", @TDialog_KeyDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "KeyDown", @TDialog_KeyDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER LostFocus(); IIF( .F., s_oClass:ModInline( "LostFocus", {|Self | Self, ::lFocused := .F., If( ::bLostFocus <> nil, Eval( ::bLostFocus ), nil ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "LostFocus", {|Self | Self, ::lFocused := .F., If( ::bLostFocus <> nil, Eval( ::bLostFocus ), nil ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER MouseMove( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "MouseMove", @TDialog_MouseMove(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MouseMove", @TDialog_MouseMove(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Paint(); IIF( .F., s_oClass:ModMethod( "Paint", @TDialog_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Paint", @TDialog_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER PrintClient(hDC); IIF( .F., s_oClass:ModInline( "PrintClient", {|Self,hDC | Self, 1 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "PrintClient", {|Self,hDC | Self, 1 }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER QueryEndSession(); IIF( .F., s_oClass:ModInline( "QueryEndSession", {|Self | Self, ! ::End() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "QueryEndSession", {|Self | Self, ! ::End() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER SetControl(oCtrl); IIF( .F., s_oClass:ModInline( "SetControl", {|Self,oCtrl | Self, ::oClient := oCtrl, ::ReSize() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetControl", {|Self,oCtrl | Self, ::oClient := oCtrl, ::ReSize() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetFont( oFont); IIF( .F., s_oClass:ModMethod( "SetFont", @TDialog_SetFont(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetFont", @TDialog_SetFont(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SysCommand( nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "SysCommand", @TDialog_SysCommand(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SysCommand", @TDialog_SysCommand(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER VbxFireEvent(pEventInfo); IIF( .F., s_oClass:ModInline( "VbxFireEvent", {|Self,pEventInfo | Self, VBXEvent( pEventInfo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "VbxFireEvent", {|Self,pEventInfo | Self, VBXEvent( pEventInfo ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Help95(); IIF( .F., s_oClass:ModMethod( "Help95", @TDialog_Help95(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Help95", @TDialog_Help95(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));





   _HB_MEMBER AddFastKey(nKey, bAction); IIF( .F., s_oClass:ModInline( "AddFastKey", {|Self,nKey, bAction | Self, ( aAdd( ::aFastKeys, { nKey, bAction } ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "AddFastKey", {|Self,nKey, bAction | Self, ( aAdd( ::aFastKeys, { nKey, bAction } ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Enable(); IIF( .F., s_oClass:ModMethod( "Enable", @TDialog_Enable(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Enable", @TDialog_Enable(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Disable(); IIF( .F., s_oClass:ModMethod( "Disable", @TDialog_Disable(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Disable", @TDialog_Disable(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AEvalValid(); IIF( .F., s_oClass:ModMethod( "AEvalValid", @TDialog_AEvalValid(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AEvalValid", @TDialog_AEvalValid(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TDialog ;





UTILITY STATIC function TDialog_New( nTop, nLeft, nBottom, nRight, cCaption, cResName, hResources, lVbx, nStyle, nClrText, nClrBack, oBrush, oWnd, lPixels, oIco, oFont, nHelpId, nWidth, nHeight, lTransparent) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog




   IIF( hResources == nil, hResources := GetResources(), ) ; IIF( lVbx == nil, lVbx := .F., ); IIF( nClrText == nil, nClrText := GetSysColor( 18 ), ); IIF( nClrBack == nil, nClrBack := GetSysColor( 15 ), ); IIF( lPixels == nil, lPixels := .F., ); IIF( nTop == nil, nTop := 0, ); IIF( nLeft == nil, nLeft := 0, ); IIF( nBottom == nil, nBottom := 10, ); IIF( nRight == nil, nRight := 40, ); IIF( nWidth == nil, nWidth := 0, ); IIF( nHeight == nil, nHeight := 0, ); IIF( lTransparent == nil, lTransparent := .F., );


      IIF( nStyle == nil, nStyle := nOR( 128, 2147483648, 12582912, 524288 ), ) ;




   if nWidth <> 0 .OR. nHeight <> 0
      if ! lPixels
         lPixels = .T.
      endif
      nBottom = nHeight
      nRight  = nWidth
   endif

   ::aControls  = {}
   ::cResName   = cResName
   ::cCaption   = cCaption
   ::hResources = hResources
   ::lModify    = .T.
   ::lVbx       = lVbx
   ::lVisible   = .F.
   ::nResult    = 0
   ::nStyle     = nStyle
   ::oWnd       = oWnd
   ::oIcon      = oIco
   ::oFont      = oFont
   ::nLastKey   = 0
   ::nHelpId    = nHelpId
   ::lResize16  = .F.
   ::lTransparent = lTransparent






   if ValType( oIco ) == "C"
      if File( oIco )
         oIco := TIcon():New( ,,, oIco, )
      else
         oIco := TIcon():New( ,, oIco,, )
      endif
      ::oIcon := oIco
   endif

   ::SetColor( nClrText, nClrBack, oBrush )

   if lPixels
      ::nTop       = nTop
      ::nLeft      = nLeft
      ::nBottom    = nBottom
      ::nRight     = nRight
   else

      ::nTop    := int( nTop    * 15.1 )
      ::nLeft   := int( nLeft   * 7.9 )
      ::nBottom := int( nBottom * 15.1  )
      ::nRight  := int( nRight  * 7.9  )
   endif

   if lVbx
     if ! VbxInit( GetInstance(), "" )
         MsgAlert( "VBX support not available" )
      endif
   endif

   ::Register( nOr( 1, 2 ) )

   SetWndDefault( Self )

return Self




UTILITY STATIC function TDialog_Activate( bLClicked, bMoved, bPainted, lCentered,  bValid, lModal, bInit, bRClicked, bWhen, lResize16) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   static nDlgCount := 0

   local hActiveWnd, hWnd, bDlgProc

   IIF( lCentered == nil, lCentered := .F., ) ; IIF( lModal == nil, lModal := .T., ); IIF( ::hWnd == nil, ::hWnd := 0, ); IIF( lResize16 == nil, lResize16 := .F., );

   ::nLastKey = 0

   ++nDlgCount



   hActiveWnd = If( ::oWnd <> nil, ::oWnd:hWnd, If( nDlgCount > 1 .OR. lWRunning(), GetActiveWindow(), GetWndApp() ) )

   ::lCentered   = lCentered
   ::lModal      = lModal
   ::bLClicked   = bLClicked
   ::bRClicked   = bRClicked
   ::bWhen       = bWhen
   ::bValid      = bValid
   ::bInit       = bInit
   ::bPainted    = bPainted
   ::bMoved      = bMoved
   ::nResult     = nil
   ::lValidating = .F.
   ::lVisible    = .T.
   ::lResize16   = lResize16

   if ::bWhen <> nil
      if ! Eval( ::bWhen, Self )
          ::nResult  = 2
          ::lVisible = .F.
          return nil
      endif
   endif



   if lModal






         ::nResult = if( ! Empty( ::cResName ), DialogBox( ::hResources, ::cResName, hActiveWnd, Self ), DialogBoxIndirect( GetInstance(), If( ! Empty( ::cResData ), ::cResData, ::cToChar( hActiveWnd ) ), hActiveWnd, Self ) )














         if ::nResult == 65535

         CreateDlgError( Self )
      endif

   else

      if ( Len( ::aControls ) > 0 .AND. CanRegDialog() ) .OR.  Len( ::aControls ) == 0






            ::hWnd = if( ! Empty( ::cResName ), CreateDlg( ::hResources, ::cResName, hActiveWnd, Self ), CreateDlgIndirect( GetInstance(), ::cToChar( hActiveWnd ), hActiveWnd, Self ) )













         if ::hWnd == 0
            CreateDlgError( Self )
         endif

         if Len( ::aControls ) > 0 .AND. ! RegDialog( ::hWnd )
            ::SendMsg( 16 )
            MsgAlert( "Not possible to create more non-modal Dialogs" )
         endif

         ShowWindow( ::hWnd )
      else
         MsgAlert( "Not possible to create more non-modal Dialogs" )
      endif
   endif

   nDlgCount--

   if ::lModal
      ::lVisible = .F.
   endif

return nil



UTILITY STATIC function TDialog_DefControl( oCtrl) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   IIF( oCtrl:nId == nil, oCtrl:nId := oCtrl:GetNewId(), ) ;

   if AScan( ::aControls, { | o | o:nId == oCtrl:nId } ) > 0


      Eval( ErrorBlock(), _FWGenError( 2,  "No: " + Str( oCtrl:nId, 6 ) ) )
   else
      AAdd( ::aControls, oCtrl )
      oCtrl:hWnd = 0
   endif

return nil



UTILITY STATIC function TDialog_Command( nWParam, nLParam) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   local oWnd, nNotifyCode, nID, hWndCtl






      nNotifyCode = nHiWord( nWParam )
      nID         = nLoWord( nWParam )
      hWndCtl     = nLParam


   do case
      case ::oPopup <> nil
           ::oPopup:Command( nID )


      case hWndCtl == 0 .AND. ::oMenu <> nil .AND.  If( nNotifyCode == 0, nID <> 2, .F. )
           ::oMenu:Command( nID )

      case GetClassName( hWndCtl ) == "ToolbarWindow32"
           oWndFromHwnd( hWndCtl ):Command( nWParam, nLParam )

      case nID <> 0
           do case
              case nNotifyCode == 0
                   if hWndCtl <> 0 .AND. nID <> 2
                      oWnd := oWndFromhWnd( hWndCtl )
                      if ValType( ::nResult ) == "O"

                         if oWnd <> nil
                            if ! oWnd:lCancel
                               if ::nResult:nID <> nID .AND. ! ::nResult:lValid()
                                  return nil
                               endif
                            endif
                         else
                            if ::nResult:nID <> nID .AND. ! ::nResult:lValid()
                               return nil
                            endif
                         endif
                      endif

                      if AScan( ::aControls, { |o| o:nID == nID } ) > 0



                            SendMessage( hWndCtl, 1024+1024, 0, 0 )

                      elseif nID == 1
                         ::End( 1 )
                      endif
                   else
                      if nID == 1
                         ::GoNextCtrl( GetFocus() )

                      elseif hWndCtl <> 0 .AND.  AScan( ::aControls, { |o| o:nID == nID } ) > 0
                            SendMessage( hWndCtl, 1024+1024, 0, 0 )
                      else
                         ::End( 2 )
                      endif
                   endif

              case nNotifyCode == 1
                   SendMessage( hWndCtl, 1024+1029, 0, 0 )

              case nNotifyCode == 8
                   SendMessage( hWndCtl, 1024+1042, 0, 0 )










           endcase
   endcase

return nil



UTILITY STATIC function TDialog_CtlColor( hWndChild, hDCChild) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   local uVal




      if ::oWnd <> nil .AND. Upper( ::oWnd:ClassName() ) $ "TFOLDER,TPAGES"  .AND. GetClassName( hWndChild ) $ "Button,Static"  .AND. IsAppThemed()
         uVal = DrawThemed( hWndChild, hDCChild )
         SendMessage( hWndChild, 1024+1030, hDCChild )
         return uVal
      endif


return ::TWindow:CtlColor( hWndChild, hDCChild )



UTILITY STATIC function TDialog_cToChar( hActiveWnd) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   local cResult
   local aControls := ::aControls
   local n     := GetDlgBaseUnits()
   local aRect := GetWndRect( hActiveWnd )

   IIF( ::cCaption == nil, ::cCaption := "", ) ;






   cResult = cDlg2Chr( Len( aControls ), int( 8 * ( ::nTop  - aRect[ 1 ]   ) / nHiWord( n ) ), int( 4 * ( ::nLeft - aRect[ 2 ]   ) / nLoWord( n ) ), int( 8 * ( ::nBottom - aRect[ 1 ] ) / nHiWord( n ) ), int( 4 * ( ::nRight  - aRect[ 2 ] ) / nLoWord( n ) ), ::cCaption, ::nStyle )

   for n = 1 to Len( aControls )
      cResult += aControls[ n ]:cToChar()
   next

return cResult




UTILITY STATIC function TDialog_Define( nTop, nLeft, nBottom, nRight, cCaption, nStyle, lVbx, nClrText, nClrBack, oBrush) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog


   IIF( lVbx == nil, lVbx := .F., ) ; IIF( nClrText == nil, nClrText := GetSysColor( 18 ), ); IIF( nClrBack == nil, nClrBack := GetSysColor( 15 ), );

   ::hWnd      = 0
   ::nTop      = nTop
   ::nLeft     = nLeft
   ::nBottom   = nBottom
   ::nRight    = nRight
   ::cCaption  = cCaption
   ::nStyle    = nStyle
   ::lVbx      = lVbx
   ::nLastKey  = 0


   ::SetColor( nClrText, nClrBack, oBrush )

return Self



UTILITY STATIC function TDialog_End( nResult) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   IIF( nResult == nil, nResult := 2, ) ;

   if ! ::lModal

         PostMessage( ::hWnd, 16, nResult )

   else
      if ValType( ::bValid ) == "B"
         if ! Eval( ::bValid, Self )
            return .F.
         endif
      endif
      ::nResult = nResult
      EndDialog( ::hWnd, nResult )
      ::hWnd = 0
   endif


      SysRefresh()
      hb_gcAll()


return .T.





STATIC function VbxInitDialog( hWnd,hInstance,cResName ) ; local _hDLL := If( ValType( "BIVBX10.DLL" ) == "N", "BIVBX10.DLL", LoadLibrary( "BIVBX10.DLL" ) ) ; local uResult ; local cFarProc ; if Abs( _hDLL ) > 32 ; cFarProc = GetProcAdd( _hDLL, If( .T., "VbxInitDialog", ), .T., 5,3,3,8 ) ; uResult = FWCallDLL( cFarProc,hWnd,hInstance,cResName ) ; IIF( ValType( "BIVBX10.DLL" ) == "N",, FreeLibrary( _hDLL ) ) ; else ; MsgAlert( "Error code: " + LTrim( Str( _hDLL ) ) + " loading " + If( ValType( "BIVBX10.DLL" ) == "C", "BIVBX10.DLL", Str( "BIVBX10.DLL" ) ) ) ; end ; return uResult


STATIC function VbxInit( hInstance,cPrefix ) ; local _hDLL := If( ValType( "BIVBX10.DLL" ) == "N", "BIVBX10.DLL", LoadLibrary( "BIVBX10.DLL" ) ) ; local uResult ; local cFarProc ; if Abs( _hDLL ) > 32 ; cFarProc = GetProcAdd( _hDLL, If( .T., "VbxInit", ), .T., 5,3,8 ) ; uResult = FWCallDLL( cFarProc,hInstance,cPrefix ) ; IIF( ValType( "BIVBX10.DLL" ) == "N",, FreeLibrary( _hDLL ) ) ; else ; MsgAlert( "Error code: " + LTrim( Str( _hDLL ) ) + " loading " + If( ValType( "BIVBX10.DLL" ) == "C", "BIVBX10.DLL", Str( "BIVBX10.DLL" ) ) ) ; end ; return uResult

STATIC function VbxTerm( ) ; local _hDLL := If( ValType( "BIVBX10.DLL" ) == "N", "BIVBX10.DLL", LoadLibrary( "BIVBX10.DLL" ) ) ; local uResult ; local cFarProc ; if Abs( _hDLL ) > 32 ; cFarProc = GetProcAdd( _hDLL, If( .T., "VbxTerm", ), .T., 0 ) ; uResult = FWCallDLL( cFarProc ) ; IIF( ValType( "BIVBX10.DLL" ) == "N",, FreeLibrary( _hDLL ) ) ; else ; MsgAlert( "Error code: " + LTrim( Str( _hDLL ) ) + " loading " + If( ValType( "BIVBX10.DLL" ) == "C", "BIVBX10.DLL", Str( "BIVBX10.DLL" ) ) ) ; end ; return uResult



static function CreateDlgError( Self )

   local cRes := If( ValType( ::cResName ) == "N", Str( ::cResName ), ::cResName )
   local cPad := Replicate( Chr( 32 ), 22 )





   Eval( ErrorBlock(),  _FwGenError( 3, Chr(13)+Chr(10) + cPad +  If( ! Empty( cRes ), "Resource: " + cRes, "Title: " + If( Empty( ::cCaption ), "", ::cCaption ) ) ) )
return nil



UTILITY STATIC function TDialog_GetHotPos( nChar, hCtrlAt) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   local hCtrl := GetWindow( ::hWnd, 5 )
   local nAt, cText

   while hCtrl <> 0



      if hCtrl <> hCtrlAt .AND. GetParent( hCtrl ) == ::hWnd .AND.  IsWindowEnabled( hCtrl ) .AND.  ( nAt := At( "&", cText := GetWindowText( hCtrl ) ) ) <> 0 .AND.  Lower( SubStr( cText, nAt + 1, 1 ) ) == Lower( Chr( nChar ) )
         while Upper( GetClassName( hCtrl ) ) == "STATIC" .AND. hCtrl <> 0
            hCtrl = GetWindow( hCtrl, 2 )
         end
         return hCtrl
      else
         hCtrl = GetWindow( hCtrl, 2 )
      endif
   end

return 0



UTILITY STATIC function TDialog_Help( nWParam, nLParam) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   local hWndChild := HelpCtrlHwnd( nLParam ), nAtChild

   static lShow := .F.

   ::lHelpIcon = .F.

   if ! lShow
      lShow = .T.
      if ( nAtChild := AScan( ::aControls, { | o | o:hWnd == hWndChild } ) ) <> 0
         ::aControls[ nAtChild ]:HelpTopic()
      else
         ::HelpTopic()
      endif
      lShow = .F.
   endif

return nil



UTILITY STATIC function TDialog_Initiate( hWndFocus, hWnd) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   local lFocus := .T., lResult, hCtrl, lEnd := .F., aRect

   if hWnd <> nil
      ::hWnd = hWnd
   endif

   if ! ::lModal



         ::Link()

   endif

   if ::lVbx
      if ! VbxInitDialog( ::hWnd, GetResources(), ::cResName )
         MsgAlert( "Error on VBX's initialization" )
      endif
   endif

   if ::oFont == nil
      ::GetFont()
   else
      ::SetFont( ::oFont )
   endif

   if ::lTransparent
      FixSays( ::hWnd )



      AEval( ::aControls, { | o | If( ! Upper( o:ClassName() ) $  "TGET;TMULTIGET;TBTNBMP;TCOMBOBOX;TWBROWSE;TCBROWSE;TXBROWSE;TLISTBOX", o:lTransparent := .T.,) } )
   endif









         ASend( ::aControls, "INITIATE()", ::hWnd )





      if ::lResize16 .AND. ! Empty( ::cResName )
         ::nWidth = ::nWidth * 1.16668
         hCtrl = GetWindow( ::hWnd, 5 )
         if hCtrl <> 0
            while ! lEnd
               aRect = GetCoors( hCtrl )



               SetWindowPos( hCtrl, 0, aRect[ 1 ], aRect[ 2 ] * 1.16668, ( aRect[ 4 ] - aRect[ 2 ] ) * 1.16668, aRect[ 3 ] - aRect[ 1 ], nOr( 4, 8, 16 ) )
               hCtrl = GetWindow( hCtrl, 2 )
               lEnd = ! ( ( hCtrl <> 0 ) .AND. ( GetParent( hCtrl ) == ::hWnd ) )
            end
         endif
      endif


   if ::lCentered
      WndCenter( ::hWnd )
   else
      if Empty( ::cResName ) .AND. Empty( ::cResData )
         ::Move( ::nTop, ::nLeft )
      endif
   endif

   if ::cCaption <> nil
      SetWindowText( ::hWnd, ::cCaption )
   endif

   if ! Empty( ::cResName )
      ::nStyle := GetWindowLong( ::hWnd, -16 )
   endif

   if lAnd( ::nStyle, 2097152 )
      ::oVScroll := TScrollBar():WinNew(,,, (!.F.) .OR. .T., Self,,,,,,,,, .F.,, )
   endif
   if lAnd( ::nStyle, 1048576 )
      ::oHScroll := TScrollBar():WinNew(,,, (!.T.), Self,,,,,,,,, .F.,, )
   endif

   if ::oIcon <> nil
      SendMessage( ::hWnd, 128, 0, ::oIcon:hIcon )
   endif

   if ::bInit <> nil
      lResult = Eval( ::bInit, Self )
      if ValType( lResult ) == "L" .AND. ! lResult
         lFocus = .F.
      endif
   endif

   ::Help95()

   ::AEvalWhen()

return lFocus



UTILITY STATIC function TDialog_EraseBkGnd( hDC) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   if ! Empty( ::bEraseBkGnd )
      return Eval( ::bEraseBkGnd, hDC )
   endif

   if ::oBrush <> nil
      FillRect( hDC, GetClientRect( ::hWnd ), ::oBrush:hBrush )
      return 1
   endif

return nil



UTILITY STATIC function TDialog_Close( nResult) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   if ! ::lModal
      if ValType( ::bValid ) == "B"
         if ! Eval( ::bValid, Self )



               return .F.

         endif
      endif
      ::nResult = nResult
      ::lVisible = .F.
      DestroyWindow( ::hWnd )
      return .T.
   endif

return nil



UTILITY STATIC function TDialog_KeyChar( nKey, nFlags) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   if nKey == 27
      if ::oWnd == nil

      else
         if ::oWnd:ChildLevel( TMdiChild() ) <> 0
            ::End()
         else
            if ::oWnd:ChildLevel( TDialog() ) <> 0
               ::End()
            elseif Upper( ::oWnd:ClassName() ) == "TMDIFRAME"
               ::End()
            else
               return ::TWindow:KeyChar( nKey, nFlags )
            endif
         endif
      endif
   else
      return ( ::TWindow:KeyChar( nKey, nFlags ) )
   endif

return nil



UTILITY STATIC function TDialog_KeyDown( nKey, nFlags) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   local n

   if nKey == 27
      if ::oWnd == nil
         ::End()
      else
         if ::oWnd:ChildLevel( TMdiChild() ) <> 0
            ::End()
         else
            if ::oWnd:ChildLevel( TDialog() ) <> 0
               ::End()

            elseif Upper( ::oWnd:ClassName() ) == "TMDIFRAME"
               ::End()

            else
               return ::TWindow:KeyDown( nKey, nFlags )
            endif
         endif
      endif
   else



      if !Empty( ::aFastKeys )
         for n := 1 to len( ::aFastKeys )
            if nKey == ::aFastKeys[ n, 1 ]
               Eval( ::aFastKeys[ n, 2 ] )
               Return nil
            end
         next
      end



      return ::TWindow:KeyDown( nKey, nFlags )

   endif

return nil



UTILITY STATIC function TDialog_MouseMove( nRow, nCol, nKeyFlags) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   if ::lHelpIcon <> nil .AND. ! ::lHelpIcon
      if ::oCursor <> nil
         WSetCursor( ::oCursor:hCursor )
      else
         CursorArrow()
      endif
   endif

   ::SetMsg( ::cMsg )

   ::CheckToolTip()

   if ::bMMoved <> nil
      return Eval( ::bMMoved, nRow, nCol, nKeyFlags )
   endif

return .F.



UTILITY STATIC function TDialog_Paint() ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   local uVal

   if ValType( ::bPainted ) == "B"
      uVal = Eval( ::bPainted, ::hDC, ::cPS, Self )
   endif

return uVal



UTILITY STATIC function TDialog_SetFont( oFont) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   local hDlg  := ::hWnd
   local hCtrl := GetWindow( hDlg, 5 )
   local hFont := If( ::oFont <> nil, ::oFont:hFont, 0 )

   ::TWindow:SetFont( oFont )

   if hFont <> 0
      while hCtrl <> 0 .AND. GetParent( hCtrl ) == hDlg
         SendMessage( hCtrl, 48, hFont, 1 )
         hCtrl = GetWindow( hCtrl, 2 )
      end
   endif

return nil



UTILITY STATIC function TDialog_SysCommand( nWParam, nLParam) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   if nWParam == 61536 .AND. ::lModal
      if GetCapture() <> 0
         ReleaseCapture()
      endif
      return .F.
   endif

   if nWParam == 61824
      ::lHelpIcon = .T.
      return .F.
   endif

return ::TWindow:SysCommand( nWParam, nLParam )



UTILITY STATIC function TDialog_Help95() ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   if ::lHelpIcon == nil .OR. ::lHelpIcon

      SetWindowLong( ::hWnd, -20, nOr( GetWindowLong( ::hWnd, -20 ), 1024 ) )
   endif

return nil



UTILITY STATIC function TDialog_HandleEvent( nMsg, nWParam, nLParam) ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   do case
      case nMsg == 272
           return ::Initiate( nWParam, nLParam )

      case nMsg == 15
           return ::Display()

      case nMsg == 792
           return ::PrintClient( nWParam )

      case nMsg == 513
           if ::lHelpIcon <> nil .AND. ::lHelpIcon
              ::Help()
           else
              return ::TWindow:HandleEvent( nMsg, nWParam, nLParam )
           endif

      otherwise
           return ::TWindow:HandleEvent( nMsg, nWParam, nLParam )
   endcase

return nil



UTILITY STATIC function TDialog_Disable() ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   CursorWait()

   ::bTmpValid := ::bValid
   ::bValid    := {|| .F. }

   aEval( ::aControls, { | oCtrl | if( oCtrl:ClassName <> "TSAY" .AND. oCtrl:ClassName <> "TBITMAP", oCtrl:Disable(), ) } )

RETURN ( Self )



UTILITY STATIC function TDialog_Enable() ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   ::bValid    := ::bTmpValid

   aEval( ::aControls, { | oCtrl | if( oCtrl:ClassName <> "TSAY" .AND. oCtrl:ClassName <> "TBITMAP", oCtrl:Enable(), ) } )

   CursorArrow()

RETURN ( Self )



UTILITY STATIC function TDialog_AEvalValid() ; local Self AS CLASS TDialog := QSelf() AS CLASS TDialog

   local n
   local lValid      := .T.
   local aControls   := ::aControls

   if aControls <> nil .AND. !Empty( aControls )
      for n = 1 to Len( aControls )
          if aControls[ n ] <> nil .AND. aControls[ n ]:bValid <> nil
             if !Eval( aControls[ n ]:bValid )
                lValid  := .F.
                ::aControls[ n ]:SetFocus()
             endif
         endif
      next
   endif

return ( lValid )
