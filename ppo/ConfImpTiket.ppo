#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 26 ".\Prg\ConfImpTiket.prg"
static oWndBrw
static dbfImpTik
static bEdit         := { |aTmp, aGet, dbfImpTik, oBrw, bWhen, bValid, nMode | EdtRec( aTmp, aGet, dbfImpTik, oBrw, bWhen, bValid, nMode ) }






STATIC FUNCTION OpenFiles()

   local lOpen       := .T.
   local oBlock      := ErrorBlock( {| oError | ApoloBreak( oError ) } )

   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "IMPTIK.DBF" ), ( cCheckArea( "IMPTIK", @dbfImpTik ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "IMPTIK.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   RECOVER

      msgStop( "Imposible abrir todas las bases de datos" )
      CloseFiles()
      lOpen          := .F.

   end

   ErrorBlock( oBlock )

RETURN ( lOpen )






STATIC FUNCTION CloseFiles()

   if dbfImpTik <> nil
      ( dbfImpTik )->( dbCloseArea() )
   end

   dbfImpTik  := nil
   oWndBrw    := nil

RETURN .T.






FUNCTION ConfImpTiket( oMenuItem, oWnd )

   local nLevel

   IIF( oMenuItem == nil, oMenuItem := "01090", ) ;
   IIF( oWnd == nil, oWnd := oWnd(), ) ;

   if oWndBrw == NIL





      nLevel            := nLevelUsr( oMenuItem )

      if nAnd( nLevel, 1 ) <> 0
         msgStop( "Acceso no permitido." )
         return nil
      end





      if oWnd <> nil
         SysRefresh(); oWnd:CloseAll(); SysRefresh()
      end





      if !OpenFiles()
         return Nil
      end





      AddMnuNext( "Balanzas", ProcName() )














   oWndBrw := TShell():New( 2, 10, 18, 70, "Balanzas",, oWnd,,, .F.,,, ( dbfImpTik ),,,,, {"Código", "Descripción"}, {||( WinAppRec( oWndBrw:oBrw, bEdit, dbfImpTik ) )}, {||( WinEdtRec( oWndBrw:oBrw, bEdit, dbfImpTik ) )}, {||( WinDelRec( oWndBrw:oBrw, dbfImpTik ) )}, {||( WinDupRec( oWndBrw:oBrw, bEdit, dbfImpTik ) )}, nil, nLevel, "Gauge_16", "WebTopGreen",,, .T. )

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodImp"
         :bEditValue       := {|| ( dbfImpTik )->cCodImp }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Descripción"
         :cSortOrder       := "cNomImp"
         :bEditValue       := {|| ( dbfImpTik )->cNomImp }
         :nWidth           := 280
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      oWndBrw:CreateXFromCode()





      oWndBrw:NewAt( "BUS",,, {||( oWndBrw:SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )

      oWndBrw:AddSeaBar()








      oWndBrw:NewAt( "NEW",,, {||( oWndBrw:RecAdd() )}, "(A)ñadir", "A",,, 2,, .F. )







      oWndBrw:NewAt( "DUP",,, {||( oWndBrw:RecDup() )}, "(D)uplicar", "D",,, 2,, .F. )







      oWndBrw:NewAt( "EDIT",,, {||( oWndBrw:RecEdit() )}, "(M)odificar", "M",,, 4,, .F. )







        oWndBrw:NewAt( "ZOOM",,, {||( WinZooRec( oWndBrw:oBrw, bEdit, dbfImpTik ) )}, "(Z)oom", "Z",,, 8,, .F. )







        oWndBrw:NewAt( "DEL",,, {||( oWndBrw:RecDel() )}, "(E)liminar", "E",,, 16,, .F. )





      oWndBrw:NewAt( "END",,, {||( oWndBrw:end() )}, "(S)alir", "S",,,,, .F. )

        oWndBrw:Activate(, oWndBrw:bLClicked, oWndBrw:bRClicked, oWndBrw:bMoved, oWndBrw:bResized, oWndBrw:bPainted, oWndBrw:bKeyDown, oWndBrw:bInit,,,,,,,,, {|| ( CloseFiles() )},, oWndBrw:bLButtonUp )

   else

        oWndBrw:SetFocus()

   end

RETURN NIL






STATIC FUNCTION EdtRec( aTmp, aGet, dbfImpTik, oBrw, bWhen, bValid, nMode )

   local oDlg
   local oPort
   local cPort
   local oBitsSec
   local oBitsParada
   local oBitsDatos
   local oBitsParidad
   local cBitsSec
   local cBitsParada
   local cBitsDatos
   local cBitsParidad
   local aBitsSec       := { "2400", "4800", "9600", "19200", "38400", "57600", "115200", "203400", "460800", "921600" }
   local aBitsParada    := { "0", "1", "2" }
   local aBitsDatos     := { "7", "8" }
   local aBitsParidad   := { "Sin paridad", "Paridad par", "Paridad impar" }
   local aPort          := { "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9", "COM10", "COM11", "COM12", "COM13", "COM14", "COM15", "COM16", "COM17", "COM18" }

   if nMode == 1
      cPort             := "COM1"
      cBitsSec          := "9600"
      cBitsParada       := "0"
      cBitsDatos        := "8"
      cBitsParidad      := "Sin paridad"
      aTmp[ ( dbfImpTik )->( FieldPos( "nRetardo" ) ) ]  := 0
   else
      cPort             := aTmp[ ( dbfImpTik )->( FieldPos( "cPort" ) ) ]
      cBitsSec          := Str( aTmp[ ( dbfImpTik )->( FieldPos( "nBitsSec" ) ) ] )
      cBitsParada       := Str( aTmp[ ( dbfImpTik )->( FieldPos( "nBitsPara" ) ) ] )
      cBitsDatos        := Str( aTmp[ ( dbfImpTik )->( FieldPos( "nBitsDatos" ) ) ] )
      cBitsParidad      := aTmp[ ( dbfImpTik )->( FieldPos( "cBitsPari" ) ) ]
   end



   oDlg = TDialog():New(,,,, LblTitle( nMode ) + " balanzas", "Balanza",, .F.,,,,,, .F.,,,,,, .F., )










      aGet[ ( dbfImpTik )->( FieldPos( "cCodImp" ) ) ] := TGetHlp():ReDefine( 80, { | u | If( PCount()==0, aTmp[ ( dbfImpTik )->( FieldPos( "cCodImp" ) ) ], aTmp[ ( dbfImpTik )->( FieldPos( "cCodImp" ) ) ]:= u ) }, oDlg,, "@!", {||    ( NotValid( aGet[ ( dbfImpTik )->( FieldPos( "cCodImp" ) ) ], dbfImpTik, .T., "0" ) )},,,,,, .T., {||     ( nMode == 1 .OR. nMode == 4 )},, .F., .F.,,,,,, nil,,, )





      aGet[ ( dbfImpTik )->( FieldPos( "cNomImp" ) ) ] := TGetHlp():ReDefine( 90, { | u | If( PCount()==0, aTmp[ ( dbfImpTik )->( FieldPos( "cNomImp" ) ) ], aTmp[ ( dbfImpTik )->( FieldPos( "cNomImp" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )






      oPort := TComboBox():ReDefine( 160, { | u | If( PCount()==0, cPort, cPort:= u ) }, aPort, oDlg,,, {|Self|( oDlg:aEvalWhen() )},,,, .F., {||     ( nMode <> 3 )},,,,, )





      oBitsSec := TComboBox():ReDefine( 170, { | u | If( PCount()==0, cBitsSec, cBitsSec:= u ) }, aBitsSec, oDlg,,,,,,, .F., {||     ( nMode <> 3 )},,,,, )





      oBitsParada := TComboBox():ReDefine( 180, { | u | If( PCount()==0, cBitsParada, cBitsParada:= u ) }, aBitsParada, oDlg,,,,,,, .F., {||     ( nMode <> 3 )},,,,, )





      oBitsDatos := TComboBox():ReDefine( 190, { | u | If( PCount()==0, cBitsDatos, cBitsDatos:= u ) }, aBitsDatos, oDlg,,,,,,, .F., {||     ( nMode <> 3 )},,,,, )





      oBitsParidad := TComboBox():ReDefine( 200, { | u | If( PCount()==0, cBitsParidad, cBitsParidad:= u ) }, aBitsParidad, oDlg,,,,,,, .F., {||     ( nMode <> 3 )},,,,, )





      TButton():ReDefine( 552, {||( TestBalanza( cBitsSec, cBitsDatos, cBitsParada, cBitsParidad, cPort, aTmp[ ( dbfImpTik )->( FieldPos( "lOpenRead" ) ) ] ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )









      aGet[ ( dbfImpTik )->( FieldPos( "cActCentr" ) ) ] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ ( dbfImpTik )->( FieldPos( "cActCentr" ) ) ], aTmp[ ( dbfImpTik )->( FieldPos( "cActCentr" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )









      aGet[ ( dbfImpTik )->( FieldPos( "nRetardo" ) ) ] := TGetHlp():ReDefine( 210, { | u | If( PCount()==0, aTmp[ ( dbfImpTik )->( FieldPos( "nRetardo" ) ) ], aTmp[ ( dbfImpTik )->( FieldPos( "nRetardo" ) ) ]:= u ) }, oDlg,, "@E 9.99",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T., {||    aGet[ ( dbfImpTik )->( FieldPos( "nRetardo" ) ) ]:cText( aGet[ ( dbfImpTik )->( FieldPos( "nRetardo" ) ) ]:Value + .1 )}, {||  aGet[ ( dbfImpTik )->( FieldPos( "nRetardo" ) ) ]:cText( aGet[ ( dbfImpTik )->( FieldPos( "nRetardo" ) ) ]:Value - .1 )},,,, nil,,, )




      aGet[ ( dbfImpTik )->( FieldPos( "lOpenRead" ) ) ] := TCheckBox():ReDefine( 220, { | u | If( PCount()==0, aTmp[ ( dbfImpTik )->( FieldPos( "lOpenRead" ) ) ], aTmp[ ( dbfImpTik )->( FieldPos( "lOpenRead" ) ) ]:= u ) }, oDlg,,,,,,, .F.,, .F. )







      TButton():ReDefine( 553, {||( lDefecto( aGet, oPort, oBitsSec, oBitsParada, oBitsDatos, oBitsParidad ) )}, oDlg,,, .F., {||         ( nMode <> 3 )},,, .F. )







      TButton():ReDefine( 500, {||( EndTrans( aTmp, aGet, dbfImpTik, oBrw, nMode, oDlg, cPort, cBitsSec, cBitsParada, cBitsDatos, cBitsParidad ) )}, oDlg,,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 550, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )



   if nMode <> 3
      oDlg:AddFastKey( 116, {|| EndTrans( aTmp, aGet, dbfImpTik, oBrw, nMode, oDlg, cPort, cBitsSec, cBitsParada, cBitsDatos, cBitsParidad ) } )
   end

   oDlg:bStart    := {|| aGet[ ( dbfImpTik )->( FieldPos( "cCodImp" ) ) ]:SetFocus() }

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

RETURN ( oDlg:nResult == 1 )






STATIC FUNCTION EndTrans( aTmp, aGet, dbfImpTik, oBrw, nMode, oDlg, cPort, cBitsSec, cBitsParada, cBitsDatos, cBitsParidad )



   if nMode == 1 .OR. nMode == 4

      if Empty( aTmp[ ( dbfImpTik )->( FieldPos( "cCodImp" ) ) ] )
         MsgStop( "El código de la impresora no puede estar vacío" )
         aGet[ ( dbfImpTik )->( FieldPos( "cCodImp" ) ) ]:SetFocus()
         Return nil
      end

      if dbSeekInOrd( aTmp[ ( dbfImpTik )->( FieldPos( "cCodImp" ) ) ], "CCODIMP", dbfImpTik )
         msgStop( "Código existente" )
         return nil
      end

   end



   if Empty( aTmp[ ( dbfImpTik )->( FieldPos( "cNomImp" ) ) ] )
      MsgStop( "El nombre de la impresora no puede estar vacío" )
      aGet[ ( dbfImpTik )->( FieldPos( "cNomImp" ) ) ]:SetFocus()
      Return .F.
   end



   aTmp[ ( dbfImpTik )->( FieldPos( "cPort" ) ) ]      := cPort
   aTmp[ ( dbfImpTik )->( FieldPos( "nBitsSec" ) ) ]   := Val( cBitsSec )
   aTmp[ ( dbfImpTik )->( FieldPos( "nBitsPara" ) ) ]  := Val( cBitsParada )
   aTmp[ ( dbfImpTik )->( FieldPos( "nBitsDatos" ) ) ] := Val( cBitsDatos )
   aTmp[ ( dbfImpTik )->( FieldPos( "cBitsPari" ) ) ]  := cBitsParidad



   WinGather( aTmp, aGet, dbfImpTik, oBrw, nMode )

RETURN ( oDlg:end( 1 ) )






FUNCTION mkImpTik( cPath, lAppend, cPathOld, oMeter )

   local oImpTik

   IIF( cPath == nil, cPath := cPatDat(), ) ;
    IIF( lAppend == nil, lAppend := .F., ) ;

   oImpTik := DbfServer( "IMPTIK.DBF", ):New( "IMPTIK.DBF", "IMPTIK", ( cDriver() ), "Impresoras de tickets", ( cPath ) )

      oImpTik:AddField( "CCODIMP", "C", 3, 0,,,,, "Código de la impresora de ticket", .F.,, .F., {} )
      oImpTik:AddField( "CNOMIMP", "C", 35, 0,,,,, "Nombre de la impresora de ticket", .F.,, .F., {} )
      oImpTik:AddField( "LWIN", "L", 1, 0,,,,, "Lógico para utilizar driver de windows", .F.,, .F., {} )
      oImpTik:AddField( "CNOMPRN", "C", 254, 0,,,,, "Nombre de la impresora seleccionada", .F.,, .F., {} )
      oImpTik:AddField( "CPORT", "C", 50, 0,,,,, "Puerto de la impresora", .F.,, .F., {} )
      oImpTik:AddField( "NBITSSEC", "N", 6, 0,,,,, "Bit segundos", .F.,, .F., {} )
      oImpTik:AddField( "NBITSPARA", "N", 1, 0,,,,, "Bit de parada", .F.,, .F., {} )
      oImpTik:AddField( "NBITSDATOS", "N", 1, 0,,,,, "Bit de datos", .F.,, .F., {} )
      oImpTik:AddField( "CBITSPARI", "C", 50, 0,,,,, "Bit de paridad", .F.,, .F., {} )
      oImpTik:AddField( "CACTCENTR", "C", 50, 0,,,,, "Activar centrado", .F.,, .F., {} )
      oImpTik:AddField( "CDESCENTR", "C", 50, 0,,,,, "Desactivar centrado", .F.,, .F., {} )
      oImpTik:AddField( "CACTNEGR", "C", 50, 0,,,,, "Activar negrita", .F.,, .F., {} )
      oImpTik:AddField( "CDESNEGR", "C", 50, 0,,,,, "Desactivar negrita", .F.,, .F., {} )
      oImpTik:AddField( "CACTEXP", "C", 50, 0,,,,, "Activar expandida", .F.,, .F., {} )
      oImpTik:AddField( "CDESEXP", "C", 50, 0,,,,, "Desactivar expandida", .F.,, .F., {} )
      oImpTik:AddField( "CACTCOLOR", "C", 50, 0,,,,, "Activar color", .F.,, .F., {} )
      oImpTik:AddField( "CDESCOLOR", "C", 50, 0,,,,, "Desactivar color", .F.,, .F., {} )
      oImpTik:AddField( "CSALTO", "C", 50, 0,,,,, "Salto de página", .F.,, .F., {} )
      oImpTik:AddField( "CCORTE", "C", 50, 0,,,,, "Corte del papel", .F.,, .F., {} )
      oImpTik:AddField( "NRETARDO", "N", 4, 2, "@E 9.99",,,, "Tiempo de retardo", .F.,, .F., {} )
      oImpTik:AddField( "LOPENREAD", "L", 1, 0,,,,, "Lógico abrir el puerto cada lectura", .F.,, .F., {} )

      oImpTik:AddIndex( "CCODIMP", "IMPTIK.CDX", "CCODIMP",,, .F., .F.,,,, .T., .F. )



   oImpTik:Activate( .F., .F. )

   if lAppend .AND. lIsDir( cPathOld )

      if lExistTable( cPathOld + "IMPTIK.DBF" )

         oImpTik:AppendFrom( cPathOld + "IMPTIK.DBF" )

      end

   end

   oImpTik:end()

RETURN .T.




FUNCTION rxImpTik( cPath, oMeter )

   local dbfImpTik

   IIF( cPath == nil, cPath := cPatDat(), ) ;

   if !lExistTable( cPath + "IMPTIK.DBF" )
      mkImpTik( cPath )
   end

   if lExistIndex( cPath + "IMPTIK.CDX" )
      fErase( cPath + "IMPTIK.CDX" )
   end

   if lExistTable( cPath + "IMPTIK.DBF" )

      dbUseArea( .T., cDriver(), cPath + "IMPTIK.DBF", cCheckArea( "IMPTIK", @dbfImpTik ), .F. )

      if !( dbfImpTik )->( neterr() )

         ( dbfImpTik )->( __dbPack() )

         ( dbfImpTik )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
         ( dbfImpTik )->( ordCreate( cPath + "IMPTIK.CDX", "CCODIMP", "Field->cCodImp", {|| Field->cCodImp } ) )

         ( dbfImpTik )->( dbCloseArea() )

      else

         msgStop( "Imposible abrir en modo exclusivo impresoras de tickets" )

      end

   end

Return nil



Static Function lDefecto( aGet, oPort, oBitsSec, oBitsParada, oBitsDatos, oBitsParidad )



   oPort:oGet:cText(       "COM1" )
   oBitsSec:oGet:cText(    "9600" )
   oBitsParada:oGet:cText( "0" )
   oBitsDatos:oGet:cText(  "8" )
   oBitsParidad:oGet:cText("Sin paridad" )

   aGet[ ( dbfImpTik )->( FieldPos( "cActCEntr" ) ) ]:cText( Padr( "98000001" + Chr( 13 ) + Chr( 10 ) + Chr( 13 ) + Chr( 10 ), 100 ) )
   aGet[ ( dbfImpTik )->( FieldPos( "nRetardo"  ) ) ]:cText( 0 )



Return .T.






Static Function TestBalanza( cBitsSec, cBitsDatos, cBitsPara, cBitsPari, cPuerto, lOpenToRead )

  local oPrn



  oPrn   := TCommPort():New( cPuerto, cBitsSec, cBitsPara, cBitsDatos, cBitsPari, lOpenToRead )



  if oPrn:lCreated



      if oPrn <> nil








         msgInfo( "Puerto  : " + cPuerto                        + Chr(13)+Chr(10) + "Bit     : " + cBitsSec                       + Chr(13)+Chr(10) + "Parada  : " + cBitsPara                      + Chr(13)+Chr(10) + "Dato    : " + cBitsDatos                     + Chr(13)+Chr(10) + "Paridad : " + cBitsPari                      + Chr(13)+Chr(10) + "Handle  : " + AllTrim( Str( oPrn:nHComm ) )  + Chr(13)+Chr(10) + "Peso    : " + oPrn:cPeso(), "Puerto creado" )

         oPrn:End()

      end

   else







     msgStop( "Puerto  : " + cPuerto               + Chr(13)+Chr(10) + "Bit     : " + cBitsSec              + Chr(13)+Chr(10) + "Parada  : " + cBitsPara             + Chr(13)+Chr(10) + "Dato    : " + cBitsDatos            + Chr(13)+Chr(10) + "Paridad : " + cBitsPari             + Chr(13)+Chr(10) + "Handle  : " + AllTrim( Str( oPrn:nHComm ) ), "Puerto no creado" )

   end

Return .T.






FUNCTION BrwBalanza( oGet, oGet2 )

    local oDlg
    local oBrw
    local oGet1
    local cGet1
    local oCbxOrd
   local aCbxOrd        := { "Código" }
   local cCbxOrd        := "Código"
   local nLevel         := nLevelUsr( "01090" )

   if !OpenFiles()
      Return .F.
   end

   oDlg = TDialog():New(,,,, "Seleccionar balanzas", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F., )






   oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,, {||    ( OrdClearScope( oBrw, dbfImpTik ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, dbfImpTik ) ) }, .F., .F.,,,,,, nil, "FIND",, )






   oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,, {|Self|( ( dbfImpTik )->( OrdSetFocus( oCbxOrd:nAt ) ), oBrw:Refresh(), oGet1:SetFocus() )},,,, .F.,,,,,, )

   oBrw                 := TXBrowse():New( oDlg )

   oBrw:nMarqueeStyle   := 5
   oBrw:lHScroll        := .F.
   oBrw:cAlias          := dbfImpTik

   oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
   oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }
   oBrw:bLDblClick      := {|| oDlg:end( 1 ) }

   oBrw:CreateFromResource( 105 )

   with object ( oBrw:AddCol() )
      :cHeader          := "Código"
      :cSortOrder       := "cCodImp"
      :bEditValue       := {|| ( dbfImpTik )->cCodImp }
      :nWidth           := 80
      :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
   end

   with object ( oBrw:AddCol() )
      :cHeader          := "Descripción"
      :cSortOrder       := "cNomImp"
      :bEditValue       := {|| ( dbfImpTik )->cNomImp }
      :nWidth           := 280
      :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
   end





   TButton():ReDefine( 500, {||( WinAppRec( oBrw, bEdit, dbfImpTik ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 2 ) <> 0 )},,, .F. )





   TButton():ReDefine( 501, {||( WinEdtRec( oBrw, bEdit, dbfImpTik ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 4 ) <> 0 )},,, .F. )




   TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

   oDlg:AddFastKey( 113,       {|| if( nAnd( nLevel, 2 ) <> 0, WinAppRec( oBrw, bEdit, dbfImpTik ), ) } )
   oDlg:AddFastKey( 114,       {|| if( nAnd( nLevel, 4 ) <> 0, WinEdtRec( oBrw, bEdit, dbfImpTik ), ) } )
   oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )
   oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if oDlg:nResult == 1

      oGet:cText( ( dbfImpTik )->cCodImp )
      oGet:lValid()

      if ValType( oGet2 ) == "O"
         oGet2:cText( ( dbfImpTik )->cNomImp )
      end

   end

   DestroyFastFilter( dbfImpTik )

   CloseFiles()

   oGet:SetFocus()

RETURN ( .T. )




FUNCTION cBalanza( oGet, dbfImpTik, oGet2 )

   local lValid   := .F.
   local xValor   := oGet:VarGet()

   if Empty( oGet2 ) .AND. !Empty( oGet:oHelpText )
      oGet2       := oGet:oHelpText
   end

   if Empty( xValor )
      IIF( oGet2 <> nil, oGet2:cText( "" ), )
      return .T.
   else
      xValor   := RJustObj( oGet, "0" )
   end

   do case
      case Valtype( dbfImpTik ) == "C"

         if ( dbfImpTik )->( dbSeek( xValor ) )
            oGet:cText( ( dbfImpTik )->cCodImp )
            IIF( oGet2 <> nil, oGet2:cText( ( dbfImpTik )->cNomImp ), )
            lValid   := .T.
         else
            oGet:Refresh()
            msgStop( "Impresora no encontrada" )
         end

      case Valtype( dbfImpTik ) == "O"

         if dbfImpTik:Seek( xValor )
            oGet:cText( dbfImpTik:cCodImp )
            IIF( oGet2 <> nil, oGet2:cText( dbfImpTik:cNomImp ), )
            lValid   := .T.
         else
            oGet:Refresh()
            msgStop( "Impresora no encontrada" )
         end

   end

RETURN lValid




function IsImpTik()

   local oBlock
   local oError
   local dbfImpTik

   if !lExistTable( cPatDat() + "IMPTIK.DBF" )
      mkImpTik( cPatDat() )
   end

   if !lExistIndex( cPatDat() + "IMPTIK.CDX" )
      rxImpTik( cPatDat() )
   end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatDat() + "IMPTIK.DBF" ), ( cCheckArea( "IMPTIK", @dbfImpTik ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )


   ( dbfImpTik )->( __dbLocate( { || ( dbfImpTik )->cCodImp == "000" } ) )

   if!( dbfImpTik )->( Found() )

      ( dbfImpTik )->( dbAppend() )
      ( dbfImpTik )->cCodImp     := "000"
      ( dbfImpTik )->cNomImp     := "Impresora de tickets por defecto"
      ( dbfImpTik )->lWin        := .F.
      ( dbfImpTik )->cPort       := "COM1"
      ( dbfImpTik )->nBitsSec    := 9600
      ( dbfImpTik )->nBitsPara   := 0
      ( dbfImpTik )->nBitsDatos  := 8
      ( dbfImpTik )->cBitsPari   := "Sin paridad"
      ( dbfImpTik )->cActCentr   := "27 97 49"
      ( dbfImpTik )->cDesCentr   := "27 97 48"
      ( dbfImpTik )->cActNegr    := ""
      ( dbfImpTik )->cDesNegr    := ""
      ( dbfImpTik )->cActExp     := "27 33 16"
      ( dbfImpTik )->cDesExp     := "27 33 1"
      ( dbfImpTik )->cActColor   := "27 114 49"
      ( dbfImpTik )->cDesColor   := "27 114 48"
      ( dbfImpTik )->cSalto      := "27 100 5"
      ( dbfImpTik )->cCorte      := "27 105"
      ( dbfImpTik )->nRetardo    := 0
      ( dbfImpTik )->( dbUnLock() )

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   ( dbfImpTik )->( dbCloseArea() )

return ( .T. )





_HB_CLASS TCommPort ; UTILITY FUNCTION TCommPort(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TCommPort" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { cPort} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPort" }, .F., .F. ), )
   _HB_MEMBER {AS LOGIC lCreated} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .T., nScope + IIF( .F., 32, 0 ), { "lCreated" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nHComm} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nHComm" }, .F., .F. ), )
   _HB_MEMBER { cLastError} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cLastError" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nBitsSec} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nBitsSec" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nBitsParada} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nBitsParada" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nBitsDatos} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nBitsDatos" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nBitsParidad} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nBitsParidad" }, .F., .F. ), )
   _HB_MEMBER {AS LOGIC lOpenToRead} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .F., nScope + IIF( .F., 32, 0 ), { "lOpenToRead" }, .F., .F. ), )

   _HB_MEMBER { cBuffer} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cBuffer" }, .F., .F. ), )

   _HB_MEMBER New( cPort, nBitsSec, nBitsParada, nBitsDatos, nBitsParidad, lOpenToRead) AS CLASS TCommPort; IIF( .F., s_oClass:ModMethod( "New", @TCommPort_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TCommPort_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Create( cCodBalanaza); IIF( .F., s_oClass:ModMethod( "Create", @TCommPort_Create(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Create", @TCommPort_Create(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER lBuild(); IIF( .F., s_oClass:ModMethod( "lBuild", @TCommPort_lBuild(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lBuild", @TCommPort_lBuild(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER OpenCommError(); IIF( .F., s_oClass:ModMethod( "OpenCommError", @TCommPort_OpenCommError(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "OpenCommError", @TCommPort_OpenCommError(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Write( cTexto); IIF( .F., s_oClass:ModMethod( "Write", @TCommPort_Write(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Write", @TCommPort_Write(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Read(); IIF( .F., s_oClass:ModMethod( "Read", @TCommPort_Read(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Read", @TCommPort_Read(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Flush(); IIF( .F., s_oClass:ModMethod( "Flush", @TCommPort_Flush(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Flush", @TCommPort_Flush(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Close(); IIF( .F., s_oClass:ModMethod( "Close", @TCommPort_Close(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Close", @TCommPort_Close(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER End(); IIF( .F., s_oClass:ModInline( "End", {|Self | Self, ( ::Close() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "End", {|Self | Self, ( ::Close() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER nPeso(); IIF( .F., s_oClass:ModInline( "nPeso", {|Self | Self, ( Val( ::cPeso() ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "nPeso", {|Self | Self, ( Val( ::cPeso() ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )



   WITH OBJECT <|Self, nBitsSec|;

      if ValType( nBitsSec ) == "N"
         ::nBitsSec        := Alltrim( Str( nBitsSec ) )
      else
         ::nBitsSec        := Alltrim( nBitsSec )
      end

      RETURN ( ::nBitsSec )

   >; _HB_MEMBER SetBitsSec(); IIF( .F., s_oClass:ModInline( "SetBitsSec", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetBitsSec", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) ); END



   WITH OBJECT <|Self, nBitsParada|;

      if ValType( nBitsParada ) == "N"
         ::nBitsParada     := Alltrim( Str( nBitsParada ) )
      else
         ::nBitsParada     := Alltrim( nBitsParada )
      end

      RETURN ( ::nBitsParada )

   >; _HB_MEMBER SetBitsParada(); IIF( .F., s_oClass:ModInline( "SetBitsParada", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetBitsParada", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) ); END



   WITH OBJECT <|Self, nBitsDatos|;

      if ValType( nBitsDatos ) == "N"
         ::nBitsDatos      := Alltrim( Str( nBitsDatos ) )
      else
         ::nBitsDatos      := Alltrim( nBitsDatos )
      end

      RETURN ( ::nBitsDatos )

   >; _HB_MEMBER SetBitsDatos(); IIF( .F., s_oClass:ModInline( "SetBitsDatos", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetBitsDatos", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) ); END



   WITH OBJECT <|Self, cBitsParidad|;

      do case
         case Rtrim( cBitsParidad ) == "Sin paridad"
            ::nBitsParidad := "n"
         case Rtrim( cBitsParidad ) == "Paridad par"
            ::nBitsParidad := "p"
         case Rtrim( cBitsParidad ) == "Paridad impar"
            ::nBitsParidad := "i"
      end

      RETURN ( ::nBitsParidad )

   >; _HB_MEMBER SetBitsParidad(); IIF( .F., s_oClass:ModInline( "SetBitsParidad", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetBitsParidad", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) ); END



   WITH OBJECT <|Self|;

      local nWrite

      nWrite            := ::Write( "98000001" + Chr( 13 ) + Chr( 10 ) + Chr( 13 ) + Chr( 10 )  )

      if nWrite <= 0
         MsgInfo( "Error realizando la petición a la báscula : " + Str( GetCommError( ::nHComm ) ) )
      end

      RETURN ( Self )

   >; _HB_MEMBER Inicializa(); IIF( .F., s_oClass:ModInline( "Inicializa", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Inicializa", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) ); END



   WITH OBJECT <|Self|;

      local nKilos      := 0

      ::Read()

      if !Empty( ::cBuffer )
         nKilos         := Val( Substr( ::cBuffer, 4, 2 ) )
      end

      RETURN ( nKilos )

   >; _HB_MEMBER nKilos(); IIF( .F., s_oClass:ModInline( "nKilos", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "nKilos", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) ); END



   WITH OBJECT <|Self|;

      local nGramos     := 0

      ::Read()

      if !Empty( ::cBuffer )
         nGramos        := Val( Substr( ::cBuffer, 6, 3 ) )
      end

      RETURN ( nGramos )

   >; _HB_MEMBER nGramos(); IIF( .F., s_oClass:ModInline( "nGramos", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "nGramos", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) ); END



   WITH OBJECT <|Self|;

      local cPeso       := "0.000"

      ::Read()

      if !Empty( ::cBuffer )
         cPeso          := Substr( ::cBuffer, 4, 2 ) + "." + Substr( ::cBuffer, 6, 3 )
      end

      RETURN ( cPeso )

   >; _HB_MEMBER cPeso(); IIF( .F., s_oClass:ModInline( "cPeso", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "cPeso", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) ); END



; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TCommPort ;



UTILITY STATIC function TCommPort_New( cPort, nBitsSec, nBitsParada, nBitsDatos, cBitsParidad, lOpenToRead) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   IIF( cPort == nil, cPort := "COM1", ) ;
   IIF( nBitsSec == nil, nBitsSec := "9600", ) ;
   IIF( nBitsParada == nil, nBitsParada := "0", ) ;
   IIF( nBitsDatos == nil, nBitsDatos := "8", ) ;
   IIF( cBitsParidad == nil, cBitsParidad := "Sin paridad", ) ;
   IIF( lOpenToRead == nil, lOpenToRead := .F., ) ;

   ::cBuffer            := Space( 100 )
   ::lCreated           := .T.
   ::lOpenToRead        := lOpenToRead





   ::cPort              := Rtrim( cPort )





   ::SetBitsSec( nBitsSec )





   ::SetBitsParada( nBitsParada )





   ::SetBitsDatos( nBitsDatos )





   ::SetBitsParidad( cBitsParidad )





   if !::lOpenToRead
      ::lCreated        := ::lBuild()
   end

RETURN Self



UTILITY STATIC function TCommPort_Create( cCodBalanza) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local oBlock
   local oError

   local dbfImpTik

   oBlock                     := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "IMPTIK.DBF" ), ( cCheckArea( "IMPTIK", @dbfImpTik ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "IMPTIK.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      if !Empty( cCodBalanza ) .AND. ( dbfImpTik )->( dbSeek( cCodBalanza ) )

         ::cPort              := Rtrim( ( dbfImpTik )->cPort )
         ::lOpenToRead        := ( dbfImpTik )->lOpenRead

         ::SetBitsSec(        ( dbfImpTik )->nBitsSec )
         ::SetBitsParada(     ( dbfImpTik )->nBitsPara )
         ::SetBitsDatos(      ( dbfImpTik )->nBitsDatos )
         ::SetBitsParidad(    ( dbfImpTik )->cBitsPari )

      else

         ::cPort              := "COM1"
         ::nBitsSec           := "9600"
         ::nBitsParada        := "1"
         ::nBitsDatos         := "8"
         ::nBitsParidad       := "Sin paridad"
         ::lOpenToRead        := .F.

      end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if !Empty( dbfImpTik )
      ( dbfImpTik )->( dbCloseArea() )
   end

   dbfImpTik                  := nil

RETURN ( Self )



UTILITY STATIC function TCommPort_lBuild( lMessage) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local cDCB
   local lBuild         := .T.

   IIF( lMessage == nil, lMessage := .F., ) ;

   ::nHComm             := OpenComm( ::cPort, 1024, 128 )

   if ::nHComm > 0

      if !BuildCommDcb( ::cPort + ":" + ::nBitsSec +"," + ::nBitsParidad + "," + ::nBitsDatos + "," + ::nBitsParada, @cDCB )

         lBuild         := .F.

         if lMessage
            MsgStop( "Error abriendo el puerto : " + Str( GetCommError( ::nHComm ) ) )
         end

      else

         if !SetCommState( ::nHComm, cDCB )

            lBuild      := .F.

            if lMessage
               MsgStop( "Error en el estado del puerto : " + Str( GetCommError( ::nHComm ) ) )
            end

         endif

      end

   else

      ::OpenCommError()

      lBuild            := .F.

      if lMessage





         msgStop( "Puerto  : " + cValToChar( ::cPort )          + Chr(13)+Chr(10) + "Bits    : " + cValToChar( ::nBitsSec )       + Chr(13)+Chr(10) + "Parada  : " + cValToChar( ::nBitsParada )    + Chr(13)+Chr(10) + "Datos   : " + cValToChar( ::nBitsDatos )     + Chr(13)+Chr(10) + "Paridad : " + cValToChar( ::nBitsParidad ), ::cLastError )
      end

      ::Close()

   end

RETURN ( lBuild )



UTILITY STATIC function TCommPort_OpenCommError() ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   if ( ::nHComm >= 0 )
      ::cLastError         := "No error"
    else
        do case
         case ::nHComm == -1
            ::cLastError   := "ID: Inválido o no soportado"
         case ::nHComm == -12
            ::cLastError   := "BAUDIOS: No soportado"
         case ::nHComm == -11
            ::cLastError   := "BYTE: Tamaño no válido"
         case ::nHComm == -5
            ::cLastError   := "Valores por defecto son erroneos"
         case ::nHComm == -10
            ::cLastError   := "HARDWARE: No presente"
         case ::nHComm == -4
            ::cLastError   := "MEMORIA: Insuficiente"
         case ::nHComm == -3
            ::cLastError   := "HARDWARE: Dispositivo no abierto"
         case ::nHComm == -2
            ::cLastError   := "HARDWARE: Dispositivo ya abierto"
            otherwise
            ::cLastError   := "Error no determinado"
        endcase
    endif

Return ( ::nHComm )



UTILITY STATIC function TCommPort_Write( cTexto, nRetardo) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local nWrite      := 0
   local nLenTexto   := len( cTexto )

   IIF( nRetardo == nil, nRetardo := 0, ) ;

   nWrite            := WriteComm( ::nHComm, cTexto, nLenTexto )

   if nRetardo <> 0
      DlgWait( nRetardo )
   end

return ( nWrite )



UTILITY STATIC function TCommPort_Read( nRetardo) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local oWnd
   local nRead
   local cBuffer     := Space( 100 )

   IIF( nRetardo == nil, nRetardo := 0, ) ;

   oWnd              := TWindow():New( -100, -100, -100, -100 )
   oWnd:Activate()

   if ::lOpenToRead
      if !::lBuild()
         Return ( "" )
      end
   end

   ::Inicializa()

   Inkey( 0.1 )

   nRead             := ReadComm( ::nHComm, @cBuffer )

   if nRead <> 100
      cBuffer        := SubStr( cBuffer, 1, nRead )
   end

   ::cBuffer         := cBuffer

   if nRetardo <> 0
      DlgWait( nRetardo )
   end

   if !Empty( oWnd )
      oWnd:End()
   end

   if ::lOpenToRead
      ::Close()
   end

   SysRefresh()

return ( ::cBuffer )



UTILITY STATIC function TCommPort_Flush() ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   ::cBuffer         := ""

   if FlushComm( ::nHComm, 0 ) <> 0
      MsgStop( "Error vaciando el puerto : " + Str( GetCommError( ::nHComm ) ) )
   endif

return ( Self )



UTILITY STATIC function TCommPort_Close() ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   if !Empty( ::nHComm ) .AND. !CloseComm( ::nHComm )
      MsgStop( "Error cerrando el puerto : " + Str( GetCommError( ::nHComm ) ) )
   endif

return ( Self )
