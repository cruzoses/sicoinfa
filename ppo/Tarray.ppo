#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 14 ".\Prg\Tarray.prg"
STATIC aTArray



Function __StructNew( aInit )

 LOCAL oTArray, oTArrayPrevio
    oTArray:= TArray():New()
    If aInit <> Nil
       oTArray:aData:= aInit
    EndIf

    If aTArray == Nil
       aTArray:= { oTArray }
    Else
       oTArrayPrevio:= ATail( aTArray )
       oTArrayPrevio:aBuffer[ Len(oTArrayPrevio:aBuffer) ]:= oTArray
       Aadd( oTArrayPrevio:aFieldsObj, oTArray )
       Aadd( aTArray, oTArray )
    EndIf

return oTArray



Function __StructField( cName, uInit )

 LOCAL oTArray:= ATail( aTArray )
    oTArray:AddField( PadR( cName, 8 ), uInit )

return .T.



Function __StructEnd()

 LOCAL nLen:= Len( aTArray )
    If nLen == 1
       aTArray:= Nil
    Else
       ASize( aTArray, nLen - 1 )
    EndIf
return .T.


_HB_CLASS TArray ; UTILITY FUNCTION TArray(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TArray" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { aData} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aData" }, .F., .F. ), )
   _HB_MEMBER { aFields} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aFields" }, .F., .F. ), )
   _HB_MEMBER { aBuffer} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aBuffer" }, .F., .F. ), )
   _HB_MEMBER { lCheckUpper} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lCheckUpper" }, .F., .F. ), )
   _HB_MEMBER { aFieldsObj} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aFieldsObj" }, .F., .F. ), )

   _HB_MEMBER New() AS CLASS TArray; IIF( .F., s_oClass:ModMethod( "New", @TArray_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TArray_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AddField(); IIF( .F., s_oClass:ModMethod( "AddField", @TArray_AddField(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AddField", @TArray_AddField(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ArrayErrorHand(); s_oClass:SetOnError( @TArray_ArrayErrorHand() ) ;

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TArray ;




UTILITY STATIC function TArray_New() ; local Self AS CLASS TArray := QSelf() AS CLASS TArray

    ::aData       := {}
    ::aFields     := {}
    ::aBuffer     := {}
    ::aFieldsObj  := {}

return self



UTILITY STATIC function TArray_AddField( cName, uInit) ; local Self AS CLASS TArray := QSelf() AS CLASS TArray
    aAdd( ::aFields, Upper( cName ) )
    aAdd( ::aBuffer, uInit )
return .T.



UTILITY STATIC function TArray_ArrayErrorHand(cMethod, nError) ; local Self AS CLASS TArray := QSelf() AS CLASS TArray

 LOCAL lAssign:= .F.
 LOCAL nId
 LOCAL lExact:= Set( 1, .T. )
 LOCAL uDev

    If SubStr( cMethod, 1, 1 ) == "_"
       lAssign:= .T.
       cMethod:= SubStr( cMethod, 2 )
    EndIf

    If ::lCheckUpper
       AEval( ::aFields, {|cVal,nId| ::aFields[nId]:= Upper(cVal) } )
       ::lCheckUpper:= .F.
    EndIf

    If ( nId:= AScan( ::aFields, cMethod ) ) > 0
       If lAssign
          uDev:= GetParam( 1, 1 )
          ::aBuffer[ nId ]:= uDev
       Else
          uDev:= ::aBuffer[ nId ]
       EndIf
    Else
       uDev:= _ClsSetError( _GenError( nError, ::ClassName, cMethod ) )
    EndIf

    Set( 1, lExact )

return uDev
